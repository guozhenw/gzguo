<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/gzguo/2021/08/21/hello-world/"/>
    <url>/gzguo/2021/08/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">0.1. Quick Start</h2><h3 id="Create-a-new-post">0.1.1. Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">0.1.2. Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">0.1.3. Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">0.1.4. Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql语句</title>
    <link href="/gzguo/2021/08/20/DongR/mysql%E8%AF%AD%E5%8F%A5/"/>
    <url>/gzguo/2021/08/20/DongR/mysql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>回忆了ddl和dml的相关操作</p><span id="more"></span><h1 id="ddl">1. ddl</h1><h2 id="创建数据库">1.1. 创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">character set utf8 : 字符编码设置，创建数据库时使用</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">create</span> database dspt <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 切换数据库</span><br>use dspt;<br></code></pre></td></tr></table></figure><h2 id="创建表">1.2. 创建表</h2><ol><li>创建用户表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users(<br>uid <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY</span> KEY auto_increment comment <span class="hljs-string">&#x27;用户编号&#x27;</span>,<br>uname <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>upwd <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>ulevel <span class="hljs-type">int</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;等级，1管理员，0会员用户&#x27;</span>,<br>createtime <span class="hljs-type">timestamp</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>updatetime <span class="hljs-type">timestamp</span> comment <span class="hljs-string">&#x27;修改时间&#x27;</span><br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>创建类型表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> type(<br>tid <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;商品编号&#x27;</span>,<br>tname <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;类型名&#x27;</span>,<br>createtime <span class="hljs-type">timestamp</span> comment<span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>updatetime <span class="hljs-type">timestamp</span> comment <span class="hljs-string">&#x27;修改时间&#x27;</span><br>)comment <span class="hljs-string">&#x27;商品类型表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>创建商品表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods(<br>gid <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;商品编号&#x27;</span>,<br>gname <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;商品名&#x27;</span>,<br>tid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;类型编号&#x27;</span>,<br>gprice <span class="hljs-type">decimal</span>(<span class="hljs-number">9</span>,<span class="hljs-number">2</span>) comment <span class="hljs-string">&#x27;商品进价&#x27;</span>,<br>sellprice <span class="hljs-type">decimal</span>(<span class="hljs-number">9</span>,<span class="hljs-number">2</span>) comment <span class="hljs-string">&#x27;商品售价&#x27;</span>,<br>stocknumber <span class="hljs-type">decimal</span>(<span class="hljs-number">9</span>,<span class="hljs-number">2</span>) comment <span class="hljs-string">&#x27;库存数量&#x27;</span>,<br>stockunit <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) comment <span class="hljs-string">&#x27;库存单位&#x27;</span>,<br>sellnumber <span class="hljs-type">decimal</span>(<span class="hljs-number">9</span>) comment <span class="hljs-string">&#x27;销售数量&#x27;</span>,<br>describes <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) comment <span class="hljs-string">&#x27;商品描述&#x27;</span>,<br>gimg <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) comment <span class="hljs-string">&#x27;商品图片&#x27;</span>,<br>createtime <span class="hljs-type">timestamp</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>updatetime <span class="hljs-type">timestamp</span> comment <span class="hljs-string">&#x27;修改时间&#x27;</span><br>)comment <span class="hljs-string">&#x27;商品详情表&#x27;</span>;<br><span class="hljs-comment">-- 如果表结构有改动的话，可以先执行下面的语句删除表，再重新创建</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> goods;<br></code></pre></td></tr></table></figure><h1 id="dml">2. dml</h1><h2 id="增加">2.1. 增加</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">1</span>,now(),now());<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(uname,upwd,ulevel,createtime,updatetime) <br><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">1</span>,now(),now());<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(uname,upwd,ulevel,createtime,updatetime) <br><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;computer&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">0</span>,now(),now()),<br>(<span class="hljs-string">&#x27;mysql&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">0</span>,now(),now()),<br>(<span class="hljs-string">&#x27;min&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">0</span>,now(),now()),<br>(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">0</span>,now(),now()),<br>(<span class="hljs-string">&#x27;max&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-number">0</span>,now(),now());<br></code></pre></td></tr></table></figure><h2 id="修改">2.2. 修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改所有的用户密码为000000，没有任何条件</span><br>update users <span class="hljs-keyword">set</span> upwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;000000&#x27;</span><br>update users <span class="hljs-keyword">set</span> upwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;000000&#x27;</span> <span class="hljs-keyword">where</span> uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除">2.3. 删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除整个表的数据，没有任何条件</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;min&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="dql-查询">2.4. dql 查询</h2><h3 id="单表查询">2.4.1. 单表查询</h3><h4 id="select">2.4.1.1. select</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> now() <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;时间&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-number">12.3</span>;<br></code></pre></td></tr></table></figure><h4 id="select-from">2.4.1.2. select from</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 起别名的两种方式：直接空格 或者 用as，如果别名中有特殊字符的话用&quot;&quot;(双引号括起来)</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> uname 姓名,upwd <span class="hljs-keyword">as</span> 密码,ulevel &quot;等 级&quot; <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><h4 id="distinct：去重">2.4.1.3. distinct：去重</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> ulevel <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><h4 id="select-from-where">2.4.1.4. select from where</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**</span><br><span class="hljs-comment">比较运算符：&gt; &gt;= &lt; &lt;= &lt;&gt; =</span><br><span class="hljs-comment">逻辑运算符：not and or</span><br><span class="hljs-comment">特殊比较运算符：in </span><br><span class="hljs-comment">like </span><br><span class="hljs-comment">between and </span><br><span class="hljs-comment">  is null</span><br><span class="hljs-comment">not in</span><br><span class="hljs-comment">not like </span><br><span class="hljs-comment">not between and</span><br><span class="hljs-comment">is not null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">-- 查询到数第二个字符是a的用户信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <br><span class="hljs-keyword">where</span> uname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%a_&#x27;</span>;<br><br><span class="hljs-comment">-- 查询用户名为max、cat的用户信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;max&#x27;</span> <span class="hljs-keyword">or</span> uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cat&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uname <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;max&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);<br><br><span class="hljs-comment">-- 查询序号在2-5之间的用户信息，包含2和5</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uid <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uid <span class="hljs-operator">&gt;=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> uid <span class="hljs-operator">&lt;=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="排序">2.4.1.5. 排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 对姓名进行升序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> uname;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> uname <span class="hljs-keyword">asc</span>;<br><span class="hljs-comment">-- 对姓名进行降序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> uname <span class="hljs-keyword">desc</span>;<br><span class="hljs-comment">-- 对等级按照升序，对姓名按照降序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ulevel <span class="hljs-keyword">asc</span>,uname <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h4 id="limit-提取n条数据">2.4.1.6. limit 提取n条数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**</span><br><span class="hljs-comment">limit 每页的起始位置（第一页的起始位置从0开始），每页的条数 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 提取第一页的数据，每页数据3条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br>limit <span class="hljs-number">0</span>,<span class="hljs-number">3</span>;<br><span class="hljs-comment">-- 提取第二页的数据，每页数据3条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br>limit <span class="hljs-number">3</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="统计">2.4.1.7. 统计</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">count</span><br><span class="hljs-comment">max</span><br><span class="hljs-comment">min</span><br><span class="hljs-comment">sum</span><br><span class="hljs-comment">avg</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 求用户个数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(uid) <span class="hljs-keyword">from</span> users;   <span class="hljs-comment">-- 用这个最好</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(uname) <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(createtime) <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> users;   <span class="hljs-comment">-- 不推荐使用这个</span><br><span class="hljs-comment">-- 根据等级进行统计</span><br><span class="hljs-keyword">select</span> ulevel,<span class="hljs-built_in">count</span>(ulevel) <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ulevel;<br><span class="hljs-comment">-- 下面这种写法不严谨，不建议使用</span><br><span class="hljs-keyword">select</span> uname,ulevel,<span class="hljs-built_in">count</span>(ulevel) <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ulevel;<br><span class="hljs-comment">-- 根据等级进行统计,并且个数大于3</span><br><span class="hljs-comment">-- having 分组条件</span><br><span class="hljs-keyword">select</span> ulevel,<span class="hljs-built_in">count</span>(ulevel) <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ulevel<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(ulevel)<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="mysql语句的书写格式和关键字的执行顺序">2.4.1.8. mysql语句的书写格式和关键字的执行顺序</h4><blockquote><p>书写格式：</p></blockquote></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<br><span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">where</span> 非分组条件<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组<br><span class="hljs-keyword">having</span> 分组条件<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段<br>limit 提取<br></code></pre></td></tr></table></figure><blockquote><p>执行顺序：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">from</span>、<span class="hljs-keyword">where</span>、<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>、<span class="hljs-keyword">having</span>、<span class="hljs-keyword">select</span>、<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>、limit <br><span class="hljs-keyword">from</span>：把表里的所有数据提取出来<br><span class="hljs-keyword">where</span>：匹配<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>：分组<br><span class="hljs-keyword">having</span>：分组条件<br><span class="hljs-keyword">select</span>：拿到提取的结果<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>：对结果进行排序<br>limit：对排完序的结果进行提取<br></code></pre></td></tr></table></figure><h4 id="单行函数">2.4.1.9. 单行函数</h4><h5 id="字符函数">2.4.1.9.1. 字符函数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(uname,<span class="hljs-string">&#x27; &#x27;</span>,upwd,<span class="hljs-string">&#x27; &#x27;</span>,ulevel)<br> <span class="hljs-keyword">from</span> users;<br> <br><span class="hljs-keyword">select</span> uname,substr(uname,<span class="hljs-number">2</span>)   <span class="hljs-comment">-- substr:三个参数，第一个是截取的字段，第二个是位置，第三个是长度</span><br> <span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> uname,substr(uname,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br> <span class="hljs-keyword">from</span> users;<br> <br><span class="hljs-keyword">select</span> uname,length(uname)<br><span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><h5 id="数字函数">2.4.1.9.2. 数字函数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> round(<span class="hljs-number">12.356</span>,<span class="hljs-number">2</span>),   <span class="hljs-comment">-- round 四舍五入</span><br>round(<span class="hljs-number">12.356</span>,<span class="hljs-number">-1</span>),<br>round(<span class="hljs-number">12.356</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">12.356</span>,<span class="hljs-number">2</span>),   <span class="hljs-comment">-- truncate 截取</span><br><span class="hljs-keyword">truncate</span>(<span class="hljs-number">12.356</span>,<span class="hljs-number">-1</span>),<br><span class="hljs-keyword">truncate</span>(<span class="hljs-number">12.356</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">12.356</span>),<span class="hljs-built_in">floor</span>(<span class="hljs-number">12.356</span>);   <span class="hljs-comment">-- ceil 向上取整；floor 向下取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>),   <span class="hljs-comment">-- mod 取整；结果的正负和被除数有关</span><br><span class="hljs-built_in">mod</span>(<span class="hljs-number">-10</span>,<span class="hljs-number">3</span>),<br><span class="hljs-built_in">mod</span>(<span class="hljs-number">10</span>,<span class="hljs-number">-3</span>);<br></code></pre></td></tr></table></figure><h5 id="日期函数">2.4.1.9.3. 日期函数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(createtime),<span class="hljs-keyword">month</span>(createtime),<span class="hljs-keyword">day</span>(createtime)   <span class="hljs-comment">-- 提取年月日</span><br><span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now());<br></code></pre></td></tr></table></figure><h5 id="控制函数">2.4.1.9.4. 控制函数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> uname,<br>(<span class="hljs-keyword">case</span> ulevel <br><span class="hljs-keyword">when</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;会员用户&#x27;</span><br><span class="hljs-keyword">when</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;管理员&#x27;</span><br><span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;其他&#x27;</span><br><span class="hljs-keyword">end</span><br>) 等级<br><span class="hljs-keyword">from</span> users;<br><span class="hljs-keyword">select</span> uname,<br>(<span class="hljs-keyword">case</span>  <br><span class="hljs-keyword">when</span> ulevel<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;会员用户&#x27;</span>   <span class="hljs-comment">-- 不仅仅可以判断等于，其他的运算符也可以拿来应用</span><br><span class="hljs-keyword">when</span> ulevel<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;管理员&#x27;</span><br><span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;其他&#x27;</span>   <span class="hljs-comment">-- 既不是1又不是0的话，就是其他</span><br><span class="hljs-keyword">end</span><br>) 等级<br><span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure><h3 id="多表查询">2.4.2. 多表查询</h3><h4 id="等值连接">2.4.2.1. 等值连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> type t,goods g<br><span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> g.tid;<br></code></pre></td></tr></table></figure><h3 id="标准连接">2.4.3. 标准连接</h3><h4 id="交叉连接">2.4.3.1. 交叉连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> type <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> goods;<br></code></pre></td></tr></table></figure><h4 id="自然连接">2.4.3.2. 自然连接</h4><blockquote><p>自然连接使用的是相同的字段自动匹配，生成的字段是唯一的</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> type <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> goods;<br></code></pre></td></tr></table></figure><h4 id="using连接">2.4.3.3. using连接</h4><blockquote><p>两个表中必须有相同的字段，要选择相同的字段，生成之后保留一个</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> type <span class="hljs-keyword">join</span> goods<br><span class="hljs-keyword">using</span>(tid);<br></code></pre></td></tr></table></figure><h4 id="标准连接中的等值连接">2.4.3.4. 标准连接中的等值连接</h4><blockquote><p>连接条件在on后面</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> type t <span class="hljs-keyword">join</span> goods g<br><span class="hljs-keyword">on</span> t.tid<span class="hljs-operator">=</span>g.gid;<br></code></pre></td></tr></table></figure><h4 id="左连接和右连接">2.4.3.5. 左连接和右连接</h4><blockquote><p>左外连接：左边的所有的数据都存在，和右表匹配，匹配到的数据写上，右表没有匹配到的字段是空值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> type t <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> goods g<br><span class="hljs-keyword">on</span> t.tid<span class="hljs-operator">=</span>g.gid;<br></code></pre></td></tr></table></figure><blockquote><p>右外连接</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> type t <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> goods g<br><span class="hljs-keyword">on</span> t.tid<span class="hljs-operator">=</span>g.gid;<br></code></pre></td></tr></table></figure><h4 id="子查询">2.4.3.6. 子查询</h4><blockquote><p>不建议查询子查询，速度太慢；一般使用等值连接、标准连接、非等值连接等</p></blockquote><h5 id="where子查询">2.4.3.6.1. where子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与mysql同一等级的用户信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> ulevel<span class="hljs-operator">=</span>(<br><span class="hljs-keyword">select</span> ulevel<br><span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uname<span class="hljs-operator">=</span>&quot;mysql&quot;<br>);<br></code></pre></td></tr></table></figure><h5 id="相关子查询（快，查到之后不再往下查）">2.4.3.6.2. 相关子查询（快，查到之后不再往下查）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> users u1<br> <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<br><span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">from</span> users u2<br><span class="hljs-keyword">where</span> u2.uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br> <span class="hljs-keyword">and</span> u2.ulevel<span class="hljs-operator">=</span>u1.ulevel<br>);<br></code></pre></td></tr></table></figure><h5 id="from子查询">2.4.3.6.3. from子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br> <span class="hljs-keyword">from</span> users u,<br> (<br><span class="hljs-keyword">select</span> ulevel u1<br><span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> uname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br> ) um<br> <span class="hljs-keyword">where</span> um.u1<span class="hljs-operator">=</span>u.ulevel;<br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>DongR</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DongR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos安装mariadb</title>
    <link href="/gzguo/2021/08/20/DongR/%E5%9C%A8centos7%E4%B8%8A%E5%AE%89%E8%A3%85mysql/"/>
    <url>/gzguo/2021/08/20/DongR/%E5%9C%A8centos7%E4%B8%8A%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<p>linux的相关操作，安装了mariadb</p><span id="more"></span><h3 id="下载最小化的虚拟机之后的联网问题：">0.0.1. 下载最小化的虚拟机之后的联网问题：</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">nmcli <span class="hljs-keyword">c</span> show   显示网卡<br>nmcli <span class="hljs-keyword">c</span> up 网卡名   启动该网卡<br>ping -<span class="hljs-keyword">c</span> <span class="hljs-number">3</span> www.baidu.com   访问三次<br></code></pre></td></tr></table></figure><h3 id="下载mariadb">0.0.2. 下载mariadb</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum install -y mariadb-<span class="hljs-keyword">server</span> mariadb<br></code></pre></td></tr></table></figure><h3 id="下载好之后相关">0.0.3. 下载好之后相关</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">systemctl status mariadb   查看状态（和防火墙类似）<br>systemctl start mariadb   启动mariadb<br> <br>mysql -uroot   无密码登录<br>use mysql;   进入数据库<br>update user set password=password(<span class="hljs-string">&#x27;newpassword&#x27;</span>) where user=<span class="hljs-string">&#x27;root&#x27;</span>;   修改密码<br>flush privileges;   刷新权限<br><span class="hljs-keyword">exit</span>   退出<br><br>mysql -uroot -proot   再次登录需要输入密码<br></code></pre></td></tr></table></figure><h3 id="用navicat连接mariadb">0.0.4. 用navicat连接mariadb</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ip addr   查看ip地址<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>;   对root授权<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;ip地址&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>;   在数据库中为ip地址授权<br>flush <span class="hljs-keyword">privileges</span>;   授权之后记得刷新权限<br><br>systemctl status firewalld   查看防火墙状态<br>systemctl stop firewalld   关闭防火墙<br></code></pre></td></tr></table></figure><blockquote><p>老师的笔记网址：<br><a href="https://note.youdao.com/ynoteshare1/index.html?id=e2247fa8c88ba10fe7411d7f6cfc7c48&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=e2247fa8c88ba10fe7411d7f6cfc7c48&amp;type=note</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>DongR</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DongR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-7运行机制体系结构</title>
    <link href="/gzguo/2020/12/27/OS/1/1-7/"/>
    <url>/gzguo/2020/12/27/OS/1/1-7/</url>
    
    <content type="html"><![CDATA[<h4 id="1-7运行机制体系结构">0.0.0.1. 1-7运行机制体系结构</h4><span id="more"></span><h2 id="运行机制">0.1. 运行机制</h2><p>指令和代码：一行代码对应几行机器语言指令</p><p>由于安全性问题，将<strong>指令</strong>分为<strong>特权指令、非特权指令</strong></p><p>特权指令：内存清零，不允许用户程序使用</p><p>非特权指令：运算指令</p><p>判断CPU是否可以执行特权指令？<strong>处理机的两种状态</strong>：<strong>用户态（目态）、核心态（管态）</strong></p><p>处理机状态由程序状态字寄存器某个标志位来标识</p><p><strong>程序</strong>又被分为<strong>内核程序和应用程序</strong></p><h2 id="操作系统内核">0.2. 操作系统内核</h2><p>内核程序应该实现哪些功能？</p><p><strong>时钟管理、中断处理、原语</strong>（设备驱动、CPU切换）、<strong>对系统资源进行管理</strong>（进程管理、存储器管理、设备管理）</p><p>前面三个功能与硬件联系比较紧密，有的操作系统不会将最后一个划分到操作系统内核中</p><p>内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分</p><p>实现操作系统内核功能的程序就是<strong>内核程序</strong></p><h2 id="操作系统体系机构">0.3. 操作系统体系机构</h2><p>时钟管理、中断处理、原语、[对系统资源进行管理]</p><p>对于最后一个是否划分到内核中又争议，所以有了操作系统的体系结构</p><p>操作系统的体系结构：<strong>大内核、微内核</strong></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-1-5线程</title>
    <link href="/gzguo/2020/12/27/OS/2/2-1-5/"/>
    <url>/gzguo/2020/12/27/OS/2/2-1-5/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-5线程">0.0.0.1. 2-1-5线程</h4><span id="more"></span><h2 id="定义">0.1. 定义</h2><p>QQ可以进行很多的功能，但是进程是程序的一次执行</p><p>很多的功能不可能是由一个程序的顺序执行就能实现的</p><p>传统的进程是<strong>程序执行流</strong>的最小单位</p><p>因为有的进程可能需要同时执行很多的事情，而传统的进程只能串行的执行一系列程序。为此，<strong>引入了“线程”</strong>，来增加并发调度</p><p>引入了线程之后，<strong>线程就是程序执行流的最小单位，是一个基本的CPU执行单元</strong>。进程只作为除CPU之外的系统资源分配单元（<strong>系统资源是分配给进程的</strong>）。</p><h2 id="引入线程的变化">0.2. 引入线程的变化</h2><p>资源分配调度：<strong>进程是资源分配的基本单位，线程是调度的基本单位</strong></p><p>并发性：各线程之间也能并发，提升了并发速度</p><p>系统开销：系统开销减小（同一个进程内线程切换，不需要切换进程环境，系统开销小）</p><h2 id="线程的重要属性">0.3. 线程的重要属性</h2><ol><li>线程是处理机调度的单位</li><li>多个CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程之间共享进程的资源</li><li>由于共享内存地址空间，同意进程中的线程通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程的切换</li><li>不同的进程中的线程切换，会引起进程的切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销大</li></ol><h2 id="实现方式">0.4. 实现方式</h2><h3 id="用户级线程">0.4.1. 用户级线程</h3><p>由应用程序通过<strong>线程库</strong>来实现，所有的线程管理者工作都由应用程序负责（包括线程切换）</p><p>操作系统并意识不到线程的存在，但是用户可以感受到线程的存在</p><p>用户级线程就是从用户的视角可以看到的线程</p><h3 id="内核级线程">0.4.2. 内核级线程</h3><p>又称为 内核支持的线程</p><p>内核级的线程的管理工作由操作系统内核完成。内核级线程的切换必须在核心态下才能完成</p><p>内核级线程可以理解为从操作系统的角度可以看到的线程</p><p>内核级线程才是真正的处理机分配的单位</p><h2 id="多线程">0.5. 多线程</h2><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了”多线程模型“的问题</p><p>多线程模型：</p><ol><li>多对一：多个用户级线程对应一个内核级线程（并发性较弱，系统开销小）</li><li>一对一：并发性很强，占用资源太多</li><li>多对多：多对一和一对一的组合模式，更加合理</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-2-3调度算法的评价指标</title>
    <link href="/gzguo/2020/12/27/OS/2/2-2-3/"/>
    <url>/gzguo/2020/12/27/OS/2/2-2-3/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2-3调度算法的评价指标">0.0.0.1. 2-2-3调度算法的评价指标</h4><span id="more"></span><h2 id="系统利用率">0.1. 系统利用率</h2><p>利用率=忙碌时间/总时间</p><h2 id="系统吞吐量">0.2. 系统吞吐量</h2><p>单位时间内完成的作业的数量</p><p>系统吞吐量=总共完成了多少道作业/总共花了多长时间</p><h2 id="周转时间">0.3. 周转时间</h2><p>作业从提交给系统道作业完成的时间间隔</p><p>周转时间=作业完成时间-作业提交时间</p><p>平均周转时间=个作业周转时间之和/作业数</p><p>带权周转时间=作业周转时间/作业实际运行时间（越小越好，用户体验越好）</p><p>平均带权周转时间=各作业带权周转时间之和/作业数</p><h2 id="等待时间">0.4. 等待时间</h2><p>指进程/作业等待处理机状态时间之和，等待时间越长，用户满意度越低</p><p>对于作业来说：等待时间就是进程建立之后等待被服务的时间之和，等待IO完成期间也是被服务的，不算入等待时间</p><p>对于进程来说：不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</p><h2 id="响应时间">0.5. 响应时间</h2><p>用户提交请求道首次产生响应所用的时间</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-2-2进程调度</title>
    <link href="/gzguo/2020/12/27/OS/2/2-2-2/"/>
    <url>/gzguo/2020/12/27/OS/2/2-2-2/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2-2进程调度">0.0.0.1. 2-2-2进程调度</h4><span id="more"></span><h2 id="时机">0.1. 时机</h2><h3 id="主动放弃CPU">0.1.1. 主动放弃CPU</h3><ol><li>进程正常终止</li><li>运行过程发生异常而终止</li><li>进程主动请求阻塞（等待IO）</li></ol><h3 id="被动放弃CPU">0.1.2. 被动放弃CPU</h3><ol><li>分给进程的时间片用完</li><li>有更紧急的事情需要处理（IO中断）</li><li>有更高优先级的进程就如就绪队列</li></ol><h3 id="不能进行进程调度和切换">0.1.3. 不能进行进程调度和切换</h3><ol><li>在处理中断的过程中</li><li>进程在操作系统<strong>内核程序临界区</strong>中（再普通的临界区内可以进行调度与切换）</li><li>在原子操作过程中</li></ol><h2 id="切换与过程">0.2. 切换与过程</h2><p>狭义的进程调度：从就绪队列中<strong>选中</strong>一个要运行的进程</p><p>进程切换：一个程序让出处理机，让另一个进程占用处理机</p><p>广义的进程调度：包含了选择一个进程和进程切换两个步骤</p><p>进程切换的过程：完成了对原来运行进程各种数据的保存，对新的进程数据的恢复</p><h2 id="方式">0.3. 方式</h2><p>由当前运行的进程是否可以被强行剥夺处理机资源，引出了进程调度的两种方式</p><h3 id="非剥夺调度方式-非抢占">0.3.1. 非剥夺调度方式/非抢占</h3><p>只允许进程主动终止</p><p>实现简单，但是不能优先处理紧急的事情，适用于早期的</p><h3 id="剥夺调度方式-抢占">0.3.2. 剥夺调度方式/抢占</h3><p>允许被动放弃CPU</p><p>可以优先实现紧急的事情，适用于分时操作系统和实时操作系统</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-2-1处理机调度</title>
    <link href="/gzguo/2020/12/27/OS/2/2-2-1/"/>
    <url>/gzguo/2020/12/27/OS/2/2-2-1/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2-1处理机调度">0.0.0.1. 2-2-1处理机调度</h4><span id="more"></span><h2 id="定义">0.1. 定义</h2><p>某种规则来决定处理任务的顺序，这就是调度研究的问题</p><p>处理机调度：由于CPU个数远远小于进程数，不可能同时处理所有的进程。要<strong>从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</strong></p><h2 id="层次">0.2. 层次</h2><h3 id="高级调度（作业调度）">0.2.1. 高级调度（作业调度）</h3><p>作业=多个进程</p><p>由于内存有限，<strong>作业</strong>无法全部放入内存，需要某种规则来决定将作业调入内存的顺序</p><p>高级调度是<strong>外存与内存之间</strong>的调度</p><p>每个作业<strong>只调入一次调出一次</strong></p><p>作业调度时会创建相应的PCB，调出时才撤销PCB</p><h3 id="中级调度（内存调度）">0.2.2. 中级调度（内存调度）</h3><p>引入了虚拟存储技术之后，可以将暂时不能运行的<strong>进程</strong>调至外存等待。等他重新具备了运行条件且内存有空的时候，再重新调入内存</p><p>这样做的目的是<strong>提高内存的利用率和系统的吞吐量</strong></p><p>暂时调到外存的状态叫做<strong>挂起状态</strong>，进程被调出内存，但是PCB会常驻内存，因为操作系统还要对这些未执行完的进程进行管理（挂起–&gt;挂起队列）</p><p>中级调度发生的频率比高级调度高，因为一个进程可能会多次被调出、调入内存</p><p>这里引入了七状态模型，详情见补充知识</p><h3 id="低级调度（进程调度）">0.2.3. 低级调度（进程调度）</h3><p>主要任务是按照某种方法和策略从就绪队列中选取一个进程，将<strong>处理机</strong>分配给他</p><p>进程调度是最基本的一种调度，频率很高，一般几十毫秒一次</p><h2 id="调度联系、对比">0.3. 调度联系、对比</h2><p>高级调度（作业调度）：外存到内存（面向作业）（无到创建到就绪）</p><p>中级调度（内存调度）：外存到内存（面向进程）（挂起到就绪）</p><p>低级调度（进程调度）：<strong>内存–&gt;CPU</strong>（就绪到运行）</p><h2 id="补充知识">0.4. 补充知识</h2><p>与挂起状态相关的<strong>七状态模型</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">暂时调入到外存等待的进程状态为挂起状态<br>挂起态又可以分为就绪挂起、阻塞挂起两种<br></code></pre></td></tr></table></figure><p>五状态模型–&gt;七状态模型（新增两种状态）</p><p>就绪–&gt;挂起（就绪挂起）</p><p>阻塞–&gt;挂起（阻塞挂起）</p><p>阻塞挂起等待的事件出现–&gt;就绪挂起</p><p>创建态–&gt;就绪挂起</p><p>运行态–&gt;就绪挂起</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">挂起和阻塞的区别：<br>    两种都是暂时不能得到<span class="hljs-meta">CPU</span>服务<br>    挂起是将进程调入外存，而阻塞态下的进程还在内存中<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-2-4调度算法</title>
    <link href="/gzguo/2020/12/27/OS/2/2-2-4/"/>
    <url>/gzguo/2020/12/27/OS/2/2-2-4/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2-4调度算法">0.0.0.1. 2-2-4调度算法</h4><span id="more"></span><h2 id="先来先服务">0.1. 先来先服务</h2><p>FCFS（first come first serve）</p><p>公平，<strong>非抢占式</strong></p><p>对于作业调度和进程调度来说都一样，谁先来谁先进入内存</p><p>对长作业有利，对短作业不利</p><p>不会导致饥饿</p><h2 id="最短作业优先">0.2. 最短作业优先</h2><p>SJF（shortest job first）</p><p>最求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间</p><p>所谓的最短指的是执行时间/服务时间最短</p><p>有抢占式、也有非抢占式</p><p>抢占式的也叫”最短剩余时间优先算法“，题目中没有特别说明都默认是非抢占式的</p><p>每次调度的时候选择当前已经到达的且运行时间最短的作业/进程</p><p>对短作业有利，但是对长作业不利</p><p>可能产生长作业饥饿的问题</p><h2 id="最高响应比优先">0.3. 最高响应比优先</h2><p>HRRN（highest response ratio next）</p><p>综合考虑作业/进程的等待时间和要求服务时间</p><p>在每次调度时都要计算各个作业/进程的响应比，<strong>选择响应比高的作业/进程服务</strong></p><p>响应比=（等待时间+要求服务时间）/要求服务时间   要求服务时间就是执行时间</p><p><strong>非抢占式</strong>的</p><p>前两个算法的折中</p><p>不会导致饥饿</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-2-5分时系统的调度算法</title>
    <link href="/gzguo/2020/12/27/OS/2/2-2-5/"/>
    <url>/gzguo/2020/12/27/OS/2/2-2-5/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2-5分时系统的调度算法">0.0.0.1.  2-2-5分时系统的调度算法</h4><span id="more"></span><h2 id="时间片轮转">0.1. 时间片轮转</h2><p>RR（round robin）</p><p>公平、轮流为各个进程服务。让每个进程在一定时间间隔内都可以得到响应</p><p>按照时间片来进行执行，时间片的大小可能固定，也可以动态</p><p>只有进程调度才能使用这个算法</p><p><strong>抢占式</strong>的算法，通过<strong>时钟中断</strong>来通知CPU时间片已到</p><p>不会导致饥饿</p><h2 id="优先级调度">0.2. 优先级调度</h2><p>实时操作系统的出现，需要根据紧急程度来决定优先处理的顺序</p><p>每个作业/进程都有自己的优先级，调度是选择优先级最高的作业/进程</p><p>抢占式和非抢占式都有 </p><p>有静态优先级和动态优先级两种。静态优先级：创建进程时确定，之后一直不变。动态优先级：创建进程有一个初始值，之后会根据情况动态的调整优先级</p><p>如何合理的设置各类进程的优先级？</p><ol><li>系统进程优先级高于用户进程</li><li>前台进程的优先级高于后台进程</li><li>操作系统更偏好IO型进程（还有一类时计算型进程）</li></ol><p>比较适合用于实时操作系统</p><p>会发生饥饿</p><h2 id="多级反馈队列调度算法">0.3. 多级反馈队列调度算法</h2><p><strong>对所有上面的算法的折中权衡</strong></p><p><strong>抢占式</strong>的算法</p><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照FCFS原则分配时间片。如果时间片用完还没有执行完就进入下一级队列队尾。反复执行上面的过程。</p><p>可能会发生饥饿</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-1进程同步、互斥</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-1/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-1/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-1进程同步、互斥">0.0.0.1.  2-3-1进程同步、互斥</h4><span id="more"></span><h2 id="进程同步">0.1. 进程同步</h2><p>进程具有异步性的特征，异步性就是各并发执行的进程以各自独立的、不可预知的速度向前推进</p><p>有时候需要进程同步机制来实现进程之间的同步</p><p>进程同步就是用来解决进程异步的问题</p><p><strong>同步也称为直接制约关系</strong>，他们之间有一种相互制约的关系，这种制约关系源于他们之间的相互合作。</p><h2 id="进程互斥">0.2. 进程互斥</h2><p>临界资源：一个时间段内只允许一个进程使用的资源</p><p>互斥也成为间接制约关系，当资源被释放之后才可以被其他进程访问</p><p>对临界资源的互斥访问可以分为四个部分：<strong>进入区（上锁）、临界区（执行操作）、退出区（解锁）、剩余区（其余操作）</strong></p><p>为了实现对临界资源的互斥访问，同时保证系统的整体性能，需要遵循下面的规则：</p><ol><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：已被占用，其余的等待</li><li>有限等待：保证在有限的时间进入临界区</li><li>让权等待：不能进入临界区，就立即释放处理机</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-11管程</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-11/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-11/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-11管程">0.0.0.1.  2-3-11管程</h4><span id="more"></span><h2 id="为什么引入">0.1. 为什么引入</h2><p><strong>引入管程之前，实现进程和互斥的主要是信号量机制</strong>。但是信号量机制编写程序困难、容易出错。人们就像设计一种机制，让人们在写程序的时候，不再需要关心复杂的PV操作。</p><p>于是管程诞生，<strong>管程是一种高级同步的机制</strong></p><h2 id="定义和基本特征">0.2. 定义和基本特征</h2><p><strong>管程就好像用类把PV封装起来了</strong></p><p>为什么要互斥和同步？因为进程之间可能会共享某些资源</p><p>管程是一种特殊的软件模块，有以下部分组成：</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据进行操作的一组过程/函数</li><li>对局部于管程的共享数据设置初始值语句</li><li>管程有一个名字</li></ol><p>管程类似于类</p><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部与管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li></ol><h2 id="管程解决消费者生产者">0.3. 管程解决消费者生产者</h2><p>引入管程的目的就是要更加方便地实现进程地互斥和同步</p><ol><li>需要在管程中定义共享数据（如生产者消费者问题地缓冲区）</li><li>定义函数/入口</li><li>只有通过入口才能共享数据</li><li>每次只能开放一个入口，让一个进程访问（互斥特性由编译器实现）</li></ol><p>实际上就是使用了封装</p><h2 id="java中类似管程的机制">0.4. java中类似管程的机制</h2><p>java中的线程，多个线程调入函数，只有一个能访问到，其他的都在等待</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-2进程互斥软件实现</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-2/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-2/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-2进程互斥软件实现">0.0.0.1.  2-3-2进程互斥软件实现</h4><span id="more"></span><h2 id="单标志法">0.1. 单标志法</h2><p>每个进程进入临界区的权限只能被另一个进程赋予</p><p>虽然实现了互斥访问，但是违背了空闲让进原则</p><h2 id="双标志先检查">0.2. 双标志先检查</h2><p>设置boolean的数组，为true代表想进入临界区</p><p>检查别的进程有没有进入临界区的意愿，如果都没有的话，就把自己设置成想要进入临界区（上锁）</p><p>违背了忙则等待的原则</p><h2 id="双标志后检查">0.3. 双标志后检查</h2><p>先上锁后检查，解决了上面的先检查后上锁带来的问题-&gt;违背了忙则等待原则</p><p>虽然解决了忙则等待，但是违背了空闲让进和优先等待</p><h2 id="Peterson算法">0.4. Peterson算法</h2><p>解决上面算法，都抢着进入临界区的问题，孔融让梨</p><p>但是违背了让权等待的原则</p><p>相对来说是最好的</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-3进程互斥硬件实现</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-3/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-3/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-2进程互斥硬件实现">0.0.0.1.  2-3-2进程互斥硬件实现</h4><span id="more"></span><h2 id="中断屏蔽方法">0.1. 中断屏蔽方法</h2><p>开中断和关中断指令，类似于原语的实现方式</p><p>不适用于多处理机，只适合于内核进程</p><h2 id="TestAndSet（TS-TSL指令）">0.2. TestAndSet（TS/TSL指令）</h2><p>用硬件实现的，在执行的过程中只能一气呵成，不能中断</p><p>不满足让全等待原则，从而导致忙等</p><h2 id="Swap指令（XCHG指令）">0.3. Swap指令（XCHG指令）</h2><p>用硬件实现，中间不能中断</p><p>和上面的差不多</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-4信号量机制</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-4/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-4/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-4信号量机制">0.0.0.1.  2-3-4信号量机制</h4><span id="more"></span><p>迪杰斯特拉提出了信号量机制，是一种卓有成效的进程互斥、同步的方法</p><h2 id="信号量机制">0.1. 信号量机制</h2><p>用户进程可以通过操作系统提供的原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p><p>信号量就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用来标识系统中某种资源的数量</p><p>一对原语wait(S)、signal(S)   括号里的S就是信号量，可以理解为参数</p><p>wait和signal原语简称为P、V操作</p><h2 id="整形信号量">0.2. 整形信号量</h2><p>用整数来表示系统资源的数量，对信号量的操作只有三种初始化、P操作、V操作</p><p>检查和上锁一气呵成，避免了并发、异步导致的问题。但是还是不满足让全等待，会导致忙等现象</p><h2 id="记录型信号量">0.3. 记录型信号量</h2><p>解决上面的忙等的问题</p><p>加了block原语：主动阻塞，加入到等待队列   还有wakeup原语：唤醒等待队列中的程序</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-5信号量实现进程同步互斥</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-5/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-5/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-5信号量实现进程同步互斥">0.0.0.1.  2-3-5信号量实现进程同步互斥</h4><span id="more"></span><h2 id="信号量机制实现互斥">0.1. 信号量机制实现互斥</h2><p>P（加锁）、V（释放）操作必须成对出现，不同的临界资源需要设置不同的互斥信号量</p><p><strong>先设置P之后设置V</strong></p><h2 id="信号量实现进程同步">0.2. 信号量实现进程同步</h2><p><strong>在“前操作”之后执行V，在“后操作” 之前执行P</strong></p><h2 id="信号量机制实现前驱关系">0.3. 信号量机制实现前驱关系</h2><p>保证语句的执行一前一后，和上面的一样，比上面的复杂</p><ol><li>为每一个前驱关系设置一个同步变量</li><li>在前操作之后设置V</li><li>在后操作之前设置P</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-3-6生产者和消费者</title>
    <link href="/gzguo/2020/12/27/OS/2/2-3-6/"/>
    <url>/gzguo/2020/12/27/OS/2/2-3-6/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3-6生产者和消费者">0.0.0.1.  2-3-6生产者和消费者</h4><span id="more"></span><h2 id="生产者和消费者问题">0.1. 生产者和消费者问题</h2><p>系统中有一组生产者和消费者进程，生产者进程每次生产一个产品放入<strong>缓冲区</strong>，消费者进程每次从缓冲区取出一个产品并且使用</p><p>缓冲区是临界资源，必须互斥访问</p><p><strong>使用PV操作实现生产者消费者这些功能：</strong></p><p>一个同步一个互斥，实现互斥的P操作要放在实现同步的P操作之后，V操作顺序不会影响</p><h2 id="多生产者和多消费者">0.2. 多生产者和多消费者</h2><p>互斥信号量来实现生产者生产资源的问题</p><h2 id="吸烟者问题">0.3. 吸烟者问题</h2><p>先V后P</p><h2 id="读写者问题">0.4. 读写者问题</h2><h2 id="哲学家进餐问题">0.5. 哲学家进餐问题</h2><p>五个哲学家，只能吃饭和思考，每个人左右手边各一根筷子</p><p>需要持有两个临界资源才能吃饭，要避免死锁</p><ol><li>限制只能由四个哲学家同时进餐</li><li>奇数号哲学家只能拿左边的，偶数只能拿右边的</li><li>只有左右两只筷子都可以使用的时候再拿筷子（左右一起拿）</li></ol><p>哲学家进餐主要是为了解决死锁问题</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-4死锁</title>
    <link href="/gzguo/2020/12/27/OS/2/2-4/"/>
    <url>/gzguo/2020/12/27/OS/2/2-4/</url>
    
    <content type="html"><![CDATA[<h4 id="2-4死锁">0.0.0.1. 2-4死锁</h4><span id="more"></span><h1 id="死锁的概念">1. 死锁的概念</h1><h2 id="什么是死锁">1.1. 什么是死锁</h2><p>每个进程占有部分资源但又得不到剩余的资源</p><h2 id="死锁、饥饿、死循环">1.2. 死锁、饥饿、死循环</h2><p>死锁：进程间互相等待对方手里的资源，导致阻塞，无法向前推进（阻塞）</p><p>饥饿：长期得不到资源，无法向前推进（SPF：长进程饥饿）（就绪/阻塞）</p><p>死循环：某进程一直跳不出某个循环的现象，可能是BUG也可能是故意为之（可以是运行态）</p><h2 id="死锁产生的必要条件">1.3. 死锁产生的必要条件</h2><ol><li><p><strong>互斥条件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">只有对必须互斥使用的资源的争抢才会导致死锁<br></code></pre></td></tr></table></figure></li><li><p><strong>不可剥夺条件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">资源不能被抢走<br></code></pre></td></tr></table></figure></li><li><p><strong>请求和保持条件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">进程已经拥有一个资源，提出了新的资源请求。新的资源被阻塞，旧的资源不愿意释放<br></code></pre></td></tr></table></figure></li><li><p><strong>循环等待条件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">存在一种进程的循环等待链<br>死锁一定有循环等待，但是循环等待未必死锁<br></code></pre></td></tr></table></figure></li></ol><h2 id="什么时候会发生死锁">1.4. 什么时候会发生死锁</h2><ol><li>对资源的竞争</li><li>进程推进顺序非法</li><li>信号量使用不当（可以把同步、互斥信号量也看作是一种抽象的资源）</li></ol><h2 id="死锁的处理策略">1.5. 死锁的处理策略</h2><ol><li>预防死锁：破坏死锁产生的条件</li><li>避免死锁：防止系统进入不安全状态（银行家算法）</li><li>死锁的检测和解除：允许死锁发生，然后解除</li></ol><h1 id="预防死锁（静态策略）">2. 预防死锁（静态策略）</h1><h2 id="破坏互斥条件">2.1. 破坏互斥条件</h2><p>SPOOLing技术：操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</p><p>缺点：并不是所有的资源都可以改造成共享的。为了系统安全，很多地方必须保护互斥性</p><h2 id="破坏不剥夺条件">2.2. 破坏不剥夺条件</h2><p>当某个进程请求某个资源失败的话，就放弃手中的所有资源 或者 让操作系统帮他抢到他想要的资源</p><p>缺点：</p><ol><li>实现复杂</li><li>释放所有资源可能会导致之前一个阶段的工作失效。因此这种方式只适合一些容易保持和恢复状态的资源。</li><li>反复的申请和释放资源导致系统开销大，降低了系统的吞吐量</li><li>如果是第一种方法，可能会导致饥饿现象</li></ol><h2 id="破坏请求和保持条件">2.3. 破坏请求和保持条件</h2><p>静态分配方法：<strong>一旦申请就申请全部需要的资源</strong>，否则等待</p><p>缺点：可能导致饥饿，而且资源利用率会降低</p><h2 id="破坏循环等待条件">2.4. 破坏循环等待条件</h2><p>循序资源分配法：给系统中的资源编号，<strong>规定每个进程必须按编号递增的顺序请求资源</strong>，同类资源一次申请完。持有大编号的资源必然包含小编号的资源，不能形成循环</p><p>缺点：</p><ol><li>不方便新增设备，有可能重新分配所有设备</li><li>进程实际使用的资源顺序和编号递增的顺序不一致，会导致资源浪费</li><li>必须按照规定次序申请资源，用户变成麻烦</li></ol><h1 id="避免死锁（动态策略）">3. 避免死锁（动态策略）</h1><h2 id="什么是安全序列">3.1. 什么是安全序列</h2><p>系统按照安全序列的顺序分配资源，则每个进程都可以完成，只要找到一个安全序列，系统就是安全状态。可以有多个安全序列</p><p>系统找不到任何一个安全序列，那么系统就会进入不安全状态</p><p>如果系统处于安全状态，就一定不会发生死锁。如果进入不安全状态，就有可能会发生死锁</p><p><strong>银行家算法</strong>：在资源分配之前判断这次分配是否会导致系统进入不安全状态，已决定分配请求</p><p>银行家算法的步骤：</p><ol><li>检查申请的资源数是否大于声明的最大需求</li><li>检查系统资源是否能满足申请</li><li>开始分配，更改相应数据</li><li>用安全性算法检查此次分配是否会导致进入不安全状态</li></ol><p>安全性算法的步骤：检查当前的剩余可用资源是否满足某个进程，满足的话，就把这个进程加入安全序列，并把该进程的资源回收，反复执行上面的步骤</p><h1 id="检测和解除（允许死锁出现）">4. 检测和解除（允许死锁出现）</h1><p>为了可以对系统是否死锁进行检测，必须：</p><ol><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述的信息来检测系统是否死锁</li></ol><p>数据结构：资源分配图</p><ol><li><p>两种节点</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">进程节点：对应一个进程<br>资源节点：对应一类资源<br></code></pre></td></tr></table></figure></li><li><p>两种边</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">进程节点<span class="hljs-comment">--&gt;资源节点：标识进程想申请几个资源（每条边代表一个）</span><br>资源节点<span class="hljs-comment">--&gt;进程节点：标识为进程分配了几个资源（每条边代表一个）</span><br></code></pre></td></tr></table></figure></li></ol><p>如果按照某种顺序可以消除所有边，就成这个图是可以完全简化的，此时一定没有死锁发生（可以找到安全序列）</p><p>不能消除就会发生死锁 ，最终还连着边的进程就是处于死锁状态的进程</p><h2 id="解除死锁的方法">4.1. 解除死锁的方法</h2><ol><li><strong>资源剥夺法</strong>：挂起，暂时放到外存上</li><li><strong>撤销进程法</strong>：强制撤销进程</li><li><strong>进程回退法</strong>：回退到避免死锁的地步</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-1-2进程状态</title>
    <link href="/gzguo/2020/12/26/OS/2/2-1-2/"/>
    <url>/gzguo/2020/12/26/OS/2/2-1-2/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-2进程状态">0.0.0.1. 2-1-2进程状态</h4><span id="more"></span><h2 id="状态">0.1. 状态</h2><p>进程在执行的过程中，状态会有各种变化，为了方便进程的管理，操作系统需要将进程合理的划分为几种状态</p><p>其中运行、就绪、阻塞是最基本的三种状态</p><h3 id="运行">0.1.1. 运行</h3><p>占用CPU，并在CPU上运行</p><h3 id="就绪">0.1.2. 就绪</h3><p>已经具备运行条件，但是由于没有空闲的CPU，暂时不能运行</p><p>拥有了除了处理机之外的所有资源</p><h3 id="阻塞">0.1.3. 阻塞</h3><p>因等待某一事件而暂时不能运行</p><h3 id="创建">0.1.4. 创建</h3><p>程序开始之前需要进行创建，系统为其分配资源、初始化PCB</p><h3 id="终止">0.1.5. 终止</h3><p>程序执行结束或者出现bug之后需要终止/撤销，系统回收进程拥有的资源、撤销PCB</p><h2 id="状态之间的转换">0.2. 状态之间的转换</h2><p>创建==&gt;就绪==&gt;运行==&gt;阻塞==&gt;就绪==&gt;运行==&gt;终止</p><p>注意：</p><ol><li>不能由阻塞直接转换为运行状态（进入阻塞是进程主动请求的，需要进程在<strong>运行时</strong>才能发出）</li><li>不能由运行直接转换为阻塞状态</li><li>就绪到运行：进程被调度</li><li>运行到就绪：时间片到/CPU被其他高优先级的进程抢占</li><li>运行到阻塞：等待系统分配资源/等待事件发生（主动行为）</li><li>阻塞到就绪：资源分配到位，等待事件发生（被动行为）</li><li>创建到就绪：系统完成创建今晨改的相关工作</li><li>运行到终止：进程运行结束，或者出现不可修复的错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-1-3进程控制</title>
    <link href="/gzguo/2020/12/26/OS/2/2-1-3/"/>
    <url>/gzguo/2020/12/26/OS/2/2-1-3/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-3进程控制">0.0.0.1. 2-1-3进程控制</h4><span id="more"></span><h2 id="基本概念">0.1. 基本概念</h2><h3 id="定义">0.1.1. 定义</h3><p>进程控制就是对系统中的所有进程实施有效的管理。主要是创建进程、撤销进程、实现<strong>进程之间状态转换</strong>等的功能</p><h3 id="如何实现">0.1.2. 如何实现</h3><p>用原语实现<strong>进程控制</strong></p><p>因为进程控制的过程中，要进行进程状态的切换，切换的时候需要更改进程控制块的相关信息，更改需要更改对应的好几条信息，为了防止更改的不对应性。我们使用原语来实现进程控制。</p><p>原语的特点就是执行期间不能被中断，只能一气呵成。这种不可被中断的操作就是原子操作。</p><p>原语是采用<strong>关中断指令</strong>和<strong>开中段指令</strong>实现的。<u>如果执行关中断指令之后有外部中断信号进入，那么外部中断信号会被忽略</u>，这就是原语执行不会被中断的原因</p><p>关中断和开中断的权限非常大，所以这两个指令只允许在核心态下执行==&gt;原语运行在核心态</p><h2 id="进程控制相关原语">0.2. 进程控制相关原语</h2><p>无论是什么原语都无非做三类事情：</p><ol><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h3 id="创建">0.2.1. 创建</h3><p>创建原语：（创建态）</p><ol><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ol><p>引起进程创建的事件：</p><ol><li>用户登陆</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ol><h3 id="终止">0.2.2. 终止</h3><p>撤销原语：（终止态）</p><ol><li>从PCB集合中找到终止进程的PCB</li><li>若程序正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或者操作系统</li><li>删除PCB</li></ol><p>引起进程终止的事件：</p><ol><li>正常结束</li><li>异常结束</li><li>外界干预</li></ol><h3 id="阻塞">0.2.3. 阻塞</h3><p>阻塞原语：（运行到阻塞）</p><ol><li>找到阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为”阻塞态“，暂停进程运行</li><li>将PCB插入到相应进程的等待队列</li></ol><p>引起进程阻塞的事件：</p><ol><li>需要等待系统分配某种资源</li><li>需要等待相互配合工作的其他进程完成工作</li></ol><h3 id="唤醒">0.2.4. 唤醒</h3><p>唤醒原语：（阻塞到就绪）</p><ol><li>在事件等待队列中找到对应的PCB</li><li>将PCB从等待队列删除，设置进程为就绪态</li><li>将PCB插入到就绪队列，等待被掉度</li></ol><p>引起进程唤醒的事件：</p><ol><li>等待事件的发生（因为什么被阻塞就因为什么被唤醒）</li></ol><h3 id="切换">0.2.5. 切换</h3><p>切换原语：（运行态到阻塞赛/就绪态 // 就绪态到运行态）</p><ol><li>将运行环境信息存入PCB</li><li>PCB移入相应的队列</li><li>选择另一个进程执行，并更新PCB</li><li>根据PCB恢复进程所需的运行环境</li></ol><p>引起进程切换的事件：</p><ol><li>当前的进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-1-4进程通信</title>
    <link href="/gzguo/2020/12/26/OS/2/2-1-4/"/>
    <url>/gzguo/2020/12/26/OS/2/2-1-4/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-4进程通信">0.0.0.1. 2-1-4进程通信</h4><span id="more"></span><p>进程通信就是进程之间的信息交换</p><p>进程是分配系统资源的单位，各进程拥有的内存地址空间是相对独立的</p><p>为了保证安全，进程之间不允许互相访问</p><p>但是进程之间的信息交换又是必须实现的，为了保证进程之间的安全通信，操作系统提供了一些方法</p><p>下面就是操作系统提供的三种进程通信的方式</p><h2 id="共享存储">0.1. 共享存储</h2><p>系统为两个进程分配一个共享空间，两个进程可以<strong>互斥的访问</strong>共享空间</p><p>互斥访问通过操作系统提供的同步互斥工具实现（P、V操作）</p><h3 id="基于数据结构的共享">0.1.1. 基于数据结构的共享</h3><p><strong>对每次传递的数据格式有限制</strong>，是一种低级的通信方式</p><h3 id="基于存储区的共享">0.1.2. 基于存储区的共享</h3><p>操作系统只提供共享存储区，数据结构、存放位置等的信息都由进程控制，相比之下，这是一种高级通信的方式</p><h2 id="管道通信">0.2. 管道通信</h2><p>管道就是特殊的共享文件/pipe文件（实质就是在内存中开辟一个固定大小的<strong>缓冲区</strong>）</p><p>注意：</p><ol><li>管道只能采用<strong>半双工通信</strong>（只能单向传输，想要实现双向可以设置两个管道）</li><li>各进程要互斥的访问管道</li><li>管道写满，写进程阻塞，等待读进程全部读走，管道变空，读进程阻塞</li><li>没有写满不能读，没有空不允许写</li><li>数据一旦被读出就会消失，所以<strong>读进程只能有一个</strong></li></ol><h2 id="消息传递">0.3. 消息传递</h2><p>进程间的数据交换以<strong>格式化的消息</strong>为单位，通过<strong>发送/接收消息两个原语</strong>进行数据交换</p><p>格式化的消息：<strong>消息头、消息体</strong></p><h3 id="直接通信方式">0.3.1. 直接通信方式</h3><p>消息直接挂到接收进程的<strong>消息缓冲队列上</strong></p><h3 id="间接通信方式">0.3.2. 间接通信方式</h3><p>消息先发送到<strong>中间实体（信箱）</strong>，也成为“信箱通信方式”</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-1-1进程定义</title>
    <link href="/gzguo/2020/12/25/OS/2/2-1-1/"/>
    <url>/gzguo/2020/12/25/OS/2/2-1-1/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-1进程定义">0.0.0.1. 2-1-1进程定义</h4><span id="more"></span><h2 id="定义">0.1. 定义</h2><p>进程是为了解决什么问题而引入的？</p><p>先讲<strong>程序</strong>：就是一个指令序列</p><p>早期还是单道程序执行的时候，所有的资源都是一个程序的，不需要记录程序的存放位置。内存中只有<strong>程序段和数据段</strong>。</p><p>随着出现了多道程序技术，需要对程序的存放位置等的进行记录。系统会为每个运行的程序配置一个<strong>数据结构</strong>，这个数据结构称为<strong>程序控制块（PCB）</strong>，用来描述进程的各种信息（存储位置等）。内存中的<strong>程序段、数据段和进程控制块</strong>三部分构成了进程实体（进程映像）</p><p>一般来说，我们可以把进程实体称之为<strong>进程</strong>，所谓的创建进程，实际上就是创建进程实体中的PCB；撤销进程就是撤销进程实体中的PCB。</p><p>严格来说，进程实体和进程还是有区别的，进程实体是静态的，进程则是动态的。</p><p>注意：PCB是进程存在的唯一标志</p><p>从不同的角度，进程有不同的定义：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol><h2 id="组成">0.2. 组成</h2><p>每个进程由哪些部分组成？</p><p>进程是由程序段、数据段和PCB三部分组成的</p><ol><li>程序段：程序代码</li><li>数据段：程序运行时使用、产生的运算数据</li><li>PCB：操作系统对进程管理所需的各种信息</li></ol><p>PCB中的信息：</p><ol><li>进程描述信息（进程标识符id、用户标识符id）</li><li>进程控制和管理信息（进程当前状态、进程优先级）</li><li>资源分配清单（程序段指针、数据段指针、键盘、鼠标）</li><li>处理机相关信息（各种寄存器值）</li></ol><h2 id="组织方式">0.3. 组织方式</h2><p>系统间的各个进程使如何被组织起来的？</p><p>进程的组成讨论进程内部，进程组织讨论进程之间</p><h3 id="链接方式">0.3.1. 链接方式</h3><p>根据状态将PCB分为多个队列，操作系统持有队列指针</p><ol><li>执行指针：CPU中正在运行的进程</li><li>就绪队列指针：指向当前处于就绪态的进程</li><li>阻塞队列指针：指向处于阻塞状态的进程</li></ol><h3 id="索引方式">0.3.2. 索引方式</h3><p>根据状态建立索引表，操作系统持有表的指针</p><ol><li>执行指针</li><li>就绪表指针</li><li>阻塞表指针</li></ol><h2 id="特征">0.4. 特征</h2><p>相比于程序，进程有哪些特征？</p><ol><li><strong>动态性</strong>：进程是程序的一次执行过程，是动态产生、变化和消亡的</li><li><strong>并发性</strong>：内存中有多个进程实体，各进程可以并发执行</li><li><strong>独立性</strong>：进程可以独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性</strong>：不可预知的速度向前推进。操作系统提供“进程同步机制”来解决异步的问题</li><li><strong>结构性</strong>：每个进程都会配置一个PCB。结构上看，进程=程序段+数据段+PCB</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-1-2内存管理</title>
    <link href="/gzguo/2020/12/25/OS/3/3-1-2/"/>
    <url>/gzguo/2020/12/25/OS/3/3-1-2/</url>
    
    <content type="html"><![CDATA[<h4 id="3-1-2内存管理">0.0.0.1. 3-1-2内存管理</h4><span id="more"></span><h2 id="内存空间的分配与回收">0.1. 内存空间的分配与回收</h2><p>操作系统怎么记录内存的分配情况</p><p>很多位置可以分配，具体该分配哪一块</p><p>运行结束之后，如何回收进程占用的内存</p><p>方法：</p><h3 id="连续分配">0.1.1. 连续分配</h3><p>连续分配：为用户进程分配的必须是一个连续的内存空间</p><ol><li><p>单一连续分配</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">内存被分为系统区和用户区。系统区通常在低地址部分，用于存放操作系统进程的相关数据。用户区用于存放用户进程的相关数据，用户程序独占整个用户区空间。<br>优点：实现简单，没有外部碎片，不需要内存保护<br>缺点：有内部碎片<br></code></pre></td></tr></table></figure></li><li><p>固定分区分配</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">分为固定分区，每个分区中只能装入一道作业，可以分区大小相等，也可以是分区大小不等<br>分区说明表：对内存中的分区进行说明（用数据结构来表示）<br>优点：实现简单，没有外部碎片<br>缺点：程序太大要采用覆盖技术、会产生内部碎片内存利用率低<br></code></pre></td></tr></table></figure></li><li><p>动态分区分配</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">可变分区分配：不会预先划分内存分区，而是在进程装入内存的时候，根据进程大小动态的建立分区<br></code></pre></td></tr></table></figure></li></ol><h3 id="非连续分配">0.1.2. 非连续分配</h3><h2 id="内存空间扩充">0.2. 内存空间扩充</h2><p>从逻辑上对内存进行扩充</p><p>技术：</p><ol><li><p>覆盖技术</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">内存中分为一个固定区和若干个覆盖区<br>需要常驻内存段放在固定区中 ，调入后就不再调出（除非运行结束）<br>不常用的端放在覆盖区，需要用到时调入内存，用不到时调出内存<br></code></pre></td></tr></table></figure></li><li><p>交换技术</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">内存空间紧张时，系统将内存中的某些进程暂时换出内存，把外存中某些具备运行条件的进程换入内存<br>存在一个对换区<br>注意：PCB是常驻内存的，不会被换出<br></code></pre></td></tr></table></figure></li><li><p>虚拟存储技术</p></li></ol><h2 id="地址转换">0.3. 地址转换</h2><p>为了使程序员写程序方便，程序员写程序时应该只关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（地址重定位）应该由操作系统负责，这样就保证了程序员不再关注物理内存</p><p>这里有三种装入方式（绝对、可重定位、动态运行时）</p><h2 id="内存保护">0.4. 内存保护</h2><p>用户进程不能访问操作系统的内存空间，也不能访问其他进程的空间</p><p>方法：</p><ol><li>上下限寄存器</li><li>重定位寄存器（基址寄存器）、界地址寄存器（限长寄存器）-&gt;存放进程的最大逻辑地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-1-1内存基础</title>
    <link href="/gzguo/2020/12/25/OS/3/3-1-1/"/>
    <url>/gzguo/2020/12/25/OS/3/3-1-1/</url>
    
    <content type="html"><![CDATA[<h4 id="3-1-1内存基础">0.0.0.1. 3-1-1内存基础</h4><span id="more"></span><h2 id="什么是内存">0.1. 什么是内存</h2><p>内存是用于存放数据的硬件，程序执行前先放到内存中才能被CPU处理</p><h3 id="存储单元">0.1.1. 存储单元</h3><p>类似于酒店给房间编号，内存也给他所管理的内存编号，每个编号就代表一个存储单元，编号就是内存地址</p><p>存储单元的大小取决于计算机是按字节编址还是按照字编址</p><h3 id="内存地址">0.1.2. 内存地址</h3><h2 id="进程运行的基本原理">0.2. 进程运行的基本原理</h2><h3 id="指令的工作原理">0.2.1. 指令的工作原理</h3><p>指令需要有参数，参数中有地址</p><p>这里为了方便引入了逻辑地址（相对地址）</p><p>有时候只关心绝对地址（物理地址）</p><h3 id="逻辑地址和物理地址">0.2.2. 逻辑地址和物理地址</h3><p>起始位置+相对位置=物理位置</p><h3 id="从写程序到程序运行">0.2.3. 从写程序到程序运行</h3><p>编译：由编译程序将用户源代码编译成若干<strong>目标模块</strong>（把高级语言翻译成机器语言）</p><p>链接：将编译形成的模块链接起来形成<strong>装入模块</strong></p><p>装入：将装入模块放入内存中</p><h3 id="三种链接方式">0.2.4. 三种链接方式</h3><ol><li>静态链接：链接起来之后不再拆开</li><li>装入时动态链接：边装入边链接</li><li>运行时动态链接：运行的时候进行链接</li></ol><h3 id="三种装入方式">0.2.5. 三种装入方式</h3><ol><li>绝对装入：只适合单道程序环境</li><li>静态重定位（可重定位装入）：由装入程序负责地址的转变，作业在进入内存的时候必须分配他所需要的全部的内存空间，没有足够的内存，不能装入该作业</li><li>动态重定位（动态运行时装入）：地址的转变留到正式运行的时候才会进行，使用重定位寄存器来存放装入模块的起始位置（允许程序在内存中发生移动）</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-2操作系统概念</title>
    <link href="/gzguo/2020/12/24/OS/1/1-2/"/>
    <url>/gzguo/2020/12/24/OS/1/1-2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-2操作系统概念">0.0.0.1. 1-2操作系统概念</h4><span id="more"></span><h2 id="定义（概念）">0.1. 定义（概念）</h2><p>为了理解计算机系统的概念，先了解一下计算机系统的层次结构：</p><p>由下至上：裸机、操作系统、应用程序、用户（用户可以与操作系统直接交互）</p><p>裸机：CPU、内存、硬盘</p><p>操作系统：windows ios macos android linux</p><p>应用程序：QQ、IE、LOL、吃鸡</p><p>定义：</p><p>以操作系统为中心往两边看：操作系统负责管理和协调硬件软件等计算机资源的工作</p><p>自下往上看：为上层的应用程序、用户提供简单易用的服务</p><p>自上往下看：操作系统是系统软件，而不是硬件</p><h2 id="功能和目标">0.2. 功能和目标</h2><h3 id="资源管理者">0.2.1. 资源管理者</h3><p>目标：安全、高效（作为中间层）</p><p>补充知识：进程是一个程序的执行过程，执行前需要将该进程放到内存中，才能被CPU处理</p><p>和朋友用qq聊天的过程：</p><ol><li>在各个文件夹下找到QQ安装的位置（操作系统的文件管理）</li><li>双击打开qq.exe（将程序相关的内容放到内存==&gt;操作系统的存储器管理/内存管理）</li><li>QQ程序正常打开（相应的进程被处理机/CPU处理==&gt;操作系统处理机/CPU管理）</li><li>开始和朋友聊天（将摄像头分配给进程==&gt;操作系统的设备管理）</li></ol><p>以上就是操作系统作为系统资源管理者需要做的事情</p><h3 id="向用户提供服务">0.2.2. 向用户提供服务</h3><p>目标：方便使用（自下往上看）</p><p>需要提供：</p><ol><li>命令接口：允许用户直接使用（分为<strong>联机命令接口</strong>和<strong>脱机命令接口</strong>）</li><li>程序接口/<strong>系统调用</strong>/广义指令：允许用户通过程序间接使用（.dll）</li><li>GUI：现代操作系统中最流行的图形用户接口</li></ol><p>联机命令接口：用户说一句，系统做一句</p><p>脱机命令接口：用户说一堆，系统做一堆（批处理.bat）</p><p>上面的这三个接口也叫做：用户接口</p><h3 id="对硬件及其的扩展">0.2.3. 对硬件及其的扩展</h3><p>目标：对硬件机器的扩展能力（自上往下看）</p><p>覆盖了软件的机器叫做扩充机器，又称之为虚拟机</p><p>将基础的工具组装成强大的方便用户使用的，封装性，对硬件进行扩展</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-4操作系统发展与分类</title>
    <link href="/gzguo/2020/12/24/OS/1/1-4/"/>
    <url>/gzguo/2020/12/24/OS/1/1-4/</url>
    
    <content type="html"><![CDATA[<h4 id="1-4操作系统发展与分类">0.0.0.1. 1-4操作系统发展与分类</h4><span id="more"></span><h2 id="操作系统的发展过程">0.1. 操作系统的发展过程</h2><p>各个阶段的优点就是上一个阶段的缺点</p><h3 id="手工操作阶段">0.1.1. 手工操作阶段</h3><p>CPU执行快、输入慢</p><p>人机速度矛盾导致资源利用率低</p><h3 id="批处理阶段">0.1.2. 批处理阶段</h3><h4 id="单道批处理">0.1.2.1. 单道批处理</h4><p>引入了<strong>脱机输入/输出技术</strong>，<strong>监督程序</strong>控制作业输入输出</p><p>上面的监督程序就是后期操作系统的雏形</p><p>缓解了一定程度的人机矛盾</p><p>但是内存中同时只能有一个程序运行，只能串行。CPU只能等待很长时间来等待I/O完成，资源利用率低</p><h4 id="多道批处理系统">0.1.2.2. 多道批处理系统</h4><p>操作系统的诞生</p><p>引入了<strong>中断技术</strong>，操作系统负责管理这些程序的运行，各个程序并发执行。使得系统利用率大幅度提升</p><p>但是没有人机交互的能力，出错没法调试，只能等待执行结束</p><h3 id="分时操作系统">0.1.3. 分时操作系统</h3><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端来与计算机进行交互</p><p>但是分时操作系统对每一个用户/作业是完全公平的，不能优先处理一些紧急的任务</p><h3 id="实时操作系统">0.1.4. 实时操作系统</h3><p>可以优先响应紧急任务，某些紧急任务不需要时间片排队</p><p>主要特点是<strong>及时性</strong>和<strong>可靠性</strong></p><p>实时操作系统可以分为：</p><ol><li>硬实时系统：必须在绝对严格的规定时间内完成处理（导弹、自动驾驶）</li><li>软实时系统：能接受偶尔违反时间规定（12306订票）</li></ol><p>之后的操作系统不考，可以百度了解</p><h3 id="网络操作系统">0.1.5. 网络操作系统</h3><h3 id="分布式操作系统">0.1.6. 分布式操作系统</h3><h3 id="个人计算机操作系统">0.1.7. 个人计算机操作系统</h3>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-3操作系统特征</title>
    <link href="/gzguo/2020/12/24/OS/1/1-3/"/>
    <url>/gzguo/2020/12/24/OS/1/1-3/</url>
    
    <content type="html"><![CDATA[<h4 id="1-3操作系统特征">0.0.0.1. 1-3操作系统特征</h4><span id="more"></span><h1 id="操作系统的四个特征">1. 操作系统的四个特征</h1><h2 id="并发">1.1. 并发</h2><p>并发和共享是最基本的特征，二者互为存在条件</p><p>并行：同时刻进行 （多核）</p><p>并发：实际上交替进行，宏观上同时发生 （单核）</p><h2 id="共享">1.2. 共享</h2><p>系统中的资源供多个并发执行的程序共同使用</p><h3 id="两种共享方式">1.2.1. 两种共享方式</h3><ol><li>互斥共享方式：一个时间内，只允许一个进程使用</li><li>同时共享方式：一个时间内，允许多个进程使用</li></ol><h2 id="虚拟">1.3. 虚拟</h2><p>虚拟技术/空分复用技术：运行内存扩充（虚拟存储器技术）</p><p>虚拟技术/时分复用技术：多个程序同时运行（虚拟处理器技术）</p><h2 id="异步">1.4. 异步</h2><p>程序是走走停停的</p><p>虚拟和异步建立在并发和共享的基础上</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-5中断和异常</title>
    <link href="/gzguo/2020/12/24/OS/1/1-5/"/>
    <url>/gzguo/2020/12/24/OS/1/1-5/</url>
    
    <content type="html"><![CDATA[<h4 id="1-5中断和异常">0.0.0.1. 1-5中断和异常</h4><span id="more"></span><h2 id="中断机制的诞生">0.1. 中断机制的诞生</h2><p>串行的计算机资源利用率太低，所以人们发明了操作系统，引入<strong>中断机制</strong>，实现了多道程序并发执行</p><p>只要发生中断就需要操作系统介入，开展管理工作</p><h2 id="中断的概念和作用">0.2. 中断的概念和作用</h2><ol><li>中断发生之后，CPU会立即进入<strong>核心态</strong></li><li>中断发生之后，当前进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>操作系统的管理工作需要使用特权指令，需要核心态。中断可以使CPU进入核心态。有了中断，才能实现多道程序的并发执行</p><p>用户态和核心态只能通过中断来实现，中断是唯一条件</p><h2 id="中断的分类">0.3. 中断的分类</h2><h3 id="内中断">0.3.1. 内中断</h3><p>就是异常、例外；<strong>陷入</strong></p><p>信号来源：CPU内部，<strong>与当前执行的指令有关</strong></p><p>可以分为：自愿中断、强迫中断</p><p>自愿中断—&gt;指令中断：系统调用时使用的访管指令（陷入指令trap指令）（系统有意为止）</p><p>强迫中断—&gt;硬件故障（缺页）/软件故障（整除零）</p><h3 id="外中断">0.3.2. 外中断</h3><p>指的是狭义的中断</p><p>信号来源：CPU外部，与当前执行的指令无关</p><p>可以分为：<strong>外设请求、人工干预</strong></p><p>外设请求—&gt;I/O操作完成发出的中断信号</p><p>人工干预—&gt;用户强制终止一个程序</p><h2 id="外中断的处理过程">0.4. 外中断的处理过程</h2><ol><li>每个用户程序的指令执行完之后，CPU都需要检查当前是否有外部中断信号</li><li>如果检测到外部中断信号，则需要保护被中断的进程CPU环境</li><li>根据中断信号类型转入相应的中断处理程序（核心态）</li><li>恢复原来进程的CPU环境并退出中断，返回原程序继续往下运行</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-6系统调用</title>
    <link href="/gzguo/2020/12/24/OS/1/1-6/"/>
    <url>/gzguo/2020/12/24/OS/1/1-6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-6系统调用">0.0.0.1. 1-6系统调用</h4><span id="more"></span><h2 id="概念">0.1. 概念</h2><p>可以被应用程序（程序/程序员）调用的接口，可以理解为一种可提供应用程序调用的特殊函数</p><p>应用程序可以发出系统调用来请求获得操作系统的服务</p><p>打印机：没有系统调用的话，打印的内容会混杂</p><p>由于很多的共享资源都是由操作系统统一掌管的，所以用户程序不能随意访问。只能通过<strong>系统调用</strong>的方式来提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户非法操作</p><p>系统调用（按功能分类）：</p><ol><li>设备管理</li><li>文件管理</li><li>进程管理</li><li>进程通信</li><li>内存管理</li></ol><h2 id="系统调用和库函数">0.2. 系统调用和库函数</h2><p>汇编语言会提供一些系统调用的函数</p><p>但是我们现在使用的是一些高级语言，高级语言把相应的系统函数封装在了库函数中，使得高级语言直接调用库函数即可，不需要再使用汇编的那种复杂方式</p><p><strong>系统调用要在核心态下才能进行</strong></p><h2 id="过程">0.3. 过程</h2><p>高级语言经过编译之后会形成等价的汇编语言</p><p>汇编语言中会有各种：将<strong>参数放入寄存器</strong>、<strong>执行陷入指令</strong>等的操作实现相应的功能</p><p>操作系统可以通过<strong>系统调用号</strong>来实现对指令的识别</p><p>具体的过程：</p><ol><li>传递系统调用参数（高级语言）</li><li>执行陷入指令（用户态/汇编语言）</li><li>执行相应的系统调用和相应的服务程序（核心态/系统代码）</li><li>返回用户程序</li></ol><p>注意事项：</p><ol><li><strong>陷入指令是在用户态执行的</strong>，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li>发出系统调用请求是在用户态，系统调用的相关代码处在核心态</li><li><strong>陷入指令是唯一一个只能在用户态执行的指令</strong>（不能在核心态执行）</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-1大题</title>
    <link href="/gzguo/2020/12/22/OS/1/1-1/"/>
    <url>/gzguo/2020/12/22/OS/1/1-1/</url>
    
    <content type="html"><![CDATA[<center>1-1大题</center><span id="more"></span><h2 id="缺页">0.1. 缺页</h2><h3 id="先进先出FIFO">0.1.1. 先进先出FIFO</h3><p>在CPU中呆的时间最长的先出去（看下面）</p><h3 id="最佳置换算法OPT">0.1.2. 最佳置换算法OPT</h3><p>淘汰<strong>未来</strong>最长时间内不再被访问的页面（作业的页面走向右面）</p><h3 id="最近最少使用LRU">0.1.3. 最近最少使用LRU</h3><p>最久未被使用（作业的页面走向左面）</p><h2 id="物理地址计算">0.2. 物理地址计算</h2><p>前提：找出 一页多少字节/<u>块长</u>、页表、逻辑地址</p><h3 id="求出页号">0.2.1. 求出页号</h3><p>页号=逻辑地址 % 块长</p><p>求出来的<strong>商</strong>就是<u>页号</u>，<strong>余数</strong>就是<u>页内地址</u></p><h3 id="对照页表">0.2.2. 对照页表</h3><p>根据页号对照页表，找到页号对应的<u>块号</u></p><h3 id="计算地址">0.2.3. 计算地址</h3><p>绝对地址/物理地址 = 块号*块长+块内地址</p><h2 id="银行家算法">0.3. 银行家算法</h2><h3 id="判断系统是否“死锁”">0.3.1. 判断系统是否“死锁”</h3><p>max（最多需要） allocation（系统已经分配）need（需要的）available（可获得的）</p><p>work（目前的CPU）need（需要分配的CPU）allocation（已经分配的）work+allocation（下一个的work）finish（T/F）</p><h3 id="提供安全序列">0.3.2. 提供安全序列</h3><p>通过计算求i出安全序列</p><p>最后判断系统资源和题目中的是否一致</p><h2 id="磁盘调度">0.4. 磁盘调度</h2><p>通过四种方式来求总的寻道长度和平均寻道长度</p><p>关键字：磁盘驱动器（disk drive）柱面（cylinders）磁盘队列（disk queue）读写磁头（disk head）最初（initially）</p><p>按照时间顺序到达</p><h3 id="先来先服务FCFS">0.4.1. 先来先服务FCFS</h3><p>从最初拿到一个值 和 题目中给的作业队列 排成一个队列，然后<strong>相邻互减</strong>，求出的就是总的寻道长度，总的寻道长度除以移动次数就是平均训导长度</p><h3 id="最短寻道时间优先SSTF">0.4.2. 最短寻道时间优先SSTF</h3><p>先把题目中的队列按大小排序，然后标明磁头的位置，然后判断向左还是向右，原则是路径最短。直到最后都访问到了。相邻互减，得到总的寻道长度，除以寻道次数，得到平均寻道长度</p><h3 id="扫描算法SCAN">0.4.3. 扫描算法SCAN</h3><p>向左走到头然后向右走到头 或者 向右走到头然后向左走到头 依次访问路径上没有被访问到的磁头</p><p>因为是两种所以考试一般不考</p><h3 id="循环扫描算法C-SCAN">0.4.4. 循环扫描算法C-SCAN</h3><p>向左走到头之后，直接到最右边，然后往左边找。另一种和这个相反。多了一个走到最右的步骤。</p><h2 id="进程调度">0.5. 进程调度</h2><p>到达时间（提交时间）：The Arriving Time就是进程告诉操作系统你要开始处理我了的时间点，之后进入队列等待被处理</p><p>开始时间：Start time/Began就是操作系统真正开始处理进程的时间点</p><p>执行时间（CPU突发时间）：The Running Time/CPU brust time：就是把操作系统处理完这个程序需要多久</p><p>一般要求的东西：</p><p>平均等待时间：开始时间-到达时间</p><p>平均周转时间：结束时间-到达时间（根据开始时间和执行时间可以得到结束时间）</p><p>平均带权周转时间：周转时间除以运行时间</p><p>平均的意思就是每个进程的等待时间加起来再除以总的进程数</p><p>有一种做题的方法推荐：画Gantt图，不会百度</p><h3 id="先来先服务FCFS-1">0.5.1. 先来先服务FCFS</h3><p>特点：按照进程到达的先后次序，依次处理</p><h3 id="短作业优先SJF">0.5.2. 短作业优先SJF</h3><p>进程越短越优先，执行时间越小越优先，有个条件是 在CPU队列中的进程的执行时间的排序</p><h4 id="非抢占">0.5.2.1. 非抢占</h4><p>进程一旦开始执行就直接执行结束，不会被强制停止</p><h4 id="抢占">0.5.2.2. 抢占</h4><p>如果进程队列里面进来了一个执行时间更短的进程，那么就会抢占正在执行进程的CPU，优先执行执行时间短的进程</p><h3 id="高响应比优先HRRN">0.5.3. 高响应比优先HRRN</h3><p>这个属于非抢占，应该不会考，是一个扩展的</p><p>按照优先权=（等待时间+执行时间）/执行时间，接下来执行的是权重大的</p><p>算法的意义在于执行等待时间相对较长，但是执行时间较短的</p><h2 id="有效访问时间EAT">0.6. 有效访问时间EAT</h2><p>EAT=（1-p）<em>内存访问时间+p</em>平均页面错误服务时间</p><p>p：页面错误率Page Fault Rate  1000次中一次出错错误率就是0.1%</p><p>hit ratio：命中率 与页面错误率相反</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.1CSS概述</title>
    <link href="/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.1CSS%E6%A6%82%E8%BF%B0/"/>
    <url>/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.1CSS%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="6-1CSS概述">0.0.0.1. 6.1CSS概述</h4><span id="more"></span><h2 id="CSS概念">0.1. CSS概念</h2><p>Cascading Style Sheets（层叠样式表）的缩写，它是一种对Web文档添加样式的简单机制，是一种表现HTML或XML等文件外观样式的计算机语言，是一种网页排版和布局设计的技术</p><h2 id="CSS特点">0.2. CSS特点</h2><p>纯CSS布局和结构式HTML相结合能帮助设计师分离外观与结构，与传统的表格布局相比，具有以下特点：</p><ol><li>网页载入更快</li><li>降低了流量费用</li><li>修改设计时效率更高</li><li>更容易被搜索引擎收录</li></ol><h2 id="CSS功能">0.3. CSS功能</h2><ol><li>灵活控制文字字体、颜色、大小、间距、风格及位置</li><li>随意设置文本块行高、缩进，并可加三维效果的边框</li><li>方便为元素设置不同的背景颜色和背景图片</li><li>精确控制网页中个元素的位置</li><li>可以与脚本语言相结合，产生各种动态效果</li></ol><h2 id="CSS样式发展历程">0.4. CSS样式发展历程</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1996</span>年<span class="hljs-number">12</span>月：第一个CSS规范称为W<span class="hljs-number">3</span>C的推荐标准，提供有关字体、颜色、位置和文本属性的基本信息。较为全面的规定了文档的显示样式<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1998</span>年<span class="hljs-number">5</span>月：CSS<span class="hljs-number">2</span>作为W<span class="hljs-number">3</span>C推荐标准发布，他在CSS<span class="hljs-number">1</span>的基础上扩充和改进了许多属性，推出了一套内容和表现效果分离的方式，用DIV分割元素，用样式来定义外观，是程序员在开发过程中不必考虑显示和界面，大大提升了开发的效率<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2010</span>年<span class="hljs-number">12</span>月：CSS<span class="hljs-number">3</span>版本全新推出，通过模块化结构可以及时调整模块的内容，方便版本的更新与发布<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2012</span>年<span class="hljs-number">9</span>月：开始设计CSS Level<span class="hljs-number">4</span>版本；但是到目前为止，极少数的功能被浏览器厂商所支持<br></code></pre></td></tr></table></figure><h2 id="CSS3前景">0.5. CSS3前景</h2><h3 id="CSS3的应用范围">0.5.1. CSS3的应用范围</h3><ol><li>按钮效果</li><li>制作柱形图</li><li>设计下拉菜单</li><li>图片阴影效果</li><li>文本框样式</li><li>字体效果</li><li>CSS3引用气泡</li><li>动画效果</li></ol><h2 id="支持CSS3的浏览器">0.6. 支持CSS3的浏览器</h2><h3 id="对于属性的支持">0.6.1. 对于属性的支持</h3><p>除了Transforms 3D属性没有浏览器支持以外，Windows平台下的、Chrome和Safari对其他属性全面支持。其次是Firefox和Opera</p><h3 id="对于选择器的支持">0.6.2. 对于选择器的支持</h3><p>CSS3增加了许多的CSS选择器，可以简单实现更强大的功能，目前除了IE9以下的浏览器版本已经全部支持CSS3的选择器</p><h3 id="浏览器的前缀">0.6.3. 浏览器的前缀</h3><p>为了让设计人员设计的一个效果被各个浏览器所识别，通常可以在样式代码前面添加浏览器前缀</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">-ms-<span class="hljs-attribute">transform</span>：rotate(<span class="hljs-number">30deg</span>);<span class="hljs-comment">/*IE9*/</span><br>-moz-<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<span class="hljs-comment">/*Firefox*/</span><br>-webkit-<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<span class="hljs-comment">/*Safari and Chrome*/</span><br>-<span class="hljs-number">0</span>-<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<span class="hljs-comment">/*Opera*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3在网页中应用CSS的方式</title>
    <link href="/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.3%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%BA%94%E7%94%A8CSS%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.3%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%BA%94%E7%94%A8CSS%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="6-3在网页中应用CSS的方式">0.0.0.1. 6.3在网页中应用CSS的方式</h4><span id="more"></span><h2 id="CSS3应用方法">0.1. CSS3应用方法</h2><p>CSS样式能够以分离网页内容和样式的形式很好的控制网页的显示。在网页中应用CSS样式有4种方法：</p><ol><li><p>内联式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">通过标记style属性直接把CSS样式添加到<span class="hljs-selector-tag">HTML</span>标签中<br></code></pre></td></tr></table></figure><p>语法格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;标记名 <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/标记名&gt;<br></code></pre></td></tr></table></figure></li><li><p>内嵌式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">将CSS样式代码添加到HTML文档的<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>头部中，并用<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>标记定义<br></code></pre></td></tr></table></figure><p>语法格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="xml">选择器</span><span class="hljs-template-variable">&#123;属性&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>链入式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">将所有的样式放在一个或者多个以.css为扩展名的外部样式表文件中，通过<span class="hljs-tag">&lt;<span class="hljs-name">link</span> /&gt;</span>标记将外部样式表文件链接到HTML文档中<br></code></pre></td></tr></table></figure><p>语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;CSS文件路径&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>导入式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">与链入外部CSS基本相同，都是要创建一个单独的外部CSS文件，再引入到<span class="hljs-selector-tag">HTML</span>文档中。只不过语法和运作方式略有差别。<br></code></pre></td></tr></table></figure><p>语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;外部样式表相对路径&quot;</span>);</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="链入式和导入式的区别：">0.1.1. 链入式和导入式的区别：</h3><ol><li>隶属关系不同：link属于HTML标签，@import是CSS提供的载入方式</li><li>加载时间及顺序不同：link先将外部的CSS文件加载到网页中，然后再进行编译显示。而@import是浏览器先将HTML结构呈现出来，再把外部的CSS文件加载到网页中，当网速较慢的时候会先显示没有CSS的效果，加载完毕再渲染画面</li><li>兼容性不同@import只有IE5以上的版本才能识别，而link标签没有这个问题</li><li>DOM模型控制样式：使用JavaScript控制DOM改变样式时，只能使用link标签，而@import不受DOM模型的影响</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.2网页元素的定位</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.2%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.2%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h4 id="7-2网页元素的定位">0.0.0.1. 7.2网页元素的定位</h4><span id="more"></span><h2 id="网页元素的定位">0.1. 网页元素的定位</h2><p>CSS有三种基本的定位机制：普通流、浮动和绝对定位</p><ol><li>普通流：相当于默认</li><li>浮动：float属性定位</li><li>绝对定位：position属性定位</li></ol><h3 id="浮动">0.1.1. 浮动</h3><p>基本语法格式：选择器{float: 属性值;}</p><p>属性值：</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr><tr><td>none</td><td>元素不浮动（默认）</td></tr></tbody></table><p>浮动元素不再占用原文档流中的位置，所以会对其他元素排版产生影响，我们需要对元素清除浮动，基本语法格式：选择器{clear: 属性值};。它的属性值：</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动的元素</td></tr><tr><td>right</td><td>不允许右侧有浮动的元素</td></tr><tr><td>both</td><td>清除两侧的浮动元素影响</td></tr></tbody></table><h3 id="绝对定位">0.1.2. 绝对定位</h3><p>通过CSS定位设置可以实现网页元素的精确定位，定位属性包括定位模式和边偏移两部分，语法格式：选择器{position: 属性值};。属性值：</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>static</td><td>自动定位 默认</td></tr><tr><td>relative</td><td>相对定位，相对于其他原文档流位置进行定位</td></tr><tr><td>absolute</td><td>绝对定位，相对于上一个已经确定的父元素进行定位</td></tr><tr><td>fixed</td><td>固定定位，相对于浏览器窗口进行定位</td></tr></tbody></table><h2 id="设计导航栏">0.2. 设计导航栏</h2><p>用ul和li制作导航栏</p><ol><li>去掉项目符号可以使用text-decoration:none或者list-style-type:none</li><li>将列表项改为行排列，即内联行显示，可添加属性display:inline或者display:inline-block;</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.2CSS3的基本语法</title>
    <link href="/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.2CSS3%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.2CSS3%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="6-2CSS3的基本语法">0.0.0.1. 6.2CSS3的基本语法</h4><span id="more"></span><h2 id="CSS3语法格式">0.1. CSS3语法格式</h2><h3 id="构造CSS的样式规则">0.1.1. 构造CSS的样式规则</h3><p>CSS样式设置规则由两部分组成</p><ol><li>选择符：作用于哪里</li><li>声明：作用的样式，由属性和值构成，中间用冒号分割</li></ol><h3 id="说明">0.1.2. 说明</h3><ol><li><p>如果属性的值是由多个单词组成，并且单词之间有空格，那么必须给值加上引号，如字体的名称经常是几个单词的组合</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Times New Roman&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果需要对一个选择符指定多个属性时，用分号将属性分开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">text-align</span>:center;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-family</span>:宋体<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>相同属性组合起来称为选择符组。如果需要给选择符组定义属性和值，只要用逗号将选择符分开即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">table</span>&#123;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">10pt</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>CSS3对空格和大小写一般不敏感</p></li><li><p>为CSS添加注释时，只需要用/**/将注释包裹起来即可</p></li></ol><h2 id="选择器及其应用">0.2. 选择器及其应用</h2><p>选择器也可以称之为选择符，在HTML中不同的标签是用不同的选择器来控制的</p><h3 id="选择器的类型">0.2.1. 选择器的类型</h3><ol><li><p>通用选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通用选择器用*表示，他是所有选择器中作用范围最广的，能匹配页面内的所有元素<br></code></pre></td></tr></table></figure></li><li><p>标签选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">指用<span class="hljs-selector-tag">HTML</span>标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式<br></code></pre></td></tr></table></figure></li><li><p>类选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用来为一系列的网页元素定义相同的显示样式。类选择器使用.（英文符号）进行标识，后面紧跟类名<br></code></pre></td></tr></table></figure><p>类名定义是区分大小写的</p></li><li><p>id选择器</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">用来为唯一的网页元素定义显示样式。ID选择器使用<span class="hljs-meta">#进行标识，后面紧跟Id名</span><br></code></pre></td></tr></table></figure><p>id名定义是区分大小写的</p></li><li><p>伪类选择器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">伪类是可以向某些选择器添加特殊效果的、一组CSS预定义好的类，不需要进行id和<span class="hljs-keyword">class</span>属性的声明，就能自动的被支持<span class="hljs-symbol">CSS</span>的浏览器所识别<br></code></pre></td></tr></table></figure><table><thead><tr><th>伪类名</th><th>描述</th></tr></thead><tbody><tr><td>:link</td><td>向未被访问的链接添加样式，目前仅适用于超链接</td></tr><tr><td>:visited</td><td>向已被访问的链接添加样式，目前仅适用于超链接</td></tr><tr><td>:active</td><td>向被激活的元素添加样式</td></tr><tr><td>:focus</td><td>向拥有键盘输入焦点的元素添加样式</td></tr><tr><td>:hover</td><td>当鼠标悬浮在元素上方是，向元素添加样式</td></tr><tr><td>:readonly</td><td>向只读元素添加样式</td></tr><tr><td>:checked</td><td>向被选中的元素添加样式</td></tr><tr><td>:disabled</td><td>向被禁用的元素添加样式</td></tr><tr><td>:enabled</td><td>向可用的元素添加样式</td></tr></tbody></table></li><li><p>群组选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当几个元素样式属性一样的时候，可以共同调用一个声明，元素之间用逗号分隔<br></code></pre></td></tr></table></figure></li><li><p>派生选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">也叫后代选择器<br>派生选择器允许你根据文档上下文关系来确定某个标签的样式。在派生选择器中，每一个选择器对象之间使用空格作为分隔符，除了可以派生一级后代，也可以派生出多级后代<br></code></pre></td></tr></table></figure></li><li><p>属性选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用于选择拥有指定属性的HRML元素设置样式<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">属性选择器包含了：属性选择器、属性值选择器、包含选择器、连接字符选择器、子串选择器、后缀选择器<br></code></pre></td></tr></table></figure></li><li><p>组合选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">又称为子元素选择器<br>用于选区某个元素的直接子元素（间接子元素不适用）子选择器元素之间使用大于号隔开<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">相邻兄弟选择器<br>用于选择紧接在某元素之后的兄弟。相邻选择器元素之间使用+隔开<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">普通兄弟选择器<br>用于选择具有相同父元素的元素。普通兄弟选择器元素之间使用~分开<br></code></pre></td></tr></table></figure></li></ol><h2 id>0.3. </h2>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4CSS3样式特性和常用样式属性</title>
    <link href="/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.4CSS3%E6%A0%B7%E5%BC%8F%E7%89%B9%E6%80%A7%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7/"/>
    <url>/gzguo/2020/11/06/Web/6CSS3%E8%AF%AD%E6%B3%95/6.4CSS3%E6%A0%B7%E5%BC%8F%E7%89%B9%E6%80%A7%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="6-4CSS3样式特性和常用样式属性">0.0.0.1. 6.4CSS3样式特性和常用样式属性</h4><span id="more"></span><h2 id="CSS3样式的特性">0.1. CSS3样式的特性</h2><p>有四种特性：</p><ol><li><p>继承性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">特定的CSS属性向下传递到其子孙元素的特性<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">如果设置了<span class="hljs-selector-tag">p</span>的样式，那么<span class="hljs-selector-tag">span</span>将继承<span class="hljs-selector-tag">p</span>的样式<br></code></pre></td></tr></table></figure></li><li><p>特殊性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当多个规则应用于同一个元素时，权重高的优先<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">优先级：（由高到低）<br>ID选择器-&gt;类选择器-&gt;标签选择器-&gt;通用选择器<br></code></pre></td></tr></table></figure></li><li><p>层叠性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当同一个元素设置有多个样式，且具有相同的特殊性，CSS规范将根据样式的先后顺序，后定义的先应用<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">样式的优先级：（由高到低）<br>内联-&gt;内嵌-&gt;外链-&gt;外导<br></code></pre></td></tr></table></figure></li><li><p>重要性</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">当标签的选择器的属性值后面加上!important之后，该属性设置的优先权将高于一切其他样式规则<br></code></pre></td></tr></table></figure></li></ol><h2 id="CSS3常用的样式属性">0.2. CSS3常用的样式属性</h2><p>CSS样式中包含了对文本、段落、背景、边框、位置、列表、光标效果等众多属性的设置，CSS通过对属性的设置，可以控制网页中几乎所有的元素</p><h3 id="字体文本样式">0.2.1. 字体文本样式</h3><ol><li><p>设置网页中字体样式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定义文本字体、大小、加粗、风格（斜体）、变形等<br></code></pre></td></tr></table></figure></li><li><p>设置文本的样式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定义文本颜色、字符间距、对齐、装饰、缩进等<br></code></pre></td></tr></table></figure><table><thead><tr><th>功能</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>文本颜色</td><td>color</td><td>设置文本颜色</td></tr><tr><td>字体类型</td><td>font-family</td><td>设置文本的字体</td></tr><tr><td>字体风格</td><td>font-style</td><td>设置字体的样式，取值normal正常、italic斜体、oblique倾斜</td></tr><tr><td>字体加粗</td><td>font-weight</td><td>设置字体的粗细，取值可以时bolder、bold、normal、lighter或100-900之间的9个等级</td></tr><tr><td>字体大小</td><td>font-size</td><td>设置文本大小，值可以是绝对或者相对值</td></tr><tr><td>行间距</td><td>line-height</td><td>设置文本的行高，即两文本线之间的距离</td></tr><tr><td>字体简写</td><td>font</td><td>属性的简写可用于一次设置元素字体的两个或多个方面</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li></ol><h3 id="CSS中与长度相关的属性的取值方法">0.2.2. CSS中与长度相关的属性的取值方法</h3><h4 id="相对尺寸">0.2.2.1. 相对尺寸</h4><p>继承该元素属性前一个属性的单位值</p><p>em是相对长度单位</p><h4 id="绝对尺寸">0.2.2.2. 绝对尺寸</h4><p>尺寸大小受后面紧跟的单位限制，这种取值方法不会随显示器分辨率变化而变化，也不会因显示设备的不同而不同，其取值是固定的</p><p>pt是绝对长度单位</p><h4 id="常见的长度单位的含义">0.2.2.3. 常见的长度单位的含义</h4><table><thead><tr><th>长度单位</th><th>含义</th></tr></thead><tbody><tr><td>em</td><td>元素字体的高度，相对长度单位</td></tr><tr><td>ex</td><td>字母的高度，相对长度单位</td></tr><tr><td>px</td><td>像素，相对显示器分辨率而言，相对长度单位</td></tr><tr><td>cm</td><td>厘米，绝对长度单位</td></tr><tr><td>mm</td><td>毫米，绝对长度单位</td></tr><tr><td>in</td><td>英寸，绝对长度单位，1in=2.4cm</td></tr><tr><td>pt</td><td>磅，绝对长度单位，1pt=1/72英寸</td></tr><tr><td>pc</td><td>派卡，绝对长度单位，1pc=12pt</td></tr></tbody></table><h3 id="关键字表示大小">0.2.3. 关键字表示大小</h3><h4 id="绝对尺寸关键字">0.2.3.1. 绝对尺寸关键字</h4><p>xx-small、x-small、small、medium、large、x-large、xx-large</p><h4 id="相对尺寸关键字">0.2.3.2. 相对尺寸关键字</h4><p>larger相对于上一个关键字、smaller相对于上一个关键字</p><h3 id="网页中的文本样式属性">0.2.4. 网页中的文本样式属性</h3><table><thead><tr><th>功能</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>行间距</td><td>line-height</td><td>设置文本段落中两行基线之间的距离</td></tr><tr><td>字符间距</td><td>letter-spacing</td><td>设置字符或者字母间的间隔</td></tr><tr><td>字间距</td><td>word-spacing</td><td>设置字单词之间的标准间隔，默认为0、normal</td></tr><tr><td>水平对齐</td><td>text-align</td><td>设置文本的水平对齐方式left、right、center、justify</td></tr><tr><td>垂直对齐</td><td>vertical-align</td><td>设置文本的垂直对齐方式，bottom、top、middle</td></tr><tr><td>缩进文本</td><td>text-indent</td><td>设置行的缩进大小，值可以为正或负，单位em、px、%</td></tr><tr><td>字符转换</td><td>text-transform</td><td>设置文本中的字母大小写，none、uppercase、lowercase、capitalize</td></tr><tr><td>文本修饰</td><td>text-decoration</td><td>设置段落中需要强调的文字，none、underline、overline、line-through、blink</td></tr><tr><td>修饰线样式</td><td>text-decoration-style</td><td>设置修饰线的样式，solid、double、dotted、dashed、wavy</td></tr><tr><td>修饰线颜色</td><td>text-decoration-color</td><td>设置修饰线颜色</td></tr><tr><td>文本阴影</td><td>text-shadow</td><td>设置文本阴影效果</td></tr><tr><td>文本溢出</td><td>text-overflow</td><td>控制页面中溢出的文本内容。修剪文本不显示溢出内容clip，显示省略号代替被修剪文本内容ellopsis</td></tr><tr><td>文本填充色</td><td>text-fill-color</td><td>设置文本填充颜色</td></tr><tr><td>文本描边框</td><td>text-stroke-width</td><td>设置文本描边框的宽度值</td></tr><tr><td>文本描边色</td><td>text-stroke-color</td><td>设置文本描边颜色</td></tr></tbody></table><h3 id="背景样式">0.2.5. 背景样式</h3><p>略样式</p><h3 id="边框样式">0.2.6. 边框样式</h3><p>理解网页的box结构：在CSS当中，把容纳文本、图片等内容的显示区域叫做box，包括四个部分</p><ol><li>对象本身Content</li><li>围绕对象的空格填充Padding</li><li>对象的边框Border</li><li>围绕边框的对象间隙Margin</li></ol><p>略样式</p><h3 id="列表样式">0.2.7. 列表样式</h3>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.3DIV+CSS网页布局</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.3DIV+CSS%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.3DIV+CSS%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="7-3DIV-CSS网页布局">0.0.0.1. 7.3DIV+CSS网页布局</h4><span id="more"></span><h2 id="DIV-CSS网页布局名词解释">0.1. DIV+CSS网页布局名词解释</h2><p>核心是盒子模型，通过对盒子进行CSS样式定义，借助CSS对盒子定位，这样就称为DIV+CSS布局</p><h3 id="标签">0.1.1. 标签</h3><p>header、nav、aside、article</p><h2 id="为什么使用DIV-CSS">0.2. 为什么使用DIV+CSS</h2><h3 id="这样布局的优点">0.2.1. 这样布局的优点</h3><ol><li>利于搜索引擎的检索和排名</li><li>代码精简，网页加载更快</li><li>定位更准确</li><li>更容易被其他设备访问</li></ol><h2 id="如何进行DIV-CSS布局">0.3. 如何进行DIV+CSS布局</h2><p>四个步骤：</p><ol><li>整体上对页面进行分块</li><li>按照分块的设计使用DIV标记，包裹区块元素，设计HTML的主体内容</li><li>编辑CSS，设计盒子的定位及在盒中的元素样式</li><li>连编</li></ol><h2 id="DIV-CSS实例">0.4. DIV+CSS实例</h2><h3 id="常见的布局形式">0.4.1. 常见的布局形式</h3><p>单列布局：header、article、footer</p><p>1-2-1布局：header、article、aside、footer</p><p>1-3-1布局：header、article、aside、aside、footer</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.1网页布局类型及CSS盒模型</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.1%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%E5%8F%8ACSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.1%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%E5%8F%8ACSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="7-1网页布局类型及CSS盒模型">0.0.0.1. 7.1网页布局类型及CSS盒模型</h4><span id="more"></span><h2 id="网页布局方式">0.1. 网页布局方式</h2><p>网页布局主要是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种主要构成元素进行一个合理的排版</p><h3 id="网页布局的类型">0.1.1. 网页布局的类型</h3><ol><li><p>固定式<br>用固定的宽度设计网页布局尺寸，这种布局有一个设置了固定宽度的外包裹，里面的各个模块也是固定宽度。<br>优点：</p><ol><li>设计师所设计的就是最终用户所看到的</li><li>设计简单，并且容易定制</li><li>在所有的浏览器中的宽度一样，不会收到图片、表单、视频和其他固定宽度的内容影响</li></ol><p>缺点：</p><ol><li>高分辨率式，回留下很大的空白</li><li>屏幕分辨率过小时会出现横向滚动条</li><li>在应该确保至少居中外包裹DIV（margin:0 auto）以保持一种显示平衡，否则对于使用大分辨率的用户，整个页面会被藏到一边去</li></ol></li><li><p>流式<br>通常被称为液态布局。通常采用相对于分辨率大小的百分比的方式自适应不同的分辨率，可以根据浏览器的宽度和屏幕的大小自动调整效果，灵活多变<br>优点：</p><ol><li>对用户来说更加友好，能部分自适应用户设置</li><li>页面周围的空白区域在所有分辨率和浏览器下都是相同的，在视觉上更美观</li><li>如果设计良好，流动布局可以避免在小分辨率下出现水平滚动条</li></ol><p>缺点：</p><ol><li>设计者需要在不同的分辨率下进行测试才能看到最终的设计效果</li><li>在不同的分辨率下图片或者视频需要不同的素材</li><li>在屏幕分辨率跨度太大时，内容会过大或者过小，变得难以阅读</li></ol></li><li><p>响应式<br>这是一种糅合了流式布局，再搭配查询技术使用的网页布局方式<br>根据不同的设备平台对内容、媒体文件和布局结构进行相应的调整与优化，从而使为用户提供一种最优且相对统一的体验模式<br>优点：</p><ol><li>面对不同分辨率设备灵活性强</li><li>能够快捷的解决多设备显示适应问题</li></ol><p>缺点：</p><ol><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ol></li></ol><h2 id="DIV-CSS布局技术">0.2. DIV+CSS布局技术</h2><p>把页面中所有的元素都看成是一个盒子，通过盒子进行CSS样式定义，并借助DIV变迁及其CSS定位实现网页布局</p><h3 id="DIV-CSS布局的方法步骤">0.2.1. DIV+CSS布局的方法步骤</h3><ol><li>整体上对页面进行分块</li><li>按照分块设计使用DIV标记并定义其样式属性</li><li>对DIV盒子进行定位实现页面布局</li></ol><h3 id="创建DIV">0.2.2. 创建DIV</h3><p>DIV标签是一个块标签，他将页面内容划分为独立的部分，以实现网页的规划和布局。</p><p>DIV标签可以加入很多的属性，如：id、class、align、style等，在CSS布局设计中，为了设计网页内容和表现的分离，应尽量的减少align、style等属性的编写次数。因此，常用的属性也只有id和class两种了</p><h3 id="CSS盒模型">0.2.3. CSS盒模型</h3><p>是指在页面布局中，为了将页面元素合理有效的组织在一起，形成一套完整的、行之有效的原则和规范</p><p>CSS盒是由margin（外边距）、border（边框）、padding（内边距）、content（内容）四个部分组成，此外，还有高度和宽度两个辅助属性</p><h4 id="content内容区">0.2.3.1. content内容区</h4><p>是盒子模型的中心，包含了盒子的主要重要信息。包含width、height、overflow三个属性。</p><h5 id="overflower">0.2.3.1.1. overflower</h5><p>overflow主要是指定溢出内容的处理方式</p><table><thead><tr><th>overflow取值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>默认值，溢出的内容不会被修建，会呈现在元素框之外</td></tr><tr><td>hidden</td><td>溢出的内容不可见</td></tr><tr><td>scroll</td><td>溢出的内容会被修建，但是可以通过滚动条来查看隐藏的部分</td></tr><tr><td>auto</td><td>由浏览器决定如何处理溢出部分</td></tr></tbody></table><h5 id="border">0.2.3.1.2. border</h5><p>border是指围绕元素内容和内边距的一条或多条线</p><p>border-width：边框宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-attribute">border-top-width</span>: <span class="hljs-number">10px</span>&#125;<br>&#123;<span class="hljs-attribute">border-width</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">30px</span> <span class="hljs-number">40px</span>&#125; (上右下左的顺序设置)<br>如果是三个参数将按上(左右)下的顺序作用到边框上<br>如果是两个参数的话，按照(上下)(左右)的顺序作用到边框上<br>如果只有一个参数的时候，四个方向的取值相同<br></code></pre></td></tr></table></figure><p>border-style：边框样式</p><p>border-radius：可以设置四个角的圆角样式</p><p>border-image：对图像边框进行设置</p><h2 id="多列布局方法">0.3. 多列布局方法</h2><h2 id="CSS3弹性盒布局">0.4. CSS3弹性盒布局</h2><h2 id="HTML5的语义化标签及DIV-CSS网页布局技术设计网页">0.5. HTML5的语义化标签及DIV+CSS网页布局技术设计网页</h2>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.4多列布局及CSS3弹性盒布局</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.0%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80%E5%8F%8ACSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.0%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80%E5%8F%8ACSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="7-4多列布局及CSS3弹性盒布局">0.0.0.1. 7.4多列布局及CSS3弹性盒布局</h4><span id="more"></span><h1 id="见7-4-1和7-4-2">1. 见7.4.1和7.4.2</h1>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.4.2CSS3-弹性盒布局</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.2CSS3-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.2CSS3-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="7-4-2CSS3-弹性盒布局">0.0.0.1. 7.4.2CSS3-弹性盒布局</h4><span id="more"></span><h2 id="弹性盒布局">0.1. 弹性盒布局</h2><p>弹性盒是CSS3的一种新布局模式。它是一种当页面需要适应不同的屏幕大小及设备类型时确保元素拥有桥当排列的布局方式</p><ol><li>弹性盒组成<br>弹性容器的定义：选择器{display: flex;}</li><li>弹性容器的布局<br>按照子元素排列的方向不同，有横向和纵向排列两种方式，子元素的方向属性：选择器{flex-flow: 方向值 换行设置;}</li><li>子元素的布局<br>子元素在空间宽度上的分配，由flex属性设置</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.4.1CSS3-多列布局</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.1CSS3-%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.4.1CSS3-%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="7-4-1CSS3-多列布局">0.0.0.1. 7.4.1CSS3-多列布局</h4><span id="more"></span><h2 id="多列布局">0.1. 多列布局</h2><p>像报纸一样</p><p>让Web页面呈现多栏多列叫多列布局</p><ol><li>分栏数<br>CSS3中通过columns属性设置分栏</li><li>列间修饰<br>columns-gap设置列间距<br>columns-rule设置列间宽度、样式和颜色</li><li>横跨多列<br>columns-span默认1，跨多少列</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.5CSS3高级应用</title>
    <link href="/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.5CSS3%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/gzguo/2020/11/06/Web/7CSS3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/7.5CSS3%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="7-5CSS3高级应用">0.0.0.1. 7.5CSS3高级应用</h4><span id="more"></span><h1 id="特效应用">1. 特效应用</h1><h2 id="滤镜属性filter">1.1. 滤镜属性filter</h2><p>滤镜是CSS的扩展部分。CSS的滤镜技术可以将各种特效添加到标准的HTML页面上，从而设计出多姿多彩的页面</p><p>语法格式：</p><p>选择器{filter:滤镜名称(滤镜参数)}</p><p>filter有十几种取值，每种取值都带有参数</p><h3 id="常用的滤镜的名称">1.1.1. 常用的滤镜的名称</h3><p>grayscale() 灰度</p><p>sepia() 老照片</p><p>saturate() 饱和度转换</p><p>hue-ratate() 色调转换</p><p>invert() 反射效果</p><p>opacity() 透明度</p><p>brightness() 亮度效果</p><p>contrast() 对比度</p><p>blur() 模糊</p><p>drop-shadow() 阴影效果</p><h2 id="渐变gradient">1.2. 渐变gradient</h2><p>CSS渐变可以显示在两个或多个指定的颜色之间平稳过渡效果</p><h3 id="线性渐变">1.2.1. 线性渐变</h3><p>linear</p><h3 id="径向渐变">1.2.2. 径向渐变</h3><p>radio</p><h2 id="2D转换transform">1.3. 2D转换transform</h2><p>CSS3转换transform可以实现二维平面内的位移、旋转、缩放、倾斜等变换效果</p><p>变换的函数：</p><p>translate() 平移</p><p>rotate() 旋转</p><p>scale() 缩放</p><p>skew() 倾斜</p><h2 id="过渡transition">1.4. 过渡transition</h2><p>过渡属性transition允许CSS属性值在一定时间和区间内平滑的过渡，这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS地属性值。</p><p>基本语法格式：选择器{transition:属性名称 过渡时间 速度类型 延迟时间;}</p><p>发生过渡的属性名称：属性名称用来规定应用过渡效果的CSS属性名称。他的取值可以是none、all或者某一个属性名</p><p>发生过渡时间用来规定由就属性过渡到新属性所花费的时间</p><p>linear线性效果</p><p>ease缓解效果</p><p>ease-in淡入效果</p><p>ease-out淡出效果</p><p>ease-in-out渐显渐隐效果</p><p>cubic-bezier特殊立方贝塞尔曲线效果</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.1JavaScript概念及其语法</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.0JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.0JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="8-1JavaScript概念及其语法">0.0.0.1. 8.1JavaScript概念及其语法</h4><span id="more"></span><h1 id="见8-1-1和8-1-2">1. 见8.1.1和8.1.2</h1>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.1.1JavaScript概念及其语法上</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.1JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%8A/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.1JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h4 id="8-1-1JavaScript概念及其语法上">0.0.0.1. 8.1.1JavaScript概念及其语法上</h4><span id="more"></span><h2 id="JavaScript简介">0.1. JavaScript简介</h2><p>是一种脚本语言，是动态的、弱类型、基于原型的语言</p><p>特点：</p><ol><li>语法简单，易学易用</li><li>解释性语言</li><li>跨平台</li><li>基于对象和时间驱动</li><li>可用于客户端</li></ol><p>作用：</p><ol><li>动态改变网页内容</li><li>动态改变网页外观</li><li>验证表单数据</li><li>响应事件</li></ol><p>和java的区别：</p><ol><li>java是传统编程语言，javascript是脚本语言</li><li>java语言多用于服务器端，javascript主要用于客户端</li><li>java不能直接嵌入网页运行，javascript程序可以直接嵌入网页运行</li><li>java和javascript语法结构存在差异</li></ol><p>javascript开发和运行环境：</p><p>是一种脚本语言，不需要编译成二进制文件，以文本形式存在，任何编译器都可以作为他的开发环境，通常的开发环境有：记事本、UltraEdit、Dreamwaver</p><h2 id="在HTML5中使用JavaScript">0.2. 在HTML5中使用JavaScript</h2><p>有两种方法：内嵌式，外链式</p><h3 id="内嵌式">0.2.1. 内嵌式</h3><p>script标签，放在head标签中</p><h3 id="外链式">0.2.2. 外链式</h3><p>同一段代码需要被多个网页文件所使用的时候，使用外链式</p><h2 id="数据类型与变量">0.3. 数据类型与变量</h2><h2 id="运算符与表达式">0.4. 运算符与表达式</h2><h2 id="流程控制语句">0.5. 流程控制语句</h2><h2 id="函数">0.6. 函数</h2>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.1.2JavaScript概念及其语法中</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.2JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%AD/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.2JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h4 id="8-1-2JavaScript概念及其语法中">0.0.0.1. 8.1.2JavaScript概念及其语法中</h4><span id="more"></span><h2 id="javascript语法规则">0.1. javascript语法规则</h2><ol><li>javascript由语句、语句块、函数、对象、方法和属性构成，通过顺序、分支、循环三种基本程序控制结构进行编程</li><li>javascript是发送给浏览器的命令，这些命令的作用是告诉浏览器要做的事情</li><li>javascript语句可以分批组合起来形成语句块</li><li>javascript是由若干语句和语句块构成的执行体</li></ol><h2 id="语法概述">0.2. 语法概述</h2><ol><li>程序按照在HTML文件中出现的顺序逐行执行</li><li>严格区分大小写</li><li>每行结尾分号可有可无</li><li>单行注释//和多行注释/**/</li></ol><h2 id="数据类型和变量">0.3. 数据类型和变量</h2><h3 id="数据类型">0.3.1. 数据类型</h3><p><strong>数据类型</strong>分为三大类：</p><ol><li>简单数据类型<br>数值数据number<br>文本数据string<br>布尔数boolean</li><li>符合数据类型<br>数组Array<br>函数function<br>对象Objects</li><li>特殊数据类型<br>无定义数据类型undefined<br>空数据null</li></ol><h3 id="变量">0.3.2. 变量</h3><p><strong>变量</strong>：程序运行期间可能产生一些临时数据，应用程序会将这些数据保存在存储单元中。变量就是指程序中一个已经命名的存储单元，他的主要作用就是为数据操作提供存放信息的容器</p><p><strong>变量的命名规则</strong>：</p><ol><li>必须以字母或下划线开头，中间可以是数字、字母、下划线</li><li>变量名不能包含空格、加、减等符号</li><li>不能使用javascript中的关键字和保留字作为变量名</li><li>javascript的变量名严格区分大小写</li></ol><p>声明变量的语法格式：var 变量名;</p><h2 id="运算符">0.4. 运算符</h2><h3 id="算术运算符">0.4.1. 算术运算符</h3><h3 id="赋值运算符">0.4.2. 赋值运算符</h3><h3 id="位运算符">0.4.3. 位运算符</h3><h3 id="关系运算符">0.4.4. 关系运算符</h3><h3 id="逻辑运算符">0.4.5. 逻辑运算符</h3><p>条件运算符</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.2字符串对象</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="8-2字符串对象">0.0.0.1. 8.2字符串对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.1.3JavaScript概念及其语法下</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.3JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%8B/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.1.3JavaScript%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="8-1-3JavaScript概念及其语法下">0.0.0.1. 8.1.3JavaScript概念及其语法下</h4><span id="more"></span><h2 id="流程控制语句">0.1. 流程控制语句</h2><h3 id="顺序结构">0.1.1. 顺序结构</h3><h3 id="选择结构">0.1.2. 选择结构</h3><p>if switch</p><h3 id="循环结构">0.1.3. 循环结构</h3><p>while、do-while、for</p><h2 id="函数">0.2. 函数</h2>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.3数学对象</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.3%E6%95%B0%E5%AD%A6%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.3%E6%95%B0%E5%AD%A6%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="8-3数学对象">0.0.0.1. 8.3数学对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.4日期对象</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="8-4日期对象">0.0.0.1. 8.4日期对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.5数组对象</title>
    <link href="/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.5%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/8javaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8AjavaScript%E5%AF%B9%E8%B1%A1/8.5%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="8-5数组对象">0.0.0.1. 8.5数组对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.3窗口对象</title>
    <link href="/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.3%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.3%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="9-3窗口对象">0.0.0.1. 9.3窗口对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.1BOM和DOM概述</title>
    <link href="/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.1BOM%E5%92%8CDOM%E6%A6%82%E8%BF%B0/"/>
    <url>/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.1BOM%E5%92%8CDOM%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="9-1BOM和DOM概述">0.0.0.1. 9.1BOM和DOM概述</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.2事件机制</title>
    <link href="/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.2%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.2%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="9-2事件机制">0.0.0.1. 9.2事件机制</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.4文档对象</title>
    <link href="/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.4%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.4%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="9-4文档对象">0.0.0.1. 9.4文档对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.5表单对象</title>
    <link href="/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.5%E8%A1%A8%E5%8D%95%E5%AF%B9%E8%B1%A1/"/>
    <url>/gzguo/2020/11/06/Web/9javaScript%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9.5%E8%A1%A8%E5%8D%95%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="9-5表单对象">0.0.0.1. 9.5表单对象</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1表单结构及表单控件</title>
    <link href="/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.1%E8%A1%A8%E5%8D%95%E7%BB%93%E6%9E%84%E5%8F%8A%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6/"/>
    <url>/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.1%E8%A1%A8%E5%8D%95%E7%BB%93%E6%9E%84%E5%8F%8A%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="表单结构及表单控件">0.0.0.1. 表单结构及表单控件</h4><span id="more"></span><h2 id="什么是表单">0.1. 什么是表单</h2><h3 id="例子">0.1.1. 例子</h3><p>登陆、电商注册、快递查询</p><h2 id="表单的主要功能">0.2. 表单的主要功能</h2><h3 id="提示信息">0.2.1. 提示信息</h3><p>一个表单通常需要包含一些说明性的文字，提示用户进行填写和操作</p><h3 id="表单控件">0.2.2. 表单控件</h3><p>具体表单的功能项，如单行文本输入框，密码输入框、复选框、提交按钮、重置按钮等</p><h3 id="表单域">0.2.3. 表单域</h3><p>相当于一个容器，用来容纳所有的表单控件和提示信息</p><h2 id="表单的结构">0.3. 表单的结构</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">from</span> action=&quot;url地址&quot; <span class="hljs-keyword">method</span>=&quot;提交方式&quot; <span class="hljs-type">name</span>=&quot;表单名称&quot;&gt;<br>各种表单控件<br>&lt;/<span class="hljs-keyword">from</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="name">0.3.1. name</h3><p>用来区别一个页面内的不同表单</p><h3 id="action">0.3.2. action</h3><p>用于指定接收并处理表单数据的服务器程序的url地址</p><h3 id="method">0.3.3. method</h3><p>用于设置表单数据的提交方式，其取值为get或者post</p><h2 id="表单控件-1">0.4. 表单控件</h2><p>表单控件是表单的核心内容，不同的表单控件具有不同的功能，如密码输入框、文本域、下拉列表、复选框等，只有掌握了这些控件的使用方法才能正确的创建表单</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2表单的控件</title>
    <link href="/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.2%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8E%A7%E4%BB%B6/"/>
    <url>/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.2%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="4-2表单的控件">0.0.0.1. 4.2表单的控件</h4><span id="more"></span><h2 id="input控件">0.1. input控件</h2><p>定义单行文本输入框、单选按钮、复选框、提交按钮、重置按钮等，要使用input控件</p><h3 id="常见的属性">0.1.1. 常见的属性</h3><ol><li><p>type：控件类型</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">取值：<span class="hljs-keyword">text</span>、password、radio、checkbox、<span class="hljs-keyword">button</span>、submit、reset、<span class="hljs-keyword">file</span> <span class="hljs-keyword">image</span>、hidden<br></code></pre></td></tr></table></figure></li><li><p>name：控件名称</p></li><li><p>value：控件中的默认文本</p></li><li><p>size：控件名称在页面中显示宽度</p></li><li><p>readonly：控件内容为只读</p></li><li><p>disabled：首次加载的页面时是否禁用该控件（显示为灰色）</p></li><li><p>checked：定义选择控件默认值被选中</p></li><li><p>maxlength：控件允许输入最多的字符数</p></li></ol><h2 id="textarea控件">0.2. textarea控件</h2><p>可以创建多行文本输入框</p><h3 id="testarea基本语法">0.2.1. testarea基本语法</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;textarea <span class="hljs-attribute">cols</span>=<span class="hljs-string">&quot;每行中的字符数&quot;</span> <span class="hljs-attribute">rows</span>=<span class="hljs-string">&quot;显示的行数&quot;</span> <span class="hljs-attribute">wrap</span>=<span class="hljs-string">&quot;   &quot;</span>&gt;文本内容&lt;/testarea&gt;<br></code></pre></td></tr></table></figure><p>wrap是html5中的新属性：属性取值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">soft：当在表单提交时，<span class="hljs-selector-tag">textarea</span>中的文本不换行。默认值<br>hard：当在表单提交时，<span class="hljs-selector-tag">textarea</span>中的文本换行<br></code></pre></td></tr></table></figure><h2 id="select控件">0.3. select控件</h2><p>创建一个选择框</p><h3 id="select基本语法">0.3.1. select基本语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>=&quot;控件名称&quot; size=&quot;表示可见选项的数目&quot; multiple(设定为多选)&gt;<br>&lt;<span class="hljs-keyword">option</span> <span class="hljs-keyword">value</span>=&quot;选项值&quot; selected(默认该选项被选中)&gt;  (表示指定区域中的一个选项)<br><br>&lt;/<span class="hljs-keyword">option</span>&gt;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>标签功能</th><th>用到的属性</th><th>效果说明</th></tr></thead><tbody><tr><td>marquee</td><td>使标签中的内容滚动</td><td>bgcolor，direction，behavior</td><td>bgcolor代表滚动范围背景颜色；direction代表滚动方向；behavior代表滚动的方式</td></tr><tr><td>table</td><td>形成一个表格</td><td>tr,th,td</td><td>tr定义行；td定义每行的单元格；th用来定义标题栏</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3表单的处理</title>
    <link href="/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.3%E8%A1%A8%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <url>/gzguo/2020/11/03/Web/4%E6%9E%84%E5%BB%BAWeb%E8%A1%A8%E5%8D%95/4.3%E8%A1%A8%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="4-3表单的处理">0.0.0.1. 4.3表单的处理</h4><span id="more"></span><h2 id="表单的分组">0.1. 表单的分组</h2><p>使用fieldset元素将相关的元素组合在一起</p><h3 id="fieldset基本语法">0.1.1. fieldset基本语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">form</span>&gt;<br>&lt;<span class="hljs-selector-tag">fieldset</span>&gt;  (表单的一个子容器，将所包含的内容以边框环绕的方式显示)<br>&lt;<span class="hljs-selector-tag">legend</span>&gt;&lt;/<span class="hljs-selector-tag">legend</span>&gt;  (为<span class="hljs-selector-tag">fieldset</span>边框添加相关的标题)<br>&lt;/<span class="hljs-selector-tag">fieldset</span>&gt;<br>&lt;/<span class="hljs-selector-tag">form</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="表单的验证">0.2. 表单的验证</h2><p>表单验证主要时在用户提交表单之前对用户输入的数据进行验证，看数据是否合法</p><h3 id="Email-URL验证">0.2.1. Email/URL验证</h3><p>HTML5新增的Email/URL表单类型本身就是具有对表单数据进行验证的功能</p><h3 id="pattern验证">0.2.2. pattern验证</h3><p>使用pattern属性验证输入字段的模式，pattern属性具有对表单中输入字段模式进行验证的功能。适合于text、url、telephone、email、password等<input>类型</p><h4 id="pattern基本语法格式">0.2.2.1. pattern基本语法格式</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">pattern</span>=<span class="hljs-string">&quot;regexp(正则表达式)&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="表单添加组件说明">0.3. 表单添加组件说明</h2><p>使用label标签为扁担组件添加说明</p><h3 id="label标签">0.3.1. label标签</h3><p>label标签是描述表单字段用途的文本。label元素不会向用户呈现任何特殊的效果。不过它为鼠标用户改进了可用性。如果在label元素内点击文本，就会出发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转移到和标签相关的表单控件上</p><h3 id="label标签的属性">0.3.2. label标签的属性</h3><ol><li>for：规定label绑定到哪个表单元素上，属性取值为表单元素的id</li><li>form：规定label字段所属的一个或多个表单。属性取值为formid</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.1HTML5中的音频与视频</title>
    <link href="/gzguo/2020/11/03/Web/5%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%A7%86%E9%A2%91/5.1HTML5%E4%B8%AD%E7%9A%84%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%A7%86%E9%A2%91/"/>
    <url>/gzguo/2020/11/03/Web/5%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%A7%86%E9%A2%91/5.1HTML5%E4%B8%AD%E7%9A%84%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h4 id="5-1HTML5中的音频与视频">0.0.0.1. 5.1HTML5中的音频与视频</h4><span id="more"></span><h2 id="音频和视频编解码器">0.1. 音频和视频编解码器</h2><h3 id="音频编解码器">0.1.1. 音频编解码器</h3><p>定义了音频数据流编码和解码的算法。其中编码器主要是对数据流进行编码操作，用于存储和传输。音频播放器主要是对音频文件进行解码，然后进行播放操作。</p><p>主要使用的音频<strong>解码器</strong>使Vorbis和ACC</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ACC</span>是基于MPEG-<span class="hljs-number">2</span>的音频编码技术<br><span class="hljs-attribute">Ogg</span> Vorbis是一种新的音频压缩格式，类似于MP<span class="hljs-number">3</span>等的音乐格式。开源，支持多声道<br></code></pre></td></tr></table></figure><h3 id="视频编解码器">0.1.2. 视频编解码器</h3><p>定义了视频数据流编码和解码的算法。其中编码器主要是对数据流进行编码操作，用于存储和传输。视频播放器主要是对音频文件进行解码，然后进行播放操作。</p><p>目前使用较多的视频<strong>解码器</strong>是Theora、H.264和VP8</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Theora</span>是一种一款由Xiph.org基金会发布的免费且开放的视频压缩编码技术<br><span class="hljs-attribute">H</span>.<span class="hljs-number">264</span>是一种国际电信联盟和国际标准化组织联合推出的高性能视频编码解码技术<br><span class="hljs-attribute">VP8</span>由<span class="hljs-literal">On</span><span class="hljs-number">2</span> Technologiesis开发，随后由Google发布的视频压缩格式<br></code></pre></td></tr></table></figure><h2 id="HTML5播放音频">0.2. HTML5播放音频</h2><p>使用audio标签，用于音乐文件和其他视频流的播放</p><h3 id="audio基本语法">0.2.1. audio基本语法</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;audio <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">controls</span>=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/audio&gt;<br></code></pre></td></tr></table></figure><p>src:规定要播放的音频的地址</p><p>controls:供添加播放、暂停和音量控件</p><p>audio目前支持三种音频格式Ogg Vorbis</p><h3 id="audio的属性">0.2.2. audio的属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>autoplay</td><td>autoplay</td><td>如果出现该属性，则音频在就绪后马上播放</td></tr><tr><td>controls</td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮</td></tr><tr><td>loop</td><td>loop</td><td>如果出现该属性，则每当音频结束之后重新开始播放</td></tr><tr><td>preload</td><td>preload</td><td>如果出现该属性，则音频在页面页面加载时进行加载，并预备播放；如果使用“autoplay”，则忽略该属性</td></tr><tr><td>src</td><td>url</td><td>要播放的音频的url</td></tr></tbody></table><h2 id="HTML5播放视频">0.3. HTML5播放视频</h2><p>使用video元素用于视频文件的播放</p><h3 id="video基本语法">0.3.1. video基本语法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;video src=<span class="hljs-string">&quot;&quot;</span> width=<span class="hljs-string">&quot;&quot;</span> height=<span class="hljs-string">&quot;&quot;</span> controls=<span class="hljs-string">&quot;controls&quot;</span>&gt;<br>&lt;/video&gt;<br></code></pre></td></tr></table></figure><p>video元素目前支持三种音频格式：Ogg、MPEG4、WebM</p><h2 id="小结">0.4. 小结</h2><p>在HTML5问世之前，在线的音频和视频都是借助Flash或者第三方工具实现的，现在HTML5也支持了这方面的功能。在一个支持HTML5的浏览器中不需要安装任何插件就可以播放音频和视频。</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1页面元素和页面节点</title>
    <link href="/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.1%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%8A%82%E7%82%B9/"/>
    <url>/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.1%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="3-1页面元素和页面节点">0.0.0.1. 3.1页面元素和页面节点</h4><span id="more"></span><p>HTML5的目标：通过一些新标签、新功能、为开发更加简单、独立、标准的通用Web应用提供了标准</p><p>解决了三大问题：浏览器兼容问题、文档结构不明确问题、Web应用程序功能受限问题</p><h2 id="页面结构对比">0.1. 页面结构对比</h2><p>HTML5之前通常直接使用div进行网页整体布局，常见的布局包括页眉、页脚、导航菜单和正文部分。为了区别文档结构中不同的div一般会为其配上不同的id名称</p><h2 id="结构元素">0.2. 结构元素</h2><h3 id="header标签">0.2.1. header标签</h3><p>用于定义文章的页眉，其中包含多个标题、导航或普通内容</p><h3 id="article标签">0.2.2. article标签</h3><p>用于表示文档、页面或者应用程序中独立的、完整的、可以肚子被外部引用的内容</p><h3 id="aside标签">0.2.3. aside标签</h3><p>定义当前文章的附属信息，文章引用、广告等</p><h3 id="footer标签">0.2.4. footer标签</h3><p>定义脚注等</p><h3 id="figure标签">0.2.5. figure标签</h3><p>网站制作页面上一块独立的内容，将其移除后不会对网页上其他内容产生影响</p><h3 id="figcaption标签">0.2.6. figcaption标签</h3><p>定义figure元素的标题；位于figure元素的第一个或者最后一个子元素的位置</p><h2 id="页面节点">0.3. 页面节点</h2><h3 id="section标签">0.3.1. section标签</h3><p>定义文章的节，一般用于成节的内容，会在文档流中开始一个新的节。用来表现普通的文档内容或应用区块，通常由内容及其标题组成</p><h3 id="nav标签">0.3.2. nav标签</h3><p>代表页面的一个部分，是一个可以作为页面导航的链接组，导航元素链接到其他页面或者当前页面的其他部分，使html代码在语义化方面更加精确，同时对于屏幕阅读器等设备的支持更好</p><h3 id="address标签">0.3.3. address标签</h3><p>用于被作者提供该文档的联系人信息，一般放在开头或者结尾，最常用的是和其他内容包含在footer元素内。</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2交互元素</title>
    <link href="/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.2%E4%BA%A4%E4%BA%92%E5%85%83%E7%B4%A0/"/>
    <url>/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.2%E4%BA%A4%E4%BA%92%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="3-2交互元素">0.0.0.1. 3.2交互元素</h4><span id="more"></span><p>对于应用程序来说，表现最为突出的就是交互操作</p><p>HTML5为操作新增了对应的交互体验元素：progress、meter、details、summary、menu、command等，这些元素可以在不请求服务器的情况下，改变用户选择内容与展现状态。通过这些元素可以更好的改善HTML5页面的用户体验和功能</p><h2 id="交互元素">0.1. 交互元素</h2><h3 id="progress元素">0.1.1. progress元素</h3><p>属于状态交互元素。用来表示页面中某个任务完成的进度。显示可以使用整数，也可以使用百分比</p><p>progress元素的属性：</p><ul><li>max   规定任务一共需要多少工作</li><li>value   规定已经完成了多少任务</li></ul><h3 id="meter元素">0.1.2. meter元素</h3><p>状态交换元素，和progress很像</p><p>meter元素属性：</p><ul><li>form：规定meter元素所属的一个或多个表单</li><li>high：规定被视作高的值的范围</li><li>low：规定被视作低的值的范围</li><li>max：规定范围的最大值</li><li>min：规定范围的最小值</li><li>optimum：规定度量的优化值</li><li>value：必需，规定度量的当前值</li></ul><h3 id="detail元素">0.1.3. detail元素</h3><p>detail元素用来说明文档的详细信息，展开和折叠的交互效果</p><p>details元素的属性：</p><ul><li>Open：details元素是否可见，默认为不可见</li><li>Subject：设置元素所对应的ID号</li><li>Draggable：设置是否可以拖动元素，默认为false</li></ul><h3 id="menu元素">0.1.4. menu元素</h3><p>是一个旧标记。一系列菜单命令的集合。</p><p>menu元素的属性：</p><ul><li>lable：规定菜单的可见标签</li><li>type：规定要显示哪种菜单类型</li></ul><h3 id="command元素">0.1.5. command元素</h3><p>用于定义各种类型的命令按钮，只有commend在menu内时，该元素才是可见的</p><p>command元素的属性：</p><ul><li>checked：定义是否被选中，仅用于radio、checkbox类型</li><li>disabled：定义command是否可用</li><li>icon：定义作为commend来显示的图像URL</li><li>label：为command定义可见的label</li><li>radiogroup：定义command所属组名。类型为radio时使用</li><li>type：定义command类型，默认是command</li></ul>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.4全局属性</title>
    <link href="/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.4%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7/"/>
    <url>/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.4%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="3-4全局属性">0.0.0.1. 3.4全局属性</h4><span id="more"></span><h2 id="全局属性定义">0.1. 全局属性定义</h2><p>全局属性是对于任何一个标签都可以使用的属性。在HTML5中新增了一些全局属性，这些全局属性可以表达非常丰富的语义，也会额外提供很多的使用功能</p><h2 id="全局属性有哪些">0.2. 全局属性有哪些</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accesskey</td><td>规定激活元素的快捷键</td></tr><tr><td>class</td><td>规定一个元素的一个或多个类名</td></tr><tr><td>contenteditable</td><td>规定元素内容是否可以编辑</td></tr><tr><td>contextmenu</td><td>规定元素的上下文菜单</td></tr><tr><td>data</td><td>用于存储页面或者应用程序的私有定制数据</td></tr><tr><td>dir</td><td>规定元素中内容的文本方向</td></tr><tr><td>draggable</td><td>规定元素是否可被拖动</td></tr><tr><td>dropzone</td><td>规定在拖动数据时是否进行复制、移动或链接</td></tr><tr><td>hidden</td><td>规定元素是否显现</td></tr><tr><td>id</td><td>规定元素的唯一id</td></tr><tr><td>lang</td><td>规定元素内容的语言</td></tr><tr><td>spellcheck</td><td>规定是否对元素进行拼写和语法检查</td></tr><tr><td>style</td><td>规定元素的行内CSS样式</td></tr><tr><td>tabindex</td><td>规定元素的tab键次序</td></tr><tr><td>title</td><td>规定有关元素的额外信息</td></tr><tr><td>translate</td><td>规定是否应该翻译元素内容</td></tr></tbody></table><h2 id="如何设置全局属性">0.3. 如何设置全局属性</h2><h3 id="hidden属性">0.3.1. hidden属性</h3><p>设置了hidden属性的段落将不再显示</p><h3 id="spellcheck属性">0.3.2. spellcheck属性</h3><p>拼写和语法检查的属性，可对拼写和语法进行检查并在下面画红线。只有元素可以编辑spellcheck属性才有意义，主要争对文本输入或者多行文本输入</p><h3 id="contenteditable属性">0.3.3. contenteditable属性</h3><p>规定是否允许用户编辑内容，通常在input标签中使用</p><h3 id="contextmenu属性">0.3.4. contextmenu属性</h3><p>规定元素上下文菜单，当用户右键点击元素时，会出现上下文菜单</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3文本层次语义元素及分组元素</title>
    <link href="/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.3%E6%96%87%E6%9C%AC%E5%B1%82%E6%AC%A1%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0%E5%8F%8A%E5%88%86%E7%BB%84%E5%85%83%E7%B4%A0/"/>
    <url>/gzguo/2020/10/05/Web/3%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7/3.3%E6%96%87%E6%9C%AC%E5%B1%82%E6%AC%A1%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0%E5%8F%8A%E5%88%86%E7%BB%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="3-3文本层次语义元素及分组元素">0.0.0.1. 3.3文本层次语义元素及分组元素</h4><span id="more"></span><h2 id="文本层次语义元素">0.1. 文本层次语义元素</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>em</td><td>把文本定义为强调内容</td></tr><tr><td>strong</td><td>把文本定义为语气更强的强调内容</td></tr><tr><td>dfn</td><td>定义一个定义项目</td></tr><tr><td>code</td><td>定义计算机代码文本</td></tr><tr><td>samp</td><td>定义样本文本</td></tr><tr><td>kbd</td><td>定义键盘文本</td></tr><tr><td>var</td><td>定义变量</td></tr><tr><td>cite</td><td>定义引用</td></tr></tbody></table><h3 id="cite元素">0.1.1. cite元素</h3><p>创建一个引用标记，用来指明某内容的引用或参考源</p><h3 id="mark元素">0.1.2. mark元素</h3><p> 定义带有记号的文本，可以高亮显示文档中的文字以达到醒目的效果</p><h3 id="time元素">0.1.3. time元素</h3><p>定义日期或者时间，可以使用机器能够读懂的方式对日期和时间进行编码</p><h2 id="分组元素">0.2. 分组元素</h2><table><thead><tr><th>元素名称</th><th>说明</th></tr></thead><tbody><tr><td>div</td><td>没有任何语义的通用元素，与span对应</td></tr><tr><td>blockquote</td><td>表示摘自另一个源的大段内容</td></tr><tr><td>pre</td><td>表示其格式应被保留的内容</td></tr><tr><td>ul、ol</td><td>表示无序列表，有序列表</td></tr><tr><td>li</td><td>用于ul，ol元素中的列表项</td></tr><tr><td>dl、dt、dd</td><td>表示含有一系列术语和定义说明的列表</td></tr><tr><td>figure</td><td>表示图片</td></tr><tr><td>figcaption</td><td>表示figure大元素的标题</td></tr></tbody></table><h3 id="ul元素">0.2.1. ul元素</h3><p>表示不排序的项目列表，相当于word中的项目符号。无序列表使用一对标记ul标识，每一个列表项使用li</p><h3 id="ol元素">0.2.2. ol元素</h3><p>排序的项目列表，相当于word中的自动编号功能，适用语法和ul基本相同，列表项使用li</p><h3 id="dl元素">0.2.3. dl元素</h3><p>dl用于自定义列表，一般与dt和dd一起使用，dt定义列表名称，dd定义内容</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3文本控制标签</title>
    <link href="/gzguo/2020/09/29/Web/2HTML5/2.3%E6%96%87%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%A0%87%E7%AD%BE/"/>
    <url>/gzguo/2020/09/29/Web/2HTML5/2.3%E6%96%87%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="2-3文本控制标签">0.0.0.1. 2.3文本控制标签</h4><span id="more"></span><h2 id="标题段落标签">0.1. 标题段落标签</h2><h3 id="hi（双）">0.1.1. hi（双）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">设定<span class="hljs-selector-tag">HTML</span>页面中段落的级数<br></code></pre></td></tr></table></figure><h3 id="p（双）">0.1.2. p（双）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">划分段落，控制文本位置<br></code></pre></td></tr></table></figure><h2 id="文本格式标签">0.2. 文本格式标签</h2><h3 id="br（单）">0.2.1. br（单）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定义换行<br></code></pre></td></tr></table></figure><h3 id="hr（单）">0.2.2. hr（单）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定义水平线<br></code></pre></td></tr></table></figure><ol><li>Size：宽</li><li>Width：长</li><li>Align：对齐方式</li><li>Noshade：无阴影属性</li><li>Color：颜色</li></ol><h3 id="div（双）">0.2.3. div（双）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">定义大块显示区<br></code></pre></td></tr></table></figure><h3 id="文本修饰标签（双）">0.2.4. 文本修饰标签（双）</h3><ol><li><p>font：字体样式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">里面的size属性值为<span class="hljs-number">1</span><span class="hljs-number">-7</span>，默认为<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li><li><p>b：相当于strong</p></li><li><p>i：斜体</p></li><li><p>big：比周围文本大一个字体尺寸</p></li><li><p>small</p></li><li><p>s：删除线</p></li><li><p>u：下划线</p></li><li><p>sup：上标形式</p></li><li><p>sub：下标形式</p></li><li><p>strong</p></li><li><p>mark：带有记号的方式显示</p></li></ol><h3 id="span（双）">0.2.5. span（双）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">行内标签，用来组合文档中的行内元素<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>和<span class="hljs-selector-tag">div</span>的主要区别<br>    <span class="hljs-selector-tag">span</span>不换行，<span class="hljs-selector-tag">div</span>换行<br>    <span class="hljs-selector-tag">span</span>不能包含<span class="hljs-selector-tag">div</span>，<span class="hljs-selector-tag">div</span>可以包含<span class="hljs-selector-tag">span</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符标签">0.3. 特殊字符标签</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">可用于设定数学公式、版权信息中的特殊字符。通常以“<span class="hljs-meta">&amp;”开始，以“;”结束</span><br>如<span class="hljs-meta">&amp;gt;代表&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4图片标签</title>
    <link href="/gzguo/2020/09/29/Web/2HTML5/2.4%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/"/>
    <url>/gzguo/2020/09/29/Web/2HTML5/2.4%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="2-4图片标签">0.0.0.1. 2.4图片标签</h4><span id="more"></span><h2 id="gif">0.1. gif</h2><p>支持动画、无损图像格式、支持透明</p><p>常用于小图标、LOFO及其他色彩相对单一的图像</p><h2 id="png">0.2. png</h2><p>相对于gif体积更小，支持alpha透明（全透明、半透明、全不透明）颜色过度更平滑、不支持动画、无损压缩</p><h2 id="jpg">0.3. jpg</h2><p>显色比上面两个多得多、有损压缩</p><h2 id="网页插入图像">0.4. 网页插入图像</h2><h3 id="body-background">0.4.1. body background</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&lt;<span class="hljs-keyword">body</span> background=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/<span class="hljs-keyword">body</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="img">0.4.2. img</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>alt：规定图像的代替文本</li><li>src：规定图像的URL</li><li>height：规定图像的高度</li><li>ismap：把图象设置为服务器端图像映射</li><li>usemap：把图象设置为客户端图像映射</li><li>width：规定图像宽度</li></ul><h3 id="路径">0.4.3. 路径</h3><p>相对路径、绝对路径</p>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.6表格标签</title>
    <link href="/gzguo/2020/09/29/Web/2HTML5/2.6%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE/"/>
    <url>/gzguo/2020/09/29/Web/2HTML5/2.6%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="2-6表格标签">0.0.0.1. 2.6表格标签</h4><span id="more"></span><h2 id="怎样创建表格标签">0.1. 怎样创建表格标签</h2><p>表格不仅可以清晰的显示数据，而且还可以用来进行页面布局，在早期的网页设计中具有重要的作用</p><p>在基本的表格结构中，基本构造三要素：</p><ol><li>表格标题</li><li>项目表头</li><li>数据资料</li></ol><h3 id="基本语法">0.1.1. 基本语法</h3><ul><li>table标签：定义表格</li><li>caption标签：定义表格标题，嵌套在table中</li><li>tr标签：定义表格中的一行，嵌套在table中</li><li>th标签：定义表格中的表头单元格，嵌套在tr中</li><li>td标签：定义表格中的数据单元格，嵌套在tr中</li></ul><h2 id="怎么设置表格属性">0.2. 怎么设置表格属性</h2><h3 id="设置表格标记的属性">0.2.1. 设置表格标记的属性</h3><table><thead><tr><th>属性名</th><th>含义</th><th>常用属性值</th></tr></thead><tbody><tr><td>border</td><td>设置表格的边框(默认0无边框)</td><td>像素值</td></tr><tr><td>cellspacing</td><td>设置单元格与单元格边框之间的空白间距</td><td>像素值默认为2</td></tr><tr><td>cellpadding</td><td>设置单元格内容与单元格边框之间的空白间距</td><td>像素值默认为1</td></tr><tr><td>width</td><td>设置表格的宽度</td><td>像素值</td></tr><tr><td>height</td><td>设置表格的高度</td><td>像素值</td></tr><tr><td>align</td><td>设置表格在网页中的水平对齐方式</td><td>left center right</td></tr><tr><td>valign</td><td>设置一行内容垂直对齐方式</td><td>top middle bottom</td></tr><tr><td>bgcolor</td><td>设置表格的背景颜色</td><td>于定义的颜色值RGB</td></tr><tr><td>background</td><td>设置表格的背景图片</td><td>url地址</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5超链接标签</title>
    <link href="/gzguo/2020/09/29/Web/2HTML5/2.5%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%87%E7%AD%BE/"/>
    <url>/gzguo/2020/09/29/Web/2HTML5/2.5%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="2-5超链接标签">0.0.0.1. 2.5超链接标签</h4><span id="more"></span><h2 id="什么是超链接">0.1. 什么是超链接</h2><p>跳转</p><h2 id="超链接分类">0.2. 超链接分类</h2><ul><li>按路径不同分：</li></ul><ol><li>内部链接</li><li>锚点链接</li><li>外部链接</li></ol><ul><li>按使用对象不同分</li></ul><ol><li>文本超链接</li><li>图像超链接</li><li>E-mail链接</li><li>锚点链接</li><li>多媒体文件链接</li><li>空连接</li></ol><h2 id="什么时链宿和链源">0.3. 什么时链宿和链源</h2><h3 id="链宿">0.3.1. 链宿</h3><p>是指要跳转的目标，这个目标可以是一个网页、一个图片、一个电子邮件地址、一个文件、一个应用程序</p><h3 id="链源">0.3.2. 链源</h3><p>引起跳转的原因，可以实文字、图像、图形区域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">链宿</span>&gt;</span>链源<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="如何实现HTML的超链接">0.4. 如何实现HTML的超链接</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">href      链宿的路径                用于设置要跳转的目标<br><span class="hljs-keyword">name</span>   创建文档标签             用于指定锚的名称<br><span class="hljs-built_in">title</span>      指向链接的提示信息   使用<span class="hljs-built_in">title</span>属性可以让鼠标悬停在超链接上的时候，显示该超链接的文字注释<br>target  指定打开的目标窗口   有五种取值，默认值_self<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开始数据结构</title>
    <link href="/gzguo/2020/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%80%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/gzguo/2020/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%80%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="数据结构开端">0.0.0.1. 数据结构开端</h4><span id="more"></span><p>数据存储的结构：线性存储、非线性存储(树、图)</p><h2 id="线性结构">0.1. 线性结构</h2><p>线性结构的简单叙述：把所有的节点用一根直线穿起来</p><p>节点：类似于数组的元素，单个个体或者事务(专有名词)</p><p>线性结构可以分为：连续存储(数组)、离散存储(链表)。这两种存储方式从逻辑上讲是一样的，但是内部的实现不一样。</p><p> 线性结构两种最常用的应用：栈和队列</p><p>栈：函数调用、内存分配</p><p>队列：所有和时间有关的操作</p><h2 id="数组">0.2. 数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> *pArr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * length);<br></code></pre></td></tr></table></figure><p>ArrayList：List代表他是线性结构，Array代表他是以数组实现的</p><p>LinkedList：List代表他是线性结构，Linked代表他是以链表实现的</p><p>什么叫做数组？元素类型相同，大小相等</p><p>数组的优缺点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Arr</span>&#123;</span><br>  <span class="hljs-keyword">int</span> * pBase; <span class="hljs-comment">//存储的是数组第一个元素的地址</span><br>  <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//数组所能容纳的最大元素的个数</span><br>  <span class="hljs-keyword">int</span> cnt; <span class="hljs-comment">//当前数组有效元素的个数</span><br>  <span class="hljs-comment">//int increment; //自动增长因子 要学allocate()函数，动态扩充</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_string_start</title>
    <link href="/gzguo/2020/09/29/java/string/start/"/>
    <url>/gzguo/2020/09/29/java/string/start/</url>
    
    <content type="html"><![CDATA[<h4 id="string、ArrayList、多维数组">0.0.0.1. string、ArrayList、多维数组</h4><span id="more"></span><h1 id="String">1. String</h1><p>String是不可变字符序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//String是不可变的字符序列，有不一样的字符一定是在方法区中新建了一个</span><br><span class="hljs-comment">//但是String gh;这样的话，gh是一个变量，里面的引用地址可以改变</span><br><span class="hljs-comment">//看一下源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span><br><span class="hljs-class">     <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>,<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;,<span class="hljs-title">CharSequence</span></span>&#123;<br>     <span class="hljs-comment">//它是一个常量，会出现在方法区中，且唯一确定</span><br>     <span class="hljs-comment">//这就是String是不可变字符序列的与原因，出现不一样的字符一定是方法区中新建了一个</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">charAt(); <span class="hljs-comment">//查看索引位置对应的字符</span><br>equals(); <span class="hljs-comment">//比较内容是否相同</span><br>indexOf(); <span class="hljs-comment">//查看某个字符的索引位置</span><br>substring(<span class="hljs-number">0</span>); <span class="hljs-comment">//从某个内容开始截取字符串，直到末尾</span><br>split(); <span class="hljs-comment">//切割字符串</span><br>trim(); <span class="hljs-comment">//去掉首尾空格</span><br>replace(); <span class="hljs-comment">//替换掉某个字符</span><br>length(); <span class="hljs-comment">//长度，length是数组的属性，但是我们不能直接用，因为人家是私有的，只能通过方法来用</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">equalsIgnoreCase(); <span class="hljs-comment">//忽略大小写，比较内容是否相同</span><br>lastIndexOf(); <span class="hljs-comment">//该字母在字符串中最后出现的索引位置</span><br>startWith(); <span class="hljs-comment">//判断是不是以传入的字符串开头的</span><br>endWith(); <span class="hljs-comment">//判断是不是以传入的字符串结尾的</span><br>toLowerCase(); <span class="hljs-comment">//转为小写</span><br>toUpperCase(); <span class="hljs-comment">//转为大写</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们要避免下面的代码，创建对象太多，代码效率低</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String gh = <span class="hljs-string">&quot;a&quot;</span>;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * String gh = new String(&quot;a&quot;); //这一步生成两个对象</span><br><span class="hljs-comment">         * 这样的话执行下面的过程会生成12个对象</span><br><span class="hljs-comment">         */</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-comment">//gh所指向的地址可以不断发生变化</span><br>            <span class="hljs-comment">//但是每执行一次，会在方法区中生成一个新的String类型的常量，</span><br>            <span class="hljs-comment">//这个时候gh指向了这个常量，通过gh得到的值，就是这个新创建的String类型的常量</span><br>            <span class="hljs-comment">//gh是一个局部变量，存放在栈中</span><br>            gh += i;<br>            <span class="hljs-comment">//一共创建了11个对象</span><br>        &#125;<br>        System.out.println(gh);<br>        <span class="hljs-comment">//输出结果：a0123456789</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="StringBuilder">2. StringBuilder</h1><p>StringBuilder出现的意义：防止项目中多次操作String，创建太多对象，代码效率低。如果必须要创建很多的对象的话，又想要提升代码效率，那么StringBuilder应运而生。StringBuilder只创建一个对象，它使用了<strong>扩容机制</strong>，一开始会创建长度为16的数组，长度不足会自动扩容 value.length*2+2 ，这里会生成新数组，回收旧数组。这样的话就解决了String的字符串不可变序列的问题。StringBuilder就是可变的字符串序列。</p><p>StringBuilder创建新对象的时候，会自动给一个16位的数组，如果新建的时候有字符串。那么会给一个字符串.长度+16位的数组</p><p><strong>String是不可变字符序列，StringBuilder是可变字符序列(注意源码分析)</strong></p><p>StringBuilder和StringBuffer基本上是一样的</p><ul><li>StringBuilder是线程不安全的，效率高，我们一般用这个</li><li>StringBuffer是线程安全的，效率较低</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以通过retuen this来实现方法链，看下面：</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    String s = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;a&quot;</span>);<br>s.append(<span class="hljs-keyword">true</span>).append(<span class="hljs-number">321</span>).append(<span class="hljs-string">&quot;随便&quot;</span>); <span class="hljs-comment">//这个就称之为方法链</span><br><span class="hljs-comment">//append是追加的意思</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        StringBuilder gh = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-comment">//这样的话只需要创建两个对象</span><br>        <span class="hljs-comment">//第一个：&quot;a&quot;</span><br>        <span class="hljs-comment">//第二个：new StringBuilder(&quot;a&quot;)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            <span class="hljs-comment">//1000个数组长度不够用，扩容机制</span><br>            <span class="hljs-comment">//append()自带扩容：value.length*2+2;</span><br>            <span class="hljs-comment">//但是数组一旦确定长度就不能改变了，为了解决这个问题</span><br>            <span class="hljs-comment">//它做了一件事：创建了一个新数组，把旧数组放了进去</span><br>            <span class="hljs-comment">//把旧的数组根据垃圾回收机制回收</span><br>            gh.append(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="StringBuilder中的一些方法">2.1. StringBuilder中的一些方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">append(); <span class="hljs-comment">//拼接</span><br>delete(); <span class="hljs-comment">//根据索引位置删除数组中的元素，删头不删尾，(3,5)删的是索引为3，4的元素</span><br>replace(); <span class="hljs-comment">//取代</span><br>insert(); <span class="hljs-comment">//插入</span><br>reverse(); <span class="hljs-comment">//反转</span><br></code></pre></td></tr></table></figure><h2 id="StringBuffer">2.2. StringBuffer</h2><p>StringBuffer的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-comment">//比StringBuilder多了一个synchroized</span><br>    <span class="hljs-comment">//这个涉及到了线程安全</span><br>    <span class="hljs-comment">//除了这个，StringBuilder和StringBuffer没有任何区别，继承的同一个类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">super</span>.trimToSize();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模拟ArrayList容器">3. 模拟ArrayList容器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArrayList</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] value;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrayList</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//value = new Object[16];</span><br>        <span class="hljs-comment">//一个构造器调用另一个构造器</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">16</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArriayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        value = <span class="hljs-keyword">new</span> Object[size];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        value[size] = obj;<br>        size++;<br>        <span class="hljs-keyword">if</span>(size &gt;= value.length)&#123;<br>            <span class="hljs-comment">//装不下了。进行扩容</span><br>            <span class="hljs-keyword">int</span> newCapacity = value.length*<span class="hljs-number">2</span>;<br>            Object[] newList = <span class="hljs-keyword">new</span> Object[newCapacity];<br>            <span class="hljs-comment">//System.arraycopy(src,srcPos,dest,destPos,length);</span><br>            <span class="hljs-comment">//这段代码可以将旧数据的数据拷贝到新数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++)&#123;<br>                newList[i] = value[i];<br>            &#125;<br>            value = newList;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(); <span class="hljs-comment">//手动抛出异常，异常地抛出代表程序的停止</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> value[index];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组">3.1. 数组</h2><p>数组初始化的三种方式：</p><p>默认初始化：默认初始化为类型的默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：0，0</span><br><span class="hljs-keyword">boolean</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：false，fales</span><br>String[] s = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：null，null</span><br></code></pre></td></tr></table></figure><p>静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">//这个就是静态初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//动态初始化数组，先分配空间</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//给数组元素赋值</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">//给数组元素赋值</span><br></code></pre></td></tr></table></figure><p>多维数组：自己理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][];<br><span class="hljs-keyword">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][<span class="hljs-number">3</span>]; <span class="hljs-comment">//错误，</span><br><span class="hljs-comment">//第一个方括号内没值，第二个方括号内不能有值</span><br></code></pre></td></tr></table></figure><p>数组copy：</p><p>System类里包含了一个static void arraycopy(object src,int srcpos,object dest,int destpos,int length)方法，该方法可以将src数组里面的元素赋值给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多个元素赋给dest数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] s = &#123;<span class="hljs-string">&quot;Mircosoft&quot;</span>,<span class="hljs-string">&quot;IBM&quot;</span>,<span class="hljs-string">&quot;Oracle&quot;</span>,<span class="hljs-string">&quot;Apple&quot;</span>&#125;;<br>String[] sBak = <span class="hljs-keyword">new</span> String[<span class="hljs-number">6</span>];<br><span class="hljs-comment">//将s中的元素copy到sBak里面</span><br>System.arraycopy(s,<span class="hljs-number">0</span>,sBak,<span class="hljs-number">0</span>,s.length);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(); <span class="hljs-comment">//为数组排序</span><br>Arrays.toString(); <span class="hljs-comment">//打印数组</span><br>Arrays.fill(a,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100</span>); <span class="hljs-comment">//将2到4索引的元素替换为100</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_object_start</title>
    <link href="/gzguo/2020/09/29/java/object/start/"/>
    <url>/gzguo/2020/09/29/java/object/start/</url>
    
    <content type="html"><![CDATA[<h4 id="对象和类、内存分析、垃圾回收机制、构造器-this-、static、参数传值机制、包机制、import">0.0.0.1. 对象和类、内存分析、垃圾回收机制、构造器(this)、static、参数传值机制、包机制、import</h4><span id="more"></span><p>面向过程和面向对象</p><p>面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导着人们以不同的方式去分析、设计和开发软件</p><p>面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。这个适合简单任务，不需要过多协作的情况下。比如：如何开车</p><p>面向过程适合简单、不需要协作的事务。但是当我们思考比较复杂的问题，比如“如何造车”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了</p><p>面向对象：</p><p>OOA：面向对象分析</p><p>OOD：面向对象设计</p><p>面向对象思想更契合人的思维模式。我们首先思考的是“怎么设计这个事务？”。比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按照步骤造车的问题”</p><p>面向对象和面向过程的总结</p><ul><li>都是解决问题的思维方式，都是代码组织的方式</li><li>解决简单问题可以使用面向过程</li><li>解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。方法和控制语句就是典型的面向过程的产物</li></ul><p>对象就是一个内存块，包含了很多的数据</p><p>事物的发展总是遵循“量变引起质变”的哲学原则；企业管理和数据管理、甚至社会管理也有很多共通的地方</p><p>对象进化史(数据管理和企业管理共通之处)：</p><ul><li>数据无管理时代：数据量很少，数据不需要进行管理</li><li>数据管理和企业部门制：数据量增加，把同类型的数据放在一起。于是数组诞生了</li><li>对象和企业项目制：项目组就是一个小公司，类似于我们的对象，对象包含了不同类型的数据。</li></ul><h1 id="对象和类">1. 对象和类</h1><p>类可以看作是对象的模板，或者图纸，系统根据类的定义来造出对象</p><p>类：我们叫做class。</p><p>对象：我们叫做Object，instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思</p><h2 id="属性">1.1. 属性</h2><p>属性(field，或者叫成员变量)：属性用于定义该类或该对象包含的数据或者说静态特征，属性作用范围是整个类体，在定义成员变量时可以对其初始化，java使用默认的值对其初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法">1.2. 方法</h2><p>光有属性没有方法在c语言中叫<strong>结构体</strong></p><p>方法用来定义该类实例的行为特征。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数，面向过程中，函数是基本单位，整个程序由一个个的函数调用组成，面向对象中，整个程序的基本单位是类，方法是属于类和对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在学习&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在玩游戏&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法是程序执行的入口，必须要有滴</p><h2 id="典型的类">1.3. 典型的类</h2><p>new：代表创建一个对象</p><p>new调用了类的构造方法，通过构造方法创建了这个对象</p><p>构造方法：用来创建这个类的对象。无参的构造方法可以由系统自动创建</p><p>一个java文件可以写多个类，但是每个java文件只能有一个public修饰的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">text</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    Computer computer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我正在使用&quot;</span>+computer.brand+<span class="hljs-string">&quot;牌子的电脑学习&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        <span class="hljs-comment">//学生要想有电脑，首先得new一个电脑</span><br>        computer.brand = <span class="hljs-string">&quot;战神&quot;</span>;<br>        text text = <span class="hljs-keyword">new</span> text();<br>        text.computer = computer;<br>        text.study();<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span></span>&#123;<br>    String brand = <span class="hljs-string">&quot;神州&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="面向对象内存分析">2. 面向对象内存分析</h1><p>java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area</p><h2 id="栈">2.1. 栈</h2><p>栈的特点描述如下</p><ul><li>栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)</li><li>JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)</li><li>栈属于线程私有，不能实现线程间的共享</li><li>栈的存储特性是“先进后出，后进先出”，先进去的不能先出来被后面进来的挡住了</li><li>栈是由系统自动分配，速度快！栈是一个连续的内存空间</li></ul><h2 id="堆">2.2. 堆</h2><p>堆的特点如下：</p><ul><li>堆用于存储创建好的对象和数组(数组也是对象)</li><li>JVM只有一个堆，被所有的线程共享</li><li>堆是一个不连续的内存空间，分配灵活，速度慢</li></ul><h2 id="方法区-静态区">2.3. 方法区(静态区)</h2><ul><li>JVM只有一个方法区，被所有线程共享</li><li>方法区实际也是堆，只是用于存储类、常量的相关信息</li><li>用来存放程序中永远不变或唯一的内容。(类信息Class对象、静态变量、字符串常量等)</li></ul><h2 id="执行一个java文件">2.4. 执行一个java文件</h2><p>第一步：javac 类.java 生成.class文件，交给JRE</p><p>第二步：java 类名 ，交给底层操作系统</p><p>先在方法区存储类的相关信息：1.代码 2.静态变量 3.静态方法 4.字符串常量 。这个执行完之后相当于第二部执行完了。</p><p>然后就会去找main方法，找到main方法之后会在栈中为main方法开辟一块栈帧</p><p>碰到new之后，先为构造方法开辟一块栈帧，构造器执行完成之后会在堆中创建一块内存来存放对象，每个对象都会有一个地址。main方法中的对象名就会等于这个地址，以后再引用对象名的时候会直接指向堆内存地址去操作这个对象，栈帧和堆中的内存有了一种联系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//computer 这是一个局部变量，会存放在main方法的栈帧中</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      new Computer()会传回堆中的内存地址，</span><br><span class="hljs-comment">      之后操作computer的时候都会直接操作堆中的内存。</span><br><span class="hljs-comment">      堆中的内存中存放着Computer对象的属性和方法，</span><br><span class="hljs-comment">      这样的话就可以直接调用Computer对象的属性和方法</span><br><span class="hljs-comment">    */</span><br>    Computer computer = <span class="hljs-keyword">new</span> Computer();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="垃圾回收机制">3. 垃圾回收机制</h1><p>垃圾回收机制(Garbage Collection)</p><p>java引入了垃圾回收机制，令c++程序员最头疼的内存管理问题迎刃而解，java程序员可以将更多的精力放到业务逻辑上而不是内存管理的工作上，大大的提高了开发效率</p><h2 id="垃圾回收要做的事情">3.1. 垃圾回收要做的事情</h2><ol><li>发现无用的对象</li><li>回收无用对象占用的内存空间</li></ol><p>垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的是没有任何变量引用该对象，java的垃圾回收器通过相关的算法发现无用对象，并进行清楚和整理</p><h2 id="垃圾回收的相关算法">3.2. 垃圾回收的相关算法</h2><ol><li>引用计数法：堆中每个对象都有一个引用计数，被引用一次，计数加一，被引用变量的值变为null，则计数减一，直到计数为零，则表示变成无用的对象，优点是算法简单，缺点是“循环引用无用对象”无法被识别，意思就是两个对象互相引用的话，他们的计数就都是1，不可能出现零，无法判断他们是不是无用的对象</li><li>引用可达法：(根搜索算法)程序把所有的引用关系看作是一张图，从一个节点GC、ROOT开始，寻找对应的应用节点，找到这个节点之后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</li></ol><h2 id="通用的分代垃圾回收机制">3.3. 通用的分代垃圾回收机制</h2><p>分代垃圾回收机制，是基于这样的一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象采用不同的回收算法，以便提高效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将对内存划分为Eden(年轻代)、Survivor(年轻代)、Tenured/Old(年老代)空间</p><p>持久代是在方法区里</p><h3 id="年轻代">3.3.1. 年轻代</h3><p>所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间，当年轻代区域存放满对象后，就将对象存放到年老带区域</p><h3 id="年老代">3.3.2. 年老代</h3><p>在年轻代中经历了N(默认为15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代和年老代区域</p><h3 id="持久代">3.3.3. 持久代</h3><p>用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著的影响</p><p>程序在持久代中的对象就在</p><p>Minor GC：用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同的，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p><p>Major GC：用于清理老年代区域</p><p>Full GC：用于清理年轻代、年老代区域。成本较高，会对系统性能产生影响</p><h3 id="垃圾回收过程">3.3.4. 垃圾回收过程</h3><ol><li>新创建的对象，绝大多数都会存储在Eden中</li><li>当Eden满了(达到一定比例)不能再创建新对象，则触发垃圾回收(Minor GC)，将无用的对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区</li><li>当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空</li><li>重复多次(默认为15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中</li><li>当Old区满了，则会触发一个一次完整的垃圾回收(FullGC)，之前新生代大垃圾回收称为(minorGc)</li></ol><h2 id="JVM调优和Full-GC">3.4. JVM调优和Full GC</h2><p>在对JVM调优的过程中，很大一部分工作就是对于Full Gc的调节。有如下原因可能导致Full GC：</p><ul><li>年老代(Tenured)被写满</li><li>持久代(Perm)被写满</li><li>System.gc()被显式调用(这里是程序建议GC启动，不是调用GC)</li><li>上一次GC之后Heap的各域分配略动态变化</li></ul><h1 id="开发中很容易造成内存泄露的操作">4. 开发中很容易造成内存泄露的操作</h1><p>如下四种情况最容易造成内存泄漏：</p><h2 id="1-创造大量无用对象">4.1. 1.创造大量无用对象</h2><p>比如我们在大量拼接字符串时，使用了String而不是StringBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>    str += i; <span class="hljs-comment">//相当于产生了10000个String对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-静态集合类的使用">4.2. 2.静态集合类的使用</h2><p>像HashMap、Vector、List等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放</p><h2 id="3-各种连接对象-IO流对象、数据库连接对象、网络连接对象-未关闭">4.3. 3.各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭</h2><p>IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不实用的时候一定要关闭</p><h2 id="4-监听器的使用">4.4. 4.监听器的使用</h2><p>释放对象时，没有删除相应的监听器</p><p>要点：</p><ul><li>程序员无权调用垃圾回收器</li><li>程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能</li><li>finalize方法，是java提供给程序员用</li></ul><h1 id="面向对象的基础知识">5. 面向对象的基础知识</h1><h2 id="构造器-构造方法">5.1. 构造器(构造方法)</h2><p>构造器也叫构造方法(constructor)，用于对象的初始化</p><p>要点：</p><ul><li>通过new关键字调用</li><li>构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能再构造器里使用return返回某个值</li><li>如果我们没有定义构造器，则编译器会自动的定义一个无参的构造函数。如果已定义则编译器不会自动添加</li><li>构造器的方法名必须和类名一致</li></ul><p>构造方法的重载</p><p>构造方法的第一句总是supper(); 就算你没加，系统会自动帮你添加</p><p>this表示创建好的对象</p><ul><li>来释放对象或资源的方法，但尽量少用</li></ul><h2 id="对象创建的过程和this的本质">5.2. 对象创建的过程和this的本质</h2><p>构造方法是创建java对象的重要途径，通过new关键字调用构造器，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。</p><p>创建一个对象分为以下四步：</p><ul><li>分配对象空间，并将对象成员变量初始化为0或空</li><li>执行属性值的显式初始化</li><li>执行构造方法</li><li>返回对象的地址给相关变量</li></ul><p>this的本质就是“创建好的对象地址” 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”</p><p>this最常的用法：</p><ul><li><p>在程序中产生二义性之处，应使用this来指明当前对象；普通方法中，this总是指向调用该方法的对象。构造方法中，this总指向正要初始化的对象</p></li><li><p>使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">TestThis(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>    <span class="hljs-keyword">this</span>.b = b;<br>&#125;<br>TestThis(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)&#123;<br>    <span class="hljs-keyword">this</span>(a,b); <span class="hljs-comment">//必须放在第一句</span><br>    <span class="hljs-keyword">this</span>.c = c;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>this不能用于static方法中，因为this指的是当前对象。但是所有的静态方法和静态类都在方法区内，方法区内存放的是类信息，而不是对象信息</p></li></ul><h2 id="static关键字">5.3. static关键字</h2><h3 id="静态变量">5.3.1. 静态变量</h3><p>在类中，用static声明的成员变量，也称为类变量，类变量的生命周期和类相同，在整个应用程序执行期间都有效</p><p>静态变量的特点：</p><ol><li>为该类的公用变量，属于类，被该类的所有实例所共享，在类被载入时被显式初始化</li><li>对于该类的所有对象来说，static成员变量只有一份，被该类的所有对象共享</li><li>一般用“类名.类属性/方法”来调用(也可以通过对象引用或类名访问静态成员)</li><li>在static方法中不可直接访问非static的成员</li></ol><p>核心要点：</p><p>static修饰的成员变量和方法，从属于类</p><p>普通变量和方法式从属于对象的</p><h3 id="静态初始化块">5.3.2. 静态初始化块</h3><p>构造方法用于对象的初始化。静态初始化块，用于类的初始化操作，在静态初始化块中不能直接访问非static成员</p><p>注意事项：</p><ol><li>上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止</li><li>构造方法执行顺序和上面的顺序一致</li></ol><h2 id="参数传值机制">5.4. 参数传值机制</h2><p>java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。</p><h3 id="基本数据类型参数的传值">5.4.1. 基本数据类型参数的传值</h3><p>传递的是副本。副本改变不会影响原件</p><h3 id="引用类型参数的传值">5.4.2. 引用类型参数的传值</h3><p>传递的是值的副本，但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个地址，改变副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变</p><h2 id="包机制">5.5. 包机制</h2><p>包机制是java中管理类的重要手段。开发中，我们会遇到大量同名的类，通过包我们很容易解决类重名的问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用</p><p>我们通过package实现对类的管理，package有两个要点：</p><ol><li>通常是类的第一句非注释性语句</li><li>包名：域名倒着写即可，再加上模块名，便于内部管理类</li></ol><p>注意事项：</p><ol><li>写项目的时候都要加包，不要使用默认包</li><li>com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.test;  <span class="hljs-comment">//一定要是非注释性语句的第一句</span><br><span class="hljs-keyword">package</span> cn.*; <span class="hljs-comment">//导入包下的所有类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="import">5.6. import</h2><p>如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用。否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性</p><p>注意要点：</p><ol><li>java会默认导入java.lang包下的所有类，因此这些类我们可以直接使用</li><li>如果导入两个同名的类，只能用包名+类名来显示调用相关类</li></ol><p>同一个包下面两个类互相创建对象，不需要进行导入包，就可以创建对象</p><p>在不同包下的两个类不能互相创建对象，只能导入包，或者在包名之下写类名</p><h3 id="静态导入">5.6.1. 静态导入</h3><p>静态导入(static import)是在JDK1.5之后新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*; <span class="hljs-comment">//导入Math类的所有静态属性和方法</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;  <span class="hljs-comment">//导入Math类的PI属性</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(PI);<br>        System.out.println(random());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_object_end</title>
    <link href="/gzguo/2020/09/29/java/object/end/"/>
    <url>/gzguo/2020/09/29/java/object/end/</url>
    
    <content type="html"><![CDATA[<h4 id="多态深入、抽象类、接口、回调、内部类">0.0.0.1. 多态深入、抽象类、接口、回调、内部类</h4><span id="more"></span><h1 id="多态的内存分析">1. 多态的内存分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;HttpServlet.service()&quot;</span>);<br>        <span class="hljs-comment">//它调用了doGet()</span><br>        doGet();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;HttpServlet.doGet()&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;HttpServlet.doPost()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyServlet.doGet()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        HttpServlet s = <span class="hljs-keyword">new</span> MyServlet();<br>        s.service();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 输出结果：</span><br><span class="hljs-comment">         * HttpServlet.Service()</span><br><span class="hljs-comment">         * MyServlet.doGet()</span><br><span class="hljs-comment">         */</span>     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这个为什么会这样呢？</p><p>调用的时候总是会优先调用子类的构造方法，从子类的构造器开始向上寻找构造器，直到找到Object的构造器，开始向下执行构造器。</p><p>但是我们执行方法的时候，先寻找子类中是否存在该方法，不存在的话会向上寻找，一旦找到就会执行了，如果父类调用了某个方法，这个时候很特殊。由于this指的是当前对象(的地址)，指的还是子类对象，所以还是从子类中开始找。</p><p>咱们的例子：先在MyServlet中找service()，但是找不到，向上找，在HttpServlet中找到了，执行的时候service中执行了doGet()。因为this的原因，执行doGet的时候，又会重复一开始的操作，从MyServlet开始找，找到了，直接执行MyServlet的doGet()方法</p><h1 id="抽象类-abstract">2. 抽象类(abstract)</h1><p>抽象类就是有抽象方法的类：抽象方法就是只有声明，没有实现</p><p>抽象类是一种模板模式。抽象类为所有子类提供了一个通用模板，子类可以在这个模板基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格控制子类的设计，使子类之间更加通用</p><p>要点：</p><ul><li>有抽象方法的类只能定义成抽象类</li><li>抽象类不能实例化，不能使用new来实例化抽象类</li><li>抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能被子类调用</li><li>抽象类只能用来继承</li><li>抽象方法必须被子类实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-comment">//包含了抽象方法的类一定是抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//能这么调的原因：abstract不能被实例化，调用的run()是子类的</span><br>    <span class="hljs-comment">//抽象类只能用来继承</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">breath</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>        run();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//继承了Animal抽象类，就必须实现抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫步&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把设计和实现分开了,将方法的设计和方法的实现分开了</p><h1 id="接口">3. 接口</h1><p>interface，更加抽象，抽象类的抽象类。接口是最抽象的，接口里面放的就是基本不变的东西，以不变应万变</p><p>这个的目的就是，<strong>设计和实现分离</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义的时候用interface，除了定义的时候没有任何区别</span><br><span class="hljs-comment">//还是java文件，编译之后还是class文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span></span>&#123;<br>    <span class="hljs-comment">//接口里面只有：常量和抽象方法</span><br>    <span class="hljs-comment">//public static final有没有都一样，系统会自动加上的</span><br>    <span class="hljs-comment">/*public static final*/</span>String MAX_GREAD = <span class="hljs-string">&quot;Boss&quot;</span>;<br>    <span class="hljs-keyword">int</span> MAX_SPEED = <span class="hljs-number">120</span>;<br>    <br>    <span class="hljs-comment">//方法必须是public，不加的话，系统自动加public abstract</span><br>    <span class="hljs-comment">/*public abstract*/</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//怎么实现接口？</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span></span>&#123;<br>    <span class="hljs-comment">//implements：实现</span><br>    <span class="hljs-comment">//没有什么可以集成的，只要自己实现就行，不需要extends</span><br>    MyInterface.MAX_GREAD; <span class="hljs-comment">//调用接口中的常量</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 两个抽象方法必须都实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyClass.test1()&quot;</span>);<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类可以实现多个接口，但是一个类只能继承一个父类</p><p>java class不支持多继承，但是接口可以多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceA</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceB</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//接口是有多继承的</span><br><span class="hljs-comment">//接口可以多继承，因为接口足够简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InterfaceA</span>,<span class="hljs-title">InterfaceB</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceC</span></span>&#123;<br>    <span class="hljs-comment">//必须实现三个方法，InterfaceC继承的接口，这个类也得实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接口即规范</p><h1 id="回调的实现">4. 回调的实现</h1><p>CallBack/Hook/模板方法模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个类模拟回调</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaintFrame</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">(MyFrame f)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;启动线程&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;增加循环&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;查看消息线&quot;</span>);<br>        <br>        <span class="hljs-comment">//回调</span><br>        f.paint();<br>        <br>        System.out.println(<span class="hljs-string">&quot;启动缓存，增加效率&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        drawFram(<span class="hljs-keyword">new</span> GameFrame01());<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 输出结果：</span><br><span class="hljs-comment">         * 启动线程</span><br><span class="hljs-comment">         * 增加循环</span><br><span class="hljs-comment">         * 查看消息线</span><br><span class="hljs-comment">         * GameFrame01.Paint() //子类引用指向父类对象</span><br><span class="hljs-comment">         * 启动缓存，增加效率</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFrame</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyFrame.Paint()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameFrame01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyFrame</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;GameFrame01.Paint()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * java中的画窗口的实现类似于这个过程</span><br><span class="hljs-comment"> * 你不需要调用你写的画窗口的类，但他就直接相当于钩子执行了</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="内部类">5. 内部类</h1><p>innerclasses</p><p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个的内部定义，称为内部类</p><p>内部类的作用：</p><ul><li>内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包下的其他类直接访问</li><li>内部类可以直接访问外部类的私有属性，内部类被当作其外部类的成员。但外部类不能访问内部类的内部属性</li></ul><p>内部类的使用场合：</p><p>由于内部类提供了更好的封装性，并且可以很方便的访问外部类的属性。所以，通常内部类在只为所在外部类提供服务的情况下优先使用</p><h2 id="内部类的分类">5.1. 内部类的分类</h2><h3 id="成员内部类">5.1.1. 成员内部类</h3><p>就好像外部类的成员一样</p><p>可以使用private、protected、public 任意进行修饰。</p><p><strong>外部类文件：外部类.class</strong></p><p><strong>内部类文件：外部类$内部类.class</strong></p><h4 id="非静态内部类">5.1.1.1. 非静态内部类</h4><p>普通成员，外部类里使用非静态内部类和平时使用其他类没什么不同</p><ul><li><p>非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象，那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象</p></li><li><p>非静态内部类可以使用外部类的成员，但是外部类不能直接访问非静态内部类成员</p></li><li><p>非静态内部类不能有静态方法、静态属性、静态初始化块</p></li><li><p>静态成员不能访问非静态成员：外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例</p></li><li><p>成员变量访问要点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>内部类里的方法的局部变量：变量名<br><span class="hljs-number">2.</span>内部类的属性：<span class="hljs-keyword">this</span>.变量名<br><span class="hljs-number">3.</span>外部类的属性：外部类类名.<span class="hljs-keyword">this</span>.变量名<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span></span>&#123;<br>    <span class="hljs-keyword">int</span> type;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nose</span></span>&#123;<br>        String type;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">breath</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//内部类和外部类中都有type，怎么调用外部类的type</span><br>            System.out.println(Face.<span class="hljs-keyword">this</span>.type);<br>            <span class="hljs-comment">//如果内部类中没有type的话，想调用外部类的type，直接调用就行了</span><br>            System.out.println(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类的访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>外部类中定义内部类：newInnerClass()<br><span class="hljs-number">2.</span>外部类以外的地方使用非静态内部内：<br>  Outer.inner varname = OuterObject.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>    Face.Nose nose = <span class="hljs-keyword">new</span> Face().<span class="hljs-function">new <span class="hljs-title">Nose</span><span class="hljs-params">()</span></span>;<br>    Face f2 = <span class="hljs-keyword">new</span> Face();<br>    Face.Nose nose2 = f2.<span class="hljs-function">new <span class="hljs-title">Nose</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span></span>&#123;<br>    <span class="hljs-keyword">int</span> type;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nose</span></span>&#123;<br>        String type;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">breath</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Face f = <span class="hljs-keyword">new</span> Face();<br>        <span class="hljs-comment">//创建内部类的对象,但是得通过外部类来new</span><br>        <span class="hljs-comment">//鼻子的存在，必须先有一张脸</span><br>        Nose n = f.<span class="hljs-function">new <span class="hljs-title">Nose</span><span class="hljs-params">()</span></span>;<br>        Face.Nose n1 = f.<span class="hljs-function">new <span class="hljs-title">Nose</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态内部类">5.1.1.2. 静态内部类</h4><p>静态成员</p><p>使用要点：</p><ul><li><p>当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法/属性不能直接访问外部类的实例方法/属性</p></li><li><p>静态内部类看做外部类的一个静态成员。因此，外部类的方法中可以通过：静态内部类.名字 来访问静态内部类的静态成员。通过new静态内部类()访问静态内部类的实例</p></li><li><p>在外部类的外面创建静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Face.TestStaticInner aInner = <span class="hljs-keyword">new</span> Face.TestStaticInner();<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span></span>&#123;<br>    <span class="hljs-keyword">int</span> type;<br>    <span class="hljs-keyword">static</span> String color;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ear</span></span>&#123;<br>        <br>        <span class="hljs-comment">//这个里面不能调用外部的type，因为外部类中不一定有</span><br>        <span class="hljs-comment">//静态内部类和外部类在堆中是两个类的存在</span><br>        <span class="hljs-comment">//非静态内部类和外部类在堆中是一个类的存在，有非静态内部类必定有外部类</span><br>        <span class="hljs-comment">//所以非静态内部类可以直接调用外部类的属性和方法</span><br>        <br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>&#123;<br>           <span class="hljs-comment">//但是如果外部类中的属性是static的话，就可以直接调用</span><br>           System.out.println(color);<br>           System.out.println(<span class="hljs-string">&quot;听&quot;</span>);<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span></span>&#123;<br>    <span class="hljs-keyword">int</span> type;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ear</span></span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;听&quot;</span>);<br>       &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 非静态内部类</span><br><span class="hljs-comment">         * Face f = new Face();</span><br><span class="hljs-comment">         * //创建内部类的对象,但是得通过外部类来new</span><br><span class="hljs-comment">         * //鼻子的存在，必须先有一张脸</span><br><span class="hljs-comment">         * Nose n = f.new Nose();</span><br><span class="hljs-comment">         * Face.Nose n1 = f.new Nose();</span><br><span class="hljs-comment">         */</span><br>        <br>        <span class="hljs-comment">//可以直接创建对象，不需要Face对象</span><br>        Face.Ear e = <span class="hljs-keyword">new</span> Face.Ear();<br>        e.listen();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类">5.1.2. 匿名内部类</h3><p>适合那种只需要使用一次的类。比如：键盘监听操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类构造器(实参列表) 实现接口()&#123;<br><br><span class="hljs-comment">//匿名内部类类体</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.addWindowListener(<span class="hljs-keyword">new</span> WindowAdapter()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">windowClosing</span><span class="hljs-params">(WindowEvent e)</span></span>&#123;<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">this</span>.addKeyListener(<span class="hljs-keyword">new</span> KeyAdapter()&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keyPressed</span><span class="hljs-params">(KeyEvent e)</span></span>&#123;<br>        <span class="hljs-comment">//TODO Auto-generated method atub</span><br>        myTank.keyPressed(e);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keyReleased</span><span class="hljs-params">(KeyEvent e)</span></span>&#123;<br>        <span class="hljs-comment">//TODO Auto-generated method stub</span><br>        myTank.KeyReleased(e);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="局部内部类">5.1.3. 局部内部类</h3><p>定义在方法内部。作用域只限于本方法。用的非常少</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_object_next</title>
    <link href="/gzguo/2020/09/29/java/object/next/"/>
    <url>/gzguo/2020/09/29/java/object/next/</url>
    
    <content type="html"><![CDATA[<h4 id="对象的三大特征，数组">0.0.0.1. 对象的三大特征，数组</h4><span id="more"></span><h1 id="对象三大特征">1. 对象三大特征</h1><h2 id="继承">1.1. 继承</h2><p>继承让我们更加容易实现类的扩展。</p><p>从字面意思理解extend的意思是扩展。子类是父类的扩展。现实世界中的继承无处不在。</p><p>如何实现代码重用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExtends</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> height;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rest</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;休息一会&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> height;<br>    String major;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学习两小时&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rest</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;休息一会&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个Student和上面的Student是一样的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    String major;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学习两小时&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承的使用要点：</p><ul><li>父类也称作超类、基类、派生类等</li><li>Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护</li><li>java中类没有多继承，接口有多继承</li><li>子类继承父类，可以得到父类的全部属性和方法(除了父类的构造方法)，但不见得可以直接访问(比如，父类私有属性和方法)</li><li>如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object</li></ul><h3 id="instanceof运算符">1.1.1. instanceof运算符</h3><p>instanceof是二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">stu2 <span class="hljs-keyword">instanceof</span> Student<br>stu2 <span class="hljs-keyword">instanceof</span> Person<br>stu2 <span class="hljs-keyword">instanceof</span> Object<br></code></pre></td></tr></table></figure><h3 id="方法重写override">1.1.2. 方法重写override</h3><p>子类通过重写父类的方法，可以用自身的行为替换父类的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestOverride</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Horse h = <span class="hljs-keyword">new</span> Horse();<br>        h.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;跑&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;停止&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span></span>&#123;<br>    <span class="hljs-comment">//子类重写、覆盖了父类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;四蹄翻飞，嘚嘚嘚&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法重写需要符合下面三个要点：</p><ul><li>“==”：方法名、形参列表相同</li><li>“&lt;=”：返回值类型和声明异常类型，子类小于等于父类</li><li>“&gt;=”：访问权限，子类大于等于父类</li></ul><h3 id="Object类">1.1.3. Object类</h3><p>Object类是所有java类的根基类，也就意味着所有的java对象都拥有Object类的属性和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObject</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        TestObject to = <span class="hljs-keyword">new</span> TestObject();<br>        <span class="hljs-comment">//打印to和打印to.toString是一样的</span><br>        <span class="hljs-comment">//他有这个方法是因为它继承了Object类</span><br>         System.out.println(to);<br>         System.out.println(to.toString());<br>    &#125;<br>    <br>    <span class="hljs-comment">//重写toString</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;测试Object对象&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Object类的toString方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//第一部分是包下的类名，第二部分是堆中的地址</span><br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和equals方法">1.1.4. ==和equals方法</h3><p>“==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象</p><p>Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑</p><p>Object中的equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>    <span class="hljs-comment">//看地址是否相同，看是不是同一个对象</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>String中重写了equals方法，比较的是String中的值是否相同</p><h3 id="super">1.1.5. super</h3><p>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSuper</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">new</span> ChildClass.f();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FatherClass</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        value = <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;FatherClass.value = &quot;</span>+value);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FatherClass</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">super</span>.f(); <span class="hljs-comment">//调用父类对象的普通方法</span><br>        value = <span class="hljs-number">200</span>;<br>        System.out.println(<span class="hljs-string">&quot;ChildClass.value = &quot;</span>+value);<br>        System.out.println(value);<br>        System.out.println(<span class="hljs-keyword">super</span>.value); <span class="hljs-comment">//调用父类对象的成员变量</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * FatherClass.value = 100</span><br><span class="hljs-comment"> * ChildClass.value = 200</span><br><span class="hljs-comment"> * 200</span><br><span class="hljs-comment"> * 100</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>使用super调用普通方法，语句没有位置限制，可以在子类中随便调用</p><p>若是构造方法的第一行代码没有显式调用super或者this；那么java默认都会调用super()，含义是调用父类无参数的构造方法。这里super()可以省略</p><h4 id="这里涉及到了继承树的追溯">1.1.5.1. 这里涉及到了继承树的追溯</h4><p>属性/方法查找顺序：</p><ul><li>查找当前类中有没有属性h</li><li>依次上溯每个父类，查看每个父类中是否有h，直到Object</li><li>如果没有找到，则出现编译错误</li><li>上面步骤，只要找到h变量，则这个过程终止</li></ul><p>构造方法调用顺序：</p><p>构造方法第一句总是：super()来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化和构造方法</p><p>注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSuper</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始创建一个ChildClass对象……&quot;</span>);<br>        <span class="hljs-keyword">new</span> ChildClass();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FatherClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FatherClass</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创建FatherClass&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FatherClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChildClass</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创建ChildClass&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * 开始创建一个ChildClass对象……</span><br><span class="hljs-comment"> * 创建FatherClass</span><br><span class="hljs-comment"> * 创建ChildClass</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>步骤：第一步是向上找，第二步是向下执行</strong></p><h2 id="封装">1.2. 封装</h2><p>封装的含义：我们程序设计要追求“高内聚、低耦合”，高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用</p><p>编程中封装的具体优点：</p><ul><li>提高代码的安全性</li><li>提高代码的复用性</li><li>“高内聚”：封装细节，便于修饰内部代码，提高可维护性</li><li>“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作</li></ul><h3 id="封装的实现">1.2.1. 封装的实现</h3><p>封装的实现：使用访问控制符</p><p>java使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露。java四种访问控制符：private、default、protected、public，他们说明了面向对象的封装性，所以我们用他们尽可能的让访问权限降到最低，从而提高安全性</p><p>java四种访问控制符：</p><ul><li>private表示私有，只有自己的类能访问</li><li>default表示没有访问修饰符，只有同一个包的类能访问</li><li>protected表示可以被同一个包的类以及其他包中的子类访问</li><li>public表示可以被该项目的所有包中的所有类访问</li></ul><h3 id="封装的使用细节">1.2.2. 封装的使用细节</h3><p>类的属性的处理：</p><ul><li>一般使用private访问权限</li><li>提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作</li><li>一些只用于本类的辅助性方法可以用private修饰，希望其他类调用方法用public修饰</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt;= <span class="hljs-number">1</span> &amp;&amp; age &lt;= <span class="hljs-number">130</span>)&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;请输入正常人的年龄&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态">1.3. 多态</h2><p>多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同</p><p>多态的要点：</p><ul><li>多态是方法的多态，不是属性的多态(多态与属性无关)</li><li>多态的存在要有三个必要条件：继承，方法重写，父类引用指向子类对象</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPolym</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Animal();<br>        animalCry(a); <span class="hljs-comment">//执行结果：叫了一声</span><br>        Dog d = <span class="hljs-keyword">new</span> Dog();<br>        animalCry(d); <span class="hljs-comment">//执行结果：汪汪汪</span><br>        <span class="hljs-comment">//多态开始出现了，父类引用指向了子类对象</span><br>        <span class="hljs-comment">//传的是狗就会调用狗的构造方法，传的是猫就会调用猫的构造方法</span><br>        <span class="hljs-comment">//这就是多态，非常方便</span><br>        <span class="hljs-comment">//Animal d = new Dog(); 实际上还是狗</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">animalCry</span><span class="hljs-params">(Animal a)</span></span>&#123;<br>        a.shout();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;叫了一声&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的转型-casting">1.3.1. 对象的转型(casting)</h3><p>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换(子类可以自动转换成父类)</p><p>向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPolym</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Animal d = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">//自动向上转型</span><br>        Animal c = <span class="hljs-keyword">new</span> Cat(); <br>        <br>        Dog d2 = (Dog)d; <span class="hljs-comment">//强制向下转型</span><br>        Dog d3 = (Dog)c; <span class="hljs-comment">//编译时不会报错，但是运行的时候会出现 </span><br>         <span class="hljs-comment">//XX cannot be cast to XX 的错误</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;叫了一声&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组">2. 数组</h1><h2 id="final关键字">2.1. final关键字</h2><p>fianl关键字的作用：</p><ul><li><p>修饰变量：被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SPEEO = <span class="hljs-number">120</span>;<br></code></pre></td></tr></table></figure></li><li><p>修饰方法：该方法不可被子类重写。但是可以重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-comment">//重载是方法名相同，参数类型、参数个数不同</span><br><span class="hljs-comment">//重写是子类重写父类的方法，参数列表和返回类型都必须相同</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或类型不同，则称之为方法的重载</span><br><span class="hljs-comment"> * 方法重写是再子类存在方法与父类的方法的名字相同，而且参数个数与类型一样的方法，则称之为重写</span><br><span class="hljs-comment"> * 方法重载就是一个类的多态性的表现，而方法重写是子类与父类的一种多态性的表现</span><br><span class="hljs-comment"> /*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> /**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@Override</span>是伪代码，表示重写(当然也可以不写)，他有以下好处</span><br><span class="hljs-comment">  * 可以当注释用，方便阅读</span><br><span class="hljs-comment">  * 编译器可以给你验证<span class="hljs-doctag">@Override</span>下面的方法名是否是你的父类中所有的，如果没有则会报错。</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure></li><li><p>修饰类：修饰的不能被继承。比如Math、String等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="数组-1">2.2. 数组</h2><p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干数据，按照一定的先后次序组合而成。其中，每一个数据称之为一个元素，每个元素可以通过一个索引(下标)来访问他们</p><p>数组的三个基本特点：</p><ul><li>数组长度是确定的。数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型，不允许出现混合类型</li><li>数组类型可以实任何数据类型，包括基本类型和引用类型</li></ul><p>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</p><h2 id="数组声明">2.3. 数组声明</h2><p>注意事项：</p><ul><li>声明的时候没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关</li><li>声明一个数组的时候并没有数组真正被创建</li><li>构造一个数组，必须指定长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建基本类型的一维数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//声明数组</span><br>        s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//给数组分配空间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>            s[i] = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">//给数组元素赋值</span><br>            System.out.println(s[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组的初始化">2.4. 数组的初始化</h2><p>数组初始化方式共有三种：静态初始化、动态初始化、默认初始化</p><p>静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">//这个就是静态初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：0，0</span><br><span class="hljs-keyword">boolean</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：false，fales</span><br>String[] s = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认值：null，null</span><br></code></pre></td></tr></table></figure><p>动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//动态初始化数组，先分配空间</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//给数组元素赋值</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">//给数组元素赋值</span><br></code></pre></td></tr></table></figure><h2 id="数组的遍历">2.5. 数组的遍历</h2><p>数组元素下标的合法空间：[0,length-1].我们可以通过下标来遍历数组中的元素，遍历时可以读取元素的值或者修改元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arge)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-comment">//初始化数组元素的值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            a[i] = <span class="hljs-number">100</span>*i;<br>        &#125;<br>        <span class="hljs-comment">//读取元素的值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            System.out.println(a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-each循环">2.5.1. for-each循环</h3><p>增强for循环，for-each是JDK1.5新增加的功能，专门用于读取数组或集合中的所有元素，即对数组进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String[] ss = &#123;<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-string">&quot;ddd&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(String temp : ss)&#123;<br>            System.out.println(temp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_class_start</title>
    <link href="/gzguo/2020/09/29/java/class/start/"/>
    <url>/gzguo/2020/09/29/java/class/start/</url>
    
    <content type="html"><![CDATA[<h4 id="包装类、装箱、拆箱、时间类、文件类">0.0.0.1. 包装类、装箱、拆箱、时间类、文件类</h4><span id="more"></span><h1 id="包装类">1. 包装类</h1><p>包装类的作用：将基本类型包装成对象</p><p>主要介绍一下Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.MAX_VALUE; <span class="hljs-comment">//查看int类型的范围的最大值</span><br>Integer.toHexString(); <span class="hljs-comment">//转化为8进制</span><br>Integer.parseInt(); <span class="hljs-comment">//强转为Integer对象</span><br><span class="hljs-keyword">new</span> Integer(); <span class="hljs-comment">//强转为Integer对象</span><br>Integer.intValue(); <span class="hljs-comment">//强转为真正的数字</span><br>String str = <span class="hljs-number">234</span>+<span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//将数字转为字符串</span><br></code></pre></td></tr></table></figure><h1 id="自动装箱、拆箱">2. 自动装箱、拆箱</h1><p>自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">1000</span>; <span class="hljs-comment">//jdk5.0以前这样写是错的</span><br><span class="hljs-comment">//之后有了自动装箱，编译器帮我们改进代码,变成了如下的样子：</span><br><span class="hljs-comment">//Integer a = new Integer(1000);</span><br><span class="hljs-comment">//a还是对象</span><br></code></pre></td></tr></table></figure><p>自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> c = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1500</span>); <span class="hljs-comment">//jdk5.0以前这样写是错的</span><br><span class="hljs-comment">//编译改进：new Integer(1500).intValue();</span><br><br>Integer b = <span class="hljs-number">2000</span>;<br><span class="hljs-keyword">int</span> c = b; <span class="hljs-comment">//编译改进：b.intValue();</span><br><span class="hljs-comment">//如果 b=null ，编译器会报java.lang.NullPointerException</span><br><span class="hljs-comment">//表面上没有调用任何方法，实际上调用了b的intValue() b是空，就会报空指针</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>装箱的时候：-128到127之间的数依然被认为是基本数据类型</p><p>这样做的目的是提高效率</p><h1 id="时间类">3. 时间类</h1><p>java.util.Date 是个核心</p><p>java.text.DataFormat 它是个父类 ，看一下它的子类(实现类)：java.text.SimpleDateFormat</p><p>java.text.SimpleDateFormat的作用：把时间对象和字符串做转化</p><p>java.util.Calendar：日期计算</p><p>java.util.GregorianCalendar：是Calendar的子类，公立计算</p><p>开始学习java.util.Date:</p><ul><li>在标准的java类库中包含了一个Date类。他的对象表示特定的瞬间，精确到毫秒</li><li>java中时间表示的说白了也是数字，是从：标准纪元1970.1.1 0点开始到某个时刻的毫秒数，类型是long</li></ul><h2 id="DateFormat">3.1. DateFormat</h2><p>SimpleDateFormat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.currentTimeMillis(); <span class="hljs-comment">//得到当前时间</span><br>format<br>parse<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日 hh:mm:ss,属于本年的低w周&quot;</span>); <br><span class="hljs-comment">//这个规定了输出格式</span><br><br>Date d = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">123213123L</span>);<br>String str = df.format(d);<br>System.out.println(str); <span class="hljs-comment">//1970年01月02日</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;1977-7-7&quot;</span>;<br><span class="hljs-comment">//必须要有格式化，还得和上面的字符串相对应</span><br>DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-keyword">try</span>&#123;<br>    Date d = df.parse(str);<br>    System.out.println(d);<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Calendar">3.2. Calendar</h2><p>GregorianCalendar</p><p>月份：一月是0，二月是1，以此类推，12月是11</p><p>星期：星期日是一，星期六是七</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Calendar c = <span class="hljs-keyword">new</span> GregorianCalendar();<br>    c.set(<span class="hljs-number">2001</span>,Calendar.FEBRUARY,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>);<br>    Date d = c.getTime();<br>    System.out,println(d);<br>    <span class="hljs-comment">//输出结果：Sat Feb 10 12:23:34 CST 2001</span><br>    <span class="hljs-comment">//可以添加天数或者月数</span><br>    <span class="hljs-comment">//前面是类型，后面是数量</span><br>    c.add(Calendar.YEAR,<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">//想减的话就把30换成-30</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="file">4. file</h1><p>java.io.File：文件和目录路径名的抽象表现形式</p><p>通过File对象可以访问文件的属性</p><p>通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)</p><p>file里面有很多的方法，可以精确的操作某个文件，可以去网上百度一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/src/TestObject.java&quot;</span>);<br>f.createNewFile(); <span class="hljs-comment">//创建文件</span><br>f.delete(); <span class="hljs-comment">//删除文件</span><br>f.isFile(); <span class="hljs-comment">//判断是不是文件</span><br>f.isDirectory(); <span class="hljs-comment">//判断是不是目录</span><br>f.mkdirs(); <span class="hljs-comment">//创建目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础</title>
    <link href="/gzguo/2020/09/29/c++/c++%E5%9F%BA%E7%A1%80/c++start/"/>
    <url>/gzguo/2020/09/29/c++/c++%E5%9F%BA%E7%A1%80/c++start/</url>
    
    <content type="html"><![CDATA[<h4 id="c-基础">0.0.0.1. c++基础</h4><span id="more"></span><p>new和malloc的区别：</p><ol><li>new和delete操作配对，释放数组需要用delete[]指针。new和delete实际上调用了malloc和free，另外调用了类的构造函数和析构函数</li><li>malloc和free配对，malloc返回地时void指针，需要强转</li><li>new申请的内存保存在堆中，malloc申请的内存保存在自由存储区</li></ol><p>c++运算符：</p><ol><li>取模操作符：%</li><li>逻辑否、或、与：！&amp;&amp; ||</li><li>三元操作符：c = (a&gt;b)?a:b;</li><li>按位与、或、非：&amp; | ！</li><li>按位移：左移：&lt;&lt;；右移：&gt;&gt;</li></ol><p>引用：</p><p>指针,内存要为它分配一个存储空间。</p><p>引用,内存不分配空间的，引用只是一个别名。</p><p>就是在符号表里增加一个标志而已，对于语句int &amp;y=x; (&amp;x=&amp;y)为true。 </p><p>引用的一些规则：</p><ol><li>引用被创建的同时必须被初始化(指针则可以在任何时候被初始化)，否则会报编译错误</li><li>一旦引用被初始化，就不能改变引用的关系(指针可以随时改变所指的对象)</li><li>不能有NULL引用，引用必须与合法的存储单元关联(指针可以时NULL)</li><li>“sizeof引用”得到的是所指向的变量(对象)的大小，但是当引用作为成员时，其占用空间与指针相同(没找到标准的规定)</li><li>引用只能指向一个实际的变量，不能指向指针或引用</li><li>指针和引用在内部的实现其实没多大区别。但使用时有些地方是要注意的。因为引用具有对象行为，这一点很重要。引用赋值时会调用对象的复制函数，在涉及多态时，这地方很容易出错。</li></ol><p>const：</p><p>一般的const常量：</p><p>下面的两个声明都指向了一个const int类型的指针，指针所指向的内存不能被修改，但指针可以指向另一个内存：const int *p; int const * p;</p><p>int类型的const指针应该这样声明。指针所指向的内存可以被修改，但指针不能指向另一个内存：int * const r = &n;</p><p>简单总结一下就是，const int 类型的指针不能改变所指内容，而指针常量不能修改指针所指的地址</p><p>const在函数声明中的含义：</p><p>const int&amp; SetPoint(const int&amp; param) const</p><p>第一个const：函数的返回值限定为const，即返回值不能被修改。</p><p>第二个const：函数的形参为const类型，函数体内不能被修改</p><p>第三个const：表明这个函数不会对这个类对象的数据成员(非静态数据成员)作任何改变</p><p>类的const和static成员变量的初始化：</p><p>对于static成员变量，如果同时时const的，可以在类定义中初始化，否则只能在类定义外部初始化。非static的const成员变量只能在构造函数的初始化列表中初始化。</p><p>一些数据类型和变量赋值语法：</p><ol><li>union中的所有被声明的元素占据同一段内存空间，其大小取决于声明中最长的元素的大小。union的用途之一是将一种较长的基本类型与其他比较小的数据类型组成的结构或数组联合使用</li><li>long double和float变量的赋值方法：<br> 3.14159L // long double<br> 6.02e23f // float </li><li> 容易引起理解错误的定义语句：int* p,q; 第一眼看去，好像是p和q都是int*类型的，但事实上，只有p是一个指针，而q是一个最简单的int型变量。同时定义两个指针的语法是：int *p1, *p2; </li><li>定义一个指向int[4]数组的指针变量<br>  int (*p)[4]=RollNum;<br>  这里，p被声明为一个指向一个4元素（int类型）数组的指针</li><li>未指定size情况下，char数组的大小由初始化字符串决定：<br>   我们可以用下面两种方法的任何一种来初始化字符串mystring：<br>   char mystring [ ] = { ‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘/0’ };<br>   char mystring [ ] = “Hello”;                                                                                                            在两种情况下字符串或数组mystring都被定义为6个字符长(元素类型为字符char)：组成Hello的5个字符加上最后的空字符(‘/0’)。在第二种用双引号的情况下，空字符(‘/0’)是被自动加上的。两种情况下sizeof应该都是6，strlen都是5。 </li></ol><p>常用的几个标准函数：</p><ol><li>cout和cin的用法：                                                                                                                           cout &lt;&lt; “xxx” &lt;&lt; endl;<br>cin &gt;&gt; “yyy”; </li><li>常用的字符串函数：<br> strcat //字符串拼接<br> strcpy<br> strncpy<br> strcmp //字符串比较，相同返回0 </li></ol><p>switch-case写法：</p><p>  switch (expression)<br>  {<br>    case constant1:<br>      block of instructions 1<br>      break;<br>    case constant2:<br>      block of instructions 2<br>      break;<br>    .<br>    .<br>    .<br>    default:<br>      default block of instructions<br>  }</p><p>函数的几个属性和用法：</p><ol><li><p>指定函数的默认参数值： int divide(int a,int b = 2){}</p></li><li><p>什么是函数重载？(Overloaded functions)</p><p>两个不同的函数可以用同样的名字，只要他们的参数(arguments)的原型(prototype)不同，也就是说你可以把同一个名字给多个函数，如果他们用不同数量或类型的参数</p></li><li><p>内联函数</p><p>inline指令可以被放在函数声明之前，要求该函数在被调用的地方以代码形式被编译。这相当于一个宏定义(macro)。他的好处只对短小的函数有效，这种情况下为了避免调用函数的一些常规操作时间时间(overhead)，如参数堆栈操作的时间，所以编译结果的运行代码会更快一些</p><p>调用函数的时候不需要写关键字inline，只有在函数声明前需要写</p></li><li><p>将数组作为参数传入函数，传的是引用而不是值 void procedure(int myarray[][3])</p></li></ol><p>函数指针的用法：</p><ol><li><p>简单调用函数指针</p><p> 其中声明函数指针原型的代码可以在调用处写，也可以写成全局的。这种方法使用简单，适用于临时调用。 </p></li><li><p>使用typedef调用函数指针 </p><p> 这种方法适用于多次调用，先全局定义PFUNC，再在每个调用的地方声明临时变量后调用。 </p></li><li><p>C++类中调用成员函数指针（不使用typedef） </p><p> 和方法1类似，注意语法的不同。 </p></li><li><p>C++类中调用成员函数指针（使用用typedef） </p><p> 和方法2类似，注意语法的不同。 </p></li></ol><p> typedef的不常用用法 ：</p><p>typedf的一般用法是：typedf int UINT32;</p><p>但用来定义一个数组类型或指针函数时，比较特殊</p><p> typedef char CARRAY[32]; //定义了一个CARRAY的类型，代表char[32]</p><p> typedef void(*PFUN)(int); //定义了一个指向指针函数的变量类型，函数原型为void xxx(int yyy);</p><p>类的private/protected/public属性</p><ol><li>类成员如果没有指定访问域，默认识privatede的</li><li>标识符protected 与 private类似，他们唯一区别在继承时才表现出来。当定义一个子类的时候，基类的protected成员可以被子类的其他成员所使用，然而private成员就不可以</li><li>public/protected/private继承的区别：<ol><li>public继承：父类的public依然是public，protected依然是protected，private不可访问</li><li>protected继承：父类的public称为protected，protected称为private</li><li>private继承：父类的所有成员全部变成private</li></ol></li></ol><p>关于空类</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/gzguo/2020/09/28/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <url>/gzguo/2020/09/28/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="linux常见命令">0.0.0.1. linux常见命令</h4><span id="more"></span><h2 id="查看">0.1. 查看</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">whoami   查看当前登陆用户<br><span class="hljs-keyword">exit</span>   退出虚拟机的连接<br>pwd   查看当前路径<br>ps aux | grep mysql   查看某个进程<br>ps -ef|grep redis   查看进程是否激活<br>netstat -ntlup|grep <span class="hljs-number">8080</span>   查看<span class="hljs-number">8080</span>端口被谁占用<br>rm -rf 目录绝对位置   删除整个目录及目录下的所有文件<br>du --max-depth=<span class="hljs-number">1</span> -h   查看磁盘占用<br></code></pre></td></tr></table></figure><h2 id="vim搜索">0.2. vim搜索</h2><h3 id="搜索">0.2.1. 搜索</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:/</span>搜索内容<br></code></pre></td></tr></table></figure><h3 id="取消搜索">0.2.2. 取消搜索</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nohlsearch</span>    简写<span class="hljs-keyword">noh</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">nohlsearch</span>   简写<span class="hljs-keyword">set</span> <span class="hljs-keyword">noh</span><br></code></pre></td></tr></table></figure><h2 id="防火墙">0.3. 防火墙</h2><h3 id="添加端口">0.3.1. 添加端口</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=5000/tcp</span> --<span class="hljs-comment">permanent</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure><h3 id="开启关闭">0.3.2. 开启关闭</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl status firewalld.service   查看防火墙状态<br>firewall-cmd <span class="hljs-comment">--state   查看防火墙状态</span><br>firewall-cmd <span class="hljs-comment">--list-ports   查看防火墙开启的端口</span><br>firewall-cmd <span class="hljs-comment">--add-port=6379/tcp   添加端口</span><br>firewall-cmd <span class="hljs-comment">--list-services   查看防火墙开启的服务</span><br>systemctl <span class="hljs-keyword">start</span> firewalld   开启防火墙<br>systemctl stop firewalld   禁用防火墙<br>systemctl <span class="hljs-keyword">enable</span> firewalld   设置防火墙开机启动<br>systemctl <span class="hljs-keyword">disable</span> firewalld   停止并禁用开机启动<br>firewall-cmd <span class="hljs-comment">--reload   重启防火墙</span><br></code></pre></td></tr></table></figure><h3 id="永久打开端口">0.3.3. 永久打开端口</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">zone=public</span> --<span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8080/tcp</span> --<span class="hljs-comment">permanent</span>   <span class="hljs-comment">永久打开端口</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">reload</span>   <span class="hljs-comment">重新加载</span><br></code></pre></td></tr></table></figure><h2 id="添加swag分区">0.4. 添加swag分区</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/swapfile <span class="hljs-attribute">bs</span>=1M <span class="hljs-attribute">count</span>=1024<br>mkswap /swapfile<br>swapon /swapfile<br>free -m<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux常见命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/gzguo/2020/09/28/linux/%E9%83%A8%E7%BD%B2jar%E5%8C%85/"/>
    <url>/gzguo/2020/09/28/linux/%E9%83%A8%E7%BD%B2jar%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h4 id="部署jar包">0.0.0.1. 部署jar包</h4><span id="more"></span><h2 id="查看8080端口占用">0.1. 查看8080端口占用</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -ntulp <span class="hljs-string">| grep 8080</span><br></code></pre></td></tr></table></figure><h2 id="杀死8080端口">0.2. 杀死8080端口</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> ****<br></code></pre></td></tr></table></figure><h2 id="部署jar包-1">0.3. 部署jar包</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">nohup <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>**** &gt; ***.txt &amp;<br></code></pre></td></tr></table></figure><h2 id="清除txt文件内容">0.4. 清除txt文件内容</h2><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span> &gt; <span class="hljs-built_in">log</span>.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署jar包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows</title>
    <link href="/gzguo/2020/09/28/window/%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E9%A1%B9/"/>
    <url>/gzguo/2020/09/28/window/%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="windows添加启动项">0.0.0.1. windows添加启动项</h4><span id="more"></span><h1 id="Windows命令行">1. Windows命令行</h1><h2 id="添加启动项">1.1. 添加启动项</h2><h3 id="第一步">1.1.1. 第一步</h3><p><img src="../../../../images/image-20200817094450036.png" alt="image-20200817094450036"></p><h3 id="第二步">1.1.2. 第二步</h3><p><img src="../../../../images/image-20200817094425807.png" alt="image-20200817094425807"></p><h3 id="第三步">1.1.3. 第三步</h3><p>填写基本任务的名字和描述，添加启动任务即可</p><h2 id="连接外部端口">1.2. 连接外部端口</h2><p>可以测试阿里云的端口开放</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">telnet</span> <span class="hljs-number">112.124.17.86</span> <span class="hljs-number">3305</span><br></code></pre></td></tr></table></figure><p>命运石之门</p><p>鬼灭之刃</p>]]></content>
    
    
    <categories>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows添加启动项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea快捷键</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/idea/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/idea/</url>
    
    <content type="html"><![CDATA[<h4 id="idea快捷键、idea内存">0.0.0.1. idea快捷键、idea内存</h4><span id="more"></span><h1 id="idea快捷键">1. idea快捷键</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ctrl+alt+<span class="hljs-built_in">h</span>   查看类之间的继承关系<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">alt</span>+F<span class="hljs-number">7</span>   查看类之间的调用关系<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ctrl+alt+l   规范代码<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl+<span class="hljs-built_in">shift</span>+上   向上移动代码块<br>ctrl+<span class="hljs-built_in">shift</span>+下   向下移动代码块<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">shift+<span class="hljs-literal">tab</span>   向前移动代码块<br><span class="hljs-literal">tab</span>   向后移动代码块<br></code></pre></td></tr></table></figure><h1 id="idea分配内存">2. idea分配内存</h1><h2 id="idea-exe-vmoptions">2.1. idea.exe.vmoptions</h2><p>这个文件在idea安装目录的bin下，找到之后打开配置里面的参数即可</p><table><thead><tr><th align="center">参数</th><th align="center">参数描述</th></tr></thead><tbody><tr><td align="center">-Xms512m</td><td align="center">设置idea初始时的内存大小，提高java程序的启动速度</td></tr><tr><td align="center">-Xmx2048m</td><td align="center">设置idea最大内存数，提高该值，可以减少内存Garage收集的频率，提高程序性能</td></tr><tr><td align="center">-XX:ReservedCodeCacheSize=480m</td><td align="center">保留代码占用的内存容量</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>idea</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mariadb</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/mysql/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/mysql/</url>
    
    <content type="html"><![CDATA[<h4 id="mariadb下载">0.0.0.1. mariadb下载</h4><span id="more"></span><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span>|<span class="hljs-keyword">grep</span> mysql   查看yum源<br>rpm -ev mysql   删除yum源<br>rpm -ivh mysql   安装yum源<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PYTHONPATH=<span class="hljs-regexp">/usr/</span>lib64<span class="hljs-regexp">/python2.7/</span><br>export PYTHONHOME=<span class="hljs-regexp">/usr/</span>lib64<span class="hljs-regexp">/python2.7/</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/centos/</span><span class="hljs-number">7</span><span class="hljs-regexp">/os/</span>x86_64<span class="hljs-regexp">/Packages/</span>   yum等的镜像<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>redhat-release   查看服务器版本<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf cmake-<span class="hljs-number">3</span>.<span class="hljs-number">15</span>.<span class="hljs-number">3</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk-<span class="hljs-number">1.8.0.202</span>-<span class="hljs-number">1.8.1.2</span>.ns<span class="hljs-number">7</span>_<span class="hljs-number">4</span>.mips<span class="hljs-number">64</span>el/ java<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">yum -y install mariadb-server mariadb  <br><br>systemctl <span class="hljs-literal">start</span> mariadb  <span class="hljs-comment">#启动MariaDB</span><br><br>systemctl <span class="hljs-literal">stop</span> mariadb  <span class="hljs-comment">#停止MariaDB</span><br><br>systemctl restart mariadb  <span class="hljs-comment">#重启MariaDB</span><br><br>systemctl enable mariadb  <span class="hljs-comment">#设置开机启动</span><br><br>systemctl <span class="hljs-literal">start</span> mariadb.service<br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;/usr/lib64/python2.7/lib/python2.7/site-packages</span>&#x27;, <span class="hljs-symbol">&#x27;/usr/lib64/python2.7/lib/site-python</span>&#x27;]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mariadb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mariadb下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx静态服务器</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/nginx/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/nginx/</url>
    
    <content type="html"><![CDATA[<h4 id="nginx静态服务器配置及问题">0.0.0.1. nginx静态服务器配置及问题</h4><span id="more"></span><h2 id="nginx服务本地无法访问">0.1. nginx服务本地无法访问</h2><h3 id="查看nginx配置">0.1.1. 查看nginx配置</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">nginx -<span class="hljs-built_in">t</span>   #查看nginx配置是否正确  也可以切换到nginx的安装目录下的sbin目录下，执行<span class="hljs-symbol">:</span> ./nginx -<span class="hljs-built_in">t</span><br></code></pre></td></tr></table></figure><h3 id="查看nginx是否启动">0.1.2. 查看nginx是否启动</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> nginx  <span class="hljs-comment">#查看nginx端口</span><br></code></pre></td></tr></table></figure><h3 id="重新启动nginx">0.1.3. 重新启动nginx</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@izbp13r6miebokqjpa59gxz conf]# nginx -s reload<br>nginx: [alert] kill(2469, 1) failed (3: No such process)<br></code></pre></td></tr></table></figure><h3 id="去nginx的sbin下重启">0.1.4. 去nginx的sbin下重启</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin   去这个目录下   <br>./nginx   执行这个命令<br></code></pre></td></tr></table></figure><p>忽然间就好了，查看的文档中写的</p><h2 id="vsftpd">0.2. vsftpd</h2><h3 id="虽然nginx可以访问了，但ftp还是不能访问">0.2.1. 虽然nginx可以访问了，但ftp还是不能访问</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">systemctl <span class="hljs-built_in">start</span> vsftpd   重启<span class="hljs-keyword">ftp</span>服务 新<br>service vsftpd restart   重启<span class="hljs-keyword">ftp</span>服务<br></code></pre></td></tr></table></figure><h3 id="vsftpd的默认配置文件">0.2.2. vsftpd的默认配置文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>vsftpd/vsftpd_conf<br></code></pre></td></tr></table></figure><h3 id="最后尽然是访问路径不对">0.2.3. 最后尽然是访问路径不对</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ftp:<span class="hljs-regexp">//</span><span class="hljs-number">112.124</span>.<span class="hljs-number">17.86</span><span class="hljs-regexp">/www/im</span>ages   ftp的访问路径<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">112.124</span>.<span class="hljs-number">17.86</span>/images   nginx的访问路径<br></code></pre></td></tr></table></figure><h2 id="nginx配置">0.3. nginx配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">user ftpuser<br>autoindex on<br>root <span class="hljs-regexp">/home/</span>ftpuser<span class="hljs-regexp">/www/</span><br></code></pre></td></tr></table></figure><h2 id="vsftpd配置">0.4. vsftpd配置</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">anonymous_enable</span>=<span class="hljs-literal">NO</span><br><span class="hljs-attr">pasv_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attr">pasv_min_port</span>=<span class="hljs-number">50000</span><br><span class="hljs-attr">pasv_max_port</span>=<span class="hljs-number">60000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx静态服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java分页</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%88%86%E9%A1%B5/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="java物理分页">0.0.0.1. java物理分页</h4><span id="more"></span><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">com.github.pagehelper.Page&lt;Object&gt; page = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageHelper</span>.</span></span>start<span class="hljs-constructor">Page(<span class="hljs-params">pageForm</span>.<span class="hljs-params">getPageNum</span>()</span>, pageForm.get<span class="hljs-constructor">PageSize()</span>);<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">PageInfo pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PageInfo(<span class="hljs-params">page</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Page&lt;Object&gt; page = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageHelper</span>.</span></span>start<span class="hljs-constructor">Page(<span class="hljs-params">pageForm</span>.<span class="hljs-params">getPageNum</span>()</span>, pageForm.get<span class="hljs-constructor">PageSize()</span>);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java物理分页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java报错</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/problem/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/problem/</url>
    
    <content type="html"><![CDATA[<h4 id="redis、外键的错误解决">0.0.0.1. redis、外键的错误解决</h4><span id="more"></span><p>java报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">io.lettuce.core.RedisCommandExecutionException: MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs <span class="hljs-keyword">for</span> details about the error.<br></code></pre></td></tr></table></figure><p>错误描述：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">MISCONF Redis is configured to save RDB snapshots, but is currently<span class="hljs-built_in"> not </span>able to persist on disk. Commands that may modify the data set are disabled. Please<span class="hljs-built_in"> check </span>Redis logs for details about the error.<br>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用。请查看Redis日志的详细错误信息。<br></code></pre></td></tr></table></figure><p>解决 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs redis">#将stop-writes-on-bgsave-error设置为no<br><br>127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no<br></code></pre></td></tr></table></figure><h1 id="外键约束错误返回给前端">1. 外键约束错误返回给前端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    result = assetMapper.insert(asset);<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125; 添加资产成功&quot;</span>, asset.toString());<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SysException(e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SysException(<span class="hljs-string">&quot;数据异常，请重新输入&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果添加失败的话，finally块（必定执行）中进行判断，错误的话抛出系统异常</p><hr><p>事务处理</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">Transactional(<span class="hljs-params">propagation</span>=Propagation.SUPPORTS,<span class="hljs-params">rollbackFor</span>=Exception.<span class="hljs-params">class</span>)</span><br></code></pre></td></tr></table></figure><p>清空自增主键</p><p>truncate table (表名);</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">repair   去掉deadline<br><span class="hljs-keyword">return</span>   去掉id<br>scrap   去掉endTime<br><span class="hljs-keyword">use</span>   去掉endTime<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis、外键的错误解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/redis/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/redis/</url>
    
    <content type="html"><![CDATA[<h4 id="redis算法、启动、内存">0.0.0.1. redis算法、启动、内存</h4><span id="more"></span><h1 id="Redis">1. Redis</h1><h2 id="redis内存淘汰">1.1. redis内存淘汰</h2><h3 id="redis的内存大小">1.1.1. redis的内存大小</h3><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统中不限制内存大小，在32位操作系统众最多使用3GB内存</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; config set maxmemory <span class="hljs-number">100</span>mb   #设置Redis最大占用内存大小为<span class="hljs-number">100</span>M。<br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; config get maxmemory   #查看Redis的最大内存<br><br><span class="hljs-attribute">maxmemory</span> <span class="hljs-number">100</span>mb   #通过配置文件修改<br></code></pre></td></tr></table></figure><h3 id="redis的内存淘汰机制">1.1.2. redis的内存淘汰机制</h3><ul><li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误(DEL请求和部分特殊请求除外)</li><li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li><li>volatile-lru：从设置过期时间的key中使用LRU算法进行淘汰</li><li>allkeys-random：从所有key中随机淘汰数据</li><li>volatile-random：从设置了过期时间的key中随机淘汰</li><li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先淘汰</li></ul><p>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; config get maxmemory-policy   #查看当前的内存淘汰策略<br><span class="hljs-number">127.0.0.1:6379</span>&gt; config set maxmemory-policy allkeys-lru   #通过命令修改淘汰策略<br><br>maxmemory-policy allkeys-lru   #通过配置文件修改淘汰策略<br></code></pre></td></tr></table></figure><h3 id="LRU算法">1.1.3. LRU算法</h3><p>LRU（Least Recently Used），即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续网存储里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。</p><p>这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p><h2 id="Redis启动">1.2. Redis启动</h2><h3 id="Redis配置项">1.2.1. Redis配置项</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">port <span class="hljs-number">1111</span> <span class="hljs-comment"># 配置端口号、</span><br>bind <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>   允许远程访问<br>protected-mode no   允许远程访问<br>daemonize yes  <span class="hljs-comment"># 是否后台运行 daemonize yes/no</span><br>logfile <span class="hljs-regexp">/var/</span>log/redis.log  <span class="hljs-comment"># 日志文件位置</span><br>dbfilename dump.rbd  <span class="hljs-comment"># RDB持久化数据文件</span><br>dir <span class="hljs-regexp">/data/</span>redis  <span class="hljs-comment">#持久化文件的位置</span><br></code></pre></td></tr></table></figure><h3 id="redis启动">1.2.2. redis启动</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">：<span class="hljs-regexp">/application/</span>redis<span class="hljs-regexp">/src/</span>redis-server <span class="hljs-regexp">/etc/</span>redis.conf    <span class="hljs-comment">#在配置文件下启动</span><br><span class="hljs-regexp">/application/</span>redis<span class="hljs-regexp">/src/</span>redis-cli -p <span class="hljs-number">1111</span>   <span class="hljs-comment"># 连接</span><br><br>redis-server ../redis.conf <br></code></pre></td></tr></table></figure><h2 id="redis持久化">1.3. redis持久化</h2><p>原本的redis数据是存储在内存中的，重启redis之后数据就会消失，持久化就是可以将数据保存到硬盘，只需要在配置文件中加入以下配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>以配置文件重启redis</p><ul><li>查看redis服务占用的端口</li><li>杀死端口</li><li>重新启动</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span> 配置文件路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>reids</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis算法、启动、内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资金管理系统-高级搜索</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="高级搜索">0.0.0.1. 高级搜索</h4><span id="more"></span><h2 id="高级搜索-1">0.1. 高级搜索</h2><h3 id="资产高级搜索的参数">0.1.1. 资产高级搜索的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-keyword">private</span> Integer statusId;<br><br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-keyword">private</span> String source;<br><br><span class="hljs-keyword">private</span> String price;<br><br><span class="hljs-keyword">private</span> String intro;<br><br><span class="hljs-keyword">private</span> String photo;<br><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-keyword">private</span> Integer partitionId;<br><br><span class="hljs-keyword">private</span> Integer whomeId;<br><br><span class="hljs-keyword">private</span> Integer brandtypeId;<br><br><span class="hljs-keyword">private</span> LocalDate inTime;<br><br><span class="hljs-keyword">private</span> LocalDate outTime;<br><br><span class="hljs-keyword">private</span> String channel;<br><br><span class="hljs-keyword">private</span> LocalDate buyinTime;<br><br><span class="hljs-keyword">private</span> String model;<br><br><span class="hljs-keyword">private</span> String useTime;<br><br><span class="hljs-keyword">private</span> String measurement;<br><br><span class="hljs-keyword">private</span> Integer userId;<br><br><span class="hljs-keyword">private</span> Integer locationId;<br><br><span class="hljs-keyword">private</span> LocalDate repairStime;<br><br><span class="hljs-keyword">private</span> LocalDate repairEtime;<br><br><span class="hljs-keyword">private</span> Integer companyId;<br></code></pre></td></tr></table></figure><h3 id="领用表单搜索的参数">0.1.2. 领用表单搜索的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用人id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer userId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最后一次使用时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate endTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用处理人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer handlerId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer locationId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用工位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer partitionId;<br></code></pre></td></tr></table></figure><h3 id="报废表单搜索条件">0.1.3. 报废表单搜索条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废处理者id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer userId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废处理原因</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String reason;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废处理时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废完成时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate endTime;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对应资产的id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br></code></pre></td></tr></table></figure><h3 id="退库表单搜索条件">0.1.4. 退库表单搜索条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer id;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库存放地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer locationId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br></code></pre></td></tr></table></figure><h3 id="转移表单搜索条件">0.1.5. 转移表单搜索条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用人id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer userId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存放地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer locationId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer partitionId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理人id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer handlerId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br></code></pre></td></tr></table></figure><h3 id="调拨表单搜索条件">0.1.6. 调拨表单搜索条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨人id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer userId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨开始时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨前公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer companyPid;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨后公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer companyNid;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br></code></pre></td></tr></table></figure><h2 id="图表">0.2. 图表</h2><h3 id="资产状态走势图">0.2.1. 资产状态走势图</h3><p>路由：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">资产API<br><span class="hljs-regexp">/asset/</span>show<span class="hljs-regexp">/all/</span>status<br></code></pre></td></tr></table></figure><p>返回的信息及含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer use;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在库中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer ware;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer repair;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer borrow;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer ret;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer transfer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报废</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer scrap;<br></code></pre></td></tr></table></figure><h3 id="资产总量表">0.2.2. 资产总量表</h3><p>路由：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">货物列表API<br><span class="hljs-regexp">/show/</span>some/whome<br></code></pre></td></tr></table></figure><p>返回的信息及含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所在仓库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String wareName;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 货物类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String type;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 货物牌子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String brand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 货物数量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer num;<br></code></pre></td></tr></table></figure><h3 id="出入库对比图">0.2.3. 出入库对比图</h3><p>路由：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">货物列表API<br>/<span class="hljs-built_in">show</span>/<span class="hljs-built_in">some</span>/<span class="hljs-built_in">num</span><br></code></pre></td></tr></table></figure><p>返回的信息及含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 入库条数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer inNum;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 出库条数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer outNum;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产条目对应的出入库时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> List&lt;InOutDetailDto&gt; inOutDetailDtoList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 仓库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String wareHome;<br></code></pre></td></tr></table></figure><p>InOutDetailDto：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 入库时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate inTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 出库时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate outTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资金管理系统-增加下拉框</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%A2%9E%E5%8A%A0%E4%B8%8B%E6%8B%89%E6%A1%86/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%A2%9E%E5%8A%A0%E4%B8%8B%E6%8B%89%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<h4 id="增加下拉框">0.0.0.1. 增加下拉框</h4><span id="more"></span><h2 id="增加部门">0.1. 增加部门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddDepartmentForm</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String intro;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增加公司">0.2. 增加公司</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddCompanyForm</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-keyword">private</span> String logo;<br><br>    <span class="hljs-keyword">private</span> String intro;<br><br>    <span class="hljs-keyword">private</span> String phone;<br><br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增加牌子">0.3. 增加牌子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddBrandTypeForm</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String brandName;<br><br>    <span class="hljs-keyword">private</span> String brandIntro;<br><br>    <span class="hljs-keyword">private</span> String typeName;<br><br>    <span class="hljs-keyword">private</span> String typeIntro;<br><br>    <span class="hljs-keyword">private</span> Integer whomeId;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增加分区">0.4. 增加分区</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPartitionForm</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String remark;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增加存放地">0.5. 增加存放地</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddLocationForm</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>增加下拉框</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资金管理系统-展示页面接口</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%B1%95%E7%A4%BA/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="展示页面接口">0.0.0.1. 展示页面接口</h4><span id="more"></span><h2 id="出库领用">0.1. 出库领用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String user;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String company;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用部门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String department;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String location;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用后使用工位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String partition;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用处理人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String handler;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 领用备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产id（不用管这个）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对应的资产的信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="资产外借">0.2. 资产外借</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨处理人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String user;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨前公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String companyP;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨后公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String companyN;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调拨备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不用管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="资产转移">0.3. 资产转移</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String user;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String company;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用部门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String department;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String location;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移后使用工位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String partition;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移处理人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String handler;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转移备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不用管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="资产退库">0.4. 资产退库</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库存放地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String location;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 退库备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不用管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="资产维修">0.5. 资产维修</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String status;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报修日期</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate endTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报修原因</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String reason;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报修公司</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String company;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报修部门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String department;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报修人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String user;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String content;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修花费</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String pay;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维修备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不用管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="清理报废">0.6. 清理报废</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理单号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate startTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String user;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理原因</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String reason;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不用管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Integer assetId;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> AssetInfoDto assetInfoDto;<br></code></pre></td></tr></table></figure><h2 id="assetInfoDto">0.7. assetInfoDto</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产编码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String coding;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String status;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产类别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String type;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 入库日期</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate inTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String brand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 来源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String source;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 型号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String model;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计量单位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String measurement;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 渠道</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String channel;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 金额</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String price;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 购入时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate buyinTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用期限</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String useTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维保开始</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate repairStime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 维保结束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> LocalDate repairEtime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存放地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String location;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String photo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资产备注</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String remark;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>展示页面接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资金管理系统-小失误</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E6%B2%A1%E6%9C%89%E5%8A%A0%E6%9D%83%E9%99%90/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E6%B2%A1%E6%9C%89%E5%8A%A0%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h4 id="小失误">0.0.0.1. 小失误</h4><span id="more"></span><p>AssetUserController</p><p>CompanyController</p><p>DepartmentController</p>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小失误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资金管理系统-添加接口</title>
    <link href="/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E6%B7%BB%E5%8A%A0/"/>
    <url>/gzguo/2020/09/28/%E6%9A%91%E5%81%87%E9%A1%B9%E7%9B%AE/%E6%B7%BB%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="添加接口">0.0.0.1. 添加接口</h4><span id="more"></span><h2 id="使用">0.1. 使用</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">出库领用API<br><span class="hljs-regexp">/use/</span>add   增加<br><span class="hljs-regexp">/use/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/use/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUseForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 领用单号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 领用人id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer userId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资产</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调拨">0.2. 调拨</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">资产调拨API<br><span class="hljs-regexp">/borrow/</span>add   增加<br><span class="hljs-regexp">/borrow/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/borrow/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddBorrowForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调拨单号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调拨前公司</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer companyPid;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调拨后公司</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer companyNid;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资产id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="维修">0.3. 维修</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">资产维修API<br><span class="hljs-regexp">/repair/</span>add   增加<br><span class="hljs-regexp">/repair/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/repair/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddRepairForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修状态(0维修中，1维修完成)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修单号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String reason;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String content;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修花费</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String pay;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维修备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资产id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 报修部门</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer departmentId;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="报废">0.4. 报废</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">清理报废API<br><span class="hljs-regexp">/scrap/</span>add   增加<br><span class="hljs-regexp">/scrap/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/scrap/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddScrapForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 报废单号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 报废原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String reason;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 报废备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资产id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转移">0.5. 转移</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">资产转移API<br><span class="hljs-regexp">/transfer/</span>add   增加<br><span class="hljs-regexp">/transfer/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/transfer/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddTransferForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *转移编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转移后使用人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer userId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转移后使用地</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer locationId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转移的资产</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="退库">0.6. 退库</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">资产退库API<br><span class="hljs-regexp">/return/</span>add   增加<br><span class="hljs-regexp">/return/</span><span class="hljs-keyword">find</span>/simple   简单搜索<br><span class="hljs-regexp">/return/</span><span class="hljs-keyword">find</span><span class="hljs-regexp">/all/</span>by   高级搜索<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddReturnForm</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String coding;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存放地</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer locationId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 备注</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 资产id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer assetId;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资金管理系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>添加接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令系统</title>
    <link href="/gzguo/2020/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/gzguo/2020/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="指令系统">0.0.0.1. 指令系统</h4><span id="more"></span><h1 id="什么是指令系统">1. 什么是指令系统</h1><p>维基百科：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">指令系统是计算机硬件的语言系统，也叫机器语言，它是软件和硬件的主要界面，从系统结构的角度看，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力，也决定了指令的格式和机器的结构。对不同的计算机在设计指令系统时，应对指令格式、类型及操作功能给予应有的重视。<br></code></pre></td></tr></table></figure><p>百度百科：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">指令系统是计算机硬件的语言系统，也叫机器语言，指机器所具有的全部指令的集合，它是软件和硬件的主要界面，反映了计算机所拥有的基本功能。从系统结构的角度看，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力，也决定了指令的格式和机器的结构。设计指令系统就是要选择计算机系统中的一些基本操作<span class="hljs-comment">( 包括操作系统和高级语言中的)</span> 应由硬件实现还是由软件实现，选择某些复杂操作是由一条专用的指令实现, 还是由一串基本指令实现, 然后具体确定指令系统的指令格式、类型、操作以及对操作数的访问方式。<br></code></pre></td></tr></table></figure><p>Jarvis</p>]]></content>
    
    
    <categories>
      
      <category>计算机体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指令系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目微服务架构</title>
    <link href="/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E9%A1%B9%E7%9B%AE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E9%A1%B9%E7%9B%AE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="微服务架构">0.0.0.1. 微服务架构</h4><span id="more"></span><p>用户通过安卓或者PC向我们后台发送清求。请求先来到Nginx集群，Nginx将请求转交给后台服务（API网关），由网关动态路由到指定的服务</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker环境搭建</title>
    <link href="/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83-docker/"/>
    <url>/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83-docker/</url>
    
    <content type="html"><![CDATA[<h4 id="安装docker、启动、暂停">0.0.0.1. 安装docker、启动、暂停</h4><span id="more"></span><h1 id="环境搭建">1. 环境搭建</h1><h2 id="下载virtualBox（虚拟机）">1.1. 下载virtualBox（虚拟机）</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">windows</span> 的 virtualBox 只能通过右边的ctrl将鼠标移到windows<br></code></pre></td></tr></table></figure><h2 id="下载vagrant（镜像仓库）">1.2. 下载vagrant（镜像仓库）</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vagrant</span> init centos/<span class="hljs-number">7</span>   初始化centos镜像，之后会产生一个vagrantfile<br><span class="hljs-attribute">vagrant</span> up   启动我们的虚拟环境<br><span class="hljs-attribute">vagrant</span> ssh   以vagrant的身份登陆虚拟机<br></code></pre></td></tr></table></figure><h2 id="网络地址转换-端口转发">1.3. 网络地址转换-端口转发</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">虚拟机每装一个软件，就会到windows中映射一个虚拟端口。就好像指定windows的2000端口对应虚拟机的3306，使得虚拟机的mysql可以运行<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">端口转发太麻烦了，我们想要给虚拟机一个固定的<span class="hljs-built_in">ip</span>地址。使得windows和虚拟机可以相互ping通。这样的话，我们在虚拟机上下载一个软件直接访问虚拟机的端口就可以了<br></code></pre></td></tr></table></figure><h2 id="服务器安装docker">1.4. 服务器安装docker</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">docker是虚拟化容器技术，Docker基于镜像，可以秒级启动各种容器。每种容器都是一个完整的运行环境，容器之间互相隔离<br>防止了容器之间的相互影响，而且docker可以去镜像市场找各种镜像，然后基于镜像启动容器，每一个容器都是一个完整的运境<br></code></pre></td></tr></table></figure><h3 id="Docker官网安装CentOS的docker">1.4.1. Docker官网安装CentOS的docker</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/centos/</span><br></code></pre></td></tr></table></figure><h3 id="安装之前先卸载之前的docker">1.4.2. 安装之前先卸载之前的docker</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure><h3 id="然后设置Docker的地址，在设置之前需要安装一些必要的包">1.4.3. 然后设置Docker的地址，在设置之前需要安装一些必要的包</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></td></tr></table></figure><h3 id="告诉linux，docker在哪里装">1.4.4. 告诉linux，docker在哪里装</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">sudo yum-<span class="hljs-built_in">config</span>-manager \<br>    <span class="hljs-comment">--add-repo \</span><br>    https://download.docker.com/linux/centos/docker-ce.repo<br>测试：<br>sudo yum-<span class="hljs-built_in">config</span>-manager <span class="hljs-comment">--enable docker-ce-nightly</span><br>sudo yum-<span class="hljs-built_in">config</span>-manager <span class="hljs-comment">--enable docker-ce-test</span><br>sudo yum-<span class="hljs-built_in">config</span>-manager <span class="hljs-comment">--disable docker-ce-nightly</span><br></code></pre></td></tr></table></figure><h3 id="安装docker的引擎docker-ce，操作docker的客户端docker-ce-cli和容器containerd-io">1.4.5. 安装docker的引擎docker-ce，操作docker的客户端docker-ce-cli和容器containerd.io</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>安装完成</p><h2 id="启动Docker">1.5. 启动Docker</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">start</span> docker   启动<br>sudo systemctl <span class="hljs-keyword">enable</span> docker   设置开机自启<br>service docker <span class="hljs-keyword">restart</span>   重新启动<br></code></pre></td></tr></table></figure><h3 id="配置Docker镜像加速">1.5.1. 配置Docker镜像加速</h3><p>docker是从docker hub上下载镜像的，下载网站是国外的，可以配置国内的镜像加速</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-regexp">/etc/</span>docker<br>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://mhidjz1f.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="Docker的基本命令">1.5.2. Docker的基本命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker -v   查看docker版本<br>docker images   检查服务器上有没有下载来的镜像<br>docker pull mysql:<span class="hljs-number">5.7</span>   下载mysql的镜像<br>docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/conf:/</span>etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:<span class="hljs-number">5.7</span>   根据镜像，启动容器<br>docker ps   查看docker目前运行的容器<br>docker exec -it <span class="hljs-number">2009870</span>e21c3(mysql) <span class="hljs-regexp">/bin/</span>bash   最后的这个参数可以是容器的id或者是容器的名字(进入bash控制台),两个参数<br>docker rm -f 容器id   删除对应的容器实例<br></code></pre></td></tr></table></figure><h3 id="启动Docker容器的run命令">1.5.3. 启动Docker容器的run命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/conf:/</span>etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">run   每run一次我们就会启动一个容器，每个容器都是完整的运行环境<br><span class="hljs-deletion">-p 3306 3306   把容器内的3306端口映射到linux的3306端口，前面3306是linux的，后面3306是Docker的</span><br><span class="hljs-deletion">--name 给容器命名</span><br><span class="hljs-deletion">-v 目录挂载（前面的是linux下的真实目录，后面是docker容器里的mysql的配置对应的文件路径）</span><br>挂载的目的在于简化修改配置的操作，我们可以直接在真实的linux中改变容器里的mysql的配置，就好像是快捷方式一样<br><span class="hljs-deletion">-e 设置参数（调整密码）</span><br><span class="hljs-deletion">-d 以后台方式运行</span><br>:   相当于挂载（快捷方式）<br></code></pre></td></tr></table></figure><p>mysql容器就是一个完整的linux，进入docker的mysql内部可以看清楚</p><h3 id="重新启动docker容器">1.5.4. 重新启动docker容器</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">start</span> docker_container   启动容器<br>docker <span class="hljs-keyword">restart</span> docker_container   重启容器<br>docker logs container_name   查看容器日志<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装docker、启动、暂停</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-redis环境搭建</title>
    <link href="/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83-redis/"/>
    <url>/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83-redis/</url>
    
    <content type="html"><![CDATA[<h4 id="安装docker下的redis、启动、暂停">0.0.0.1. 安装docker下的redis、启动、暂停</h4><span id="more"></span><h2 id="下载redis镜像">0.1. 下载redis镜像</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> pull redis   下载redis最新镜像<br></code></pre></td></tr></table></figure><p>镜像都是从dockerhub中下载的</p><h2 id="启动镜像">0.2. 启动镜像</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">6379</span>:<span class="hljs-number">6378</span> --name redis -v <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/data:/</span>data -v <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf:<span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/redis.conf -d redis redis-server /</span>etc<span class="hljs-regexp">/redis/</span>redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-d redis redis-server <span class="hljs-regexp">/etc/</span>redis/redis.conf   redis启动的额外要求，以配置文件启动<br></code></pre></td></tr></table></figure><p>原先的镜像中没有配置文件，我们需要在服务器中创建好目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/mydata/</span>redis/conf<br>touch <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装docker下的redis、启动、暂停</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式基本概念</title>
    <link href="/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/gzguo/2020/09/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="分布式等基本概念">0.0.0.1. 分布式等基本概念</h4><span id="more"></span><h5 id="分布式">0.0.0.1.1. 分布式</h5><p>若干计算机的集合，组成一个相关的系统</p><hr><h5 id="微服务">0.0.0.1.2. 微服务</h5><p>将一个大的服务进行拆分，拆分成好多的微服务</p><hr><h5 id="集群">0.0.0.1.3. 集群</h5><p>一堆机器放在一起，实现统一的业务。分布式中的每一个节点都可以做成集群</p><hr><h5 id="远程调用">0.0.0.1.4. 远程调用</h5><p>在分布式系统中，各个服务可能处于不同的主机，服务之间进行调用，称之为远程调用</p><hr><h5 id="负载均衡">0.0.0.1.5. 负载均衡</h5><p>在远程调用的时候，不确定访问服务集群中的哪一台机器。负载均衡就是为了分配集群中的服务器任务量。从而提升网站的健壮性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">常见的负载均衡算法：<br>    轮询：给集群中的机器排序，然后依次访问<br>    最小连接：永远访问连接数最少的机器<br>    散列：根据ip散列（hash）。保证特定用户连接到相同的服务器<br></code></pre></td></tr></table></figure><hr><h5 id="服务注册-发现-注册中心">0.0.0.1.6. 服务注册/发现/注册中心</h5><p>每个服务开启的时候去注册中心注册，关闭的时候删除。这样的话，其他的服务想调用该服务，就可以去注册中心找注册信息。我们维护服务的开关就可以转化成维护注册中心</p><hr><h5 id="配置中心">0.0.0.1.7. 配置中心</h5><p>每个服务有大量的配置，每个服务有大量的机器，我们想更改配置的时候就很麻烦。所以我们用配置中心来集中管理微服务的配置中心</p><hr><h5 id="服务熔断-降级">0.0.0.1.8. 服务熔断/降级</h5><p>在微服务架构中，微服务之间通过网络进行通信，存在相互依赖。当一个服务没了，可能会全部崩掉。为了防止，必须有容错机制来保护服务</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">熔断：设置服务超时，被调用的服务失败次数达到某个阈值，就开启断路保护机制。后面进来的请求将不会再去调用这个服务。本地直接返回默认的数据（返回空/失败）<br>降级：在运维期间，系统处于高峰期，系统资源紧张，我们可以让非核心业务降级运行。某些服务不处理，或者简单处理（抛异常、返回<span class="hljs-literal">NULL</span>、调用Mock数据、调用Fallback处理逻辑）。<br></code></pre></td></tr></table></figure><hr><h5 id="API网关">0.0.0.1.9. API网关</h5><p>相当于前端访问后台时的拦截器、过滤器，相当于一个安检</p><hr>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1Web前端开发概述</title>
    <link href="/gzguo/2020/09/28/Web/1Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/1.1Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/"/>
    <url>/gzguo/2020/09/28/Web/1Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/1.1Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-1Web前端开发概述">0.0.0.1. 1.1Web前端开发概述</h4><span id="more"></span><h2 id="学习内容">0.1. 学习内容</h2><h3 id="Html标记">0.1.1. Html标记</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hyper</span> Text Markup   超文本标记语言。主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。最新版本是HTML<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="css样式">0.1.2. css样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Cascading Style Sheets   层叠样式表。是一种用来表现<span class="hljs-selector-tag">HTML</span>或者XML文件样式的计算机语言<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CSS</span>提供了丰富的样式，控制格式的、控制布局的、控制动态效果的等。最新版是<span class="hljs-number">2010</span>年推出的CSS<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">CSS3通过模块化结构使设计者可以及时的调整模块的内容，方便版本的更新与发布，同时也增添了很多的新功能<br></code></pre></td></tr></table></figure><h3 id="JavaScript的内置函数">0.1.3. JavaScript的内置函数</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1995</span><span class="hljs-string">年最初由Netscape（网景公司）的BrendanEich（瑞登·艾克）设计，后来Netscape为了营销考虑，与Sun微系统达成协议，将其改名为javascript</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">javascript是一种基于对象和事件驱动并具有相对安全性的客户端脚本语言。运用这个脚本语言可以给HEML网页添加动态功能，响应用户的各种操作<br></code></pre></td></tr></table></figure><h2 id="Web前端开发概述">0.2. Web前端开发概述</h2><h3 id="什么是Web？">0.2.1. 什么是Web？</h3><p>Web是Internet上最受欢迎的一种多媒体服务系统</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">整个系统由Web服务器、浏览器和通信协议组成<br></code></pre></td></tr></table></figure><h3 id="什么是Web开发？">0.2.2. 什么是Web开发？</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">包括：浏览器端页面的制作、服务器端程序的编写<br></code></pre></td></tr></table></figure><h3 id="Web前端开发">0.2.3. Web前端开发</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Web前端开发的主要工作是把UI(<span class="hljs-keyword">User</span> <span class="hljs-title">Interface</span>用户界面)的设计图按照W3C标准做成html页面，用CSS进行布局，并且用javascript脚本语言实现页面上的前端互动<br></code></pre></td></tr></table></figure><h3 id="浏览器">0.2.4. 浏览器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">浏览器是指可以显示网页服务器或者文件系统<span class="hljs-selector-tag">HTML</span>文件内容，并让用户与这些文件交互的一种软件<br></code></pre></td></tr></table></figure><h3 id="Html5">0.2.5. Html5</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Html5</span>是W<span class="hljs-number">3</span>C组织<span class="hljs-number">2014</span>年建议的标准，因此不是所有的浏览器都支持Html<span class="hljs-number">5</span>，同一浏览器对Html<span class="hljs-number">5</span>的支持情况也不同<br></code></pre></td></tr></table></figure><h3 id="Web标准">0.2.6. Web标准</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Web</span>标准是由W<span class="hljs-number">3</span>C和其他标准化组织指定的一系列标准的集合，该标准用来创建和解释基于Web的内容<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网页部分的标准通过三部分来描述：结构标准、表现标准、行为标准<br></code></pre></td></tr></table></figure><h4 id="结构标准">0.2.6.1. 结构标准</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用于对于网页元素进行整理和分类<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">相当于搭建房子的框架<br></code></pre></td></tr></table></figure><h4 id="表现标准">0.2.6.2. 表现标准</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用于设置网页元素的版式、颜色、大小等外观样式<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">相当于房子的装修，但是房子没有任何功能<br></code></pre></td></tr></table></figure><h4 id="行为标准">0.2.6.3. 行为标准</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">是对网页模型的定义以及交互的编写<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">相当于给房子增加了功能，让房子具有功能性，使用户和房子有更好的交互<br></code></pre></td></tr></table></figure><h4 id="标准的实现方式">0.2.6.4. 标准的实现方式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">上面三个标准分别对应<span class="hljs-selector-tag">HTML</span>、CSS、JavaScript（Web前端开发的基本应用技术）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1HTML5语法基础</title>
    <link href="/gzguo/2020/09/28/Web/2HTML5/2.1HTML5%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/gzguo/2020/09/28/Web/2HTML5/2.1HTML5%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1HTML5语法基础">0.0.0.1. 2.1HTML5语法基础</h4><span id="more"></span><h2 id="HTML文档结构">0.1. HTML文档结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">完整的<span class="hljs-selector-tag">HTML</span>文件包括头部和主体两大部分<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">文档结构由<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>这三大元素组成<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>   是文档类型声名：HTML5中用这一行代码进行说明，位于所有的文档标签之前，告知浏览器应按照什么方式对页面文档进行解析<br></code></pre></td></tr></table></figure><h3 id="html">0.1.1. html</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">所有的文档都是以<span class="hljs-selector-tag">html</span>标签开始和结束，所有的内容都需要放在<span class="hljs-selector-tag">html</span>标签之中<br></code></pre></td></tr></table></figure><h3 id="head">0.1.2. head</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-built_in">head</span>主要存放：标题、元信息、CSS样式、JavaScript脚本<br></code></pre></td></tr></table></figure><h3 id="body">0.1.3. body</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网页的正文，包括图片、表格、段落、音频、视屏等<br></code></pre></td></tr></table></figure><h2 id="HTML标签">0.2. HTML标签</h2><h3 id="h1">0.2.1. h1</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">标题标签一共有六种，是网页<span class="hljs-selector-tag">html</span>中对中文标题进行着重强调的标签。<br><span class="hljs-selector-tag">h1</span>-<span class="hljs-selector-tag">h6</span>依次显示重要性的递减<br></code></pre></td></tr></table></figure><h3 id="单标签">0.2.2. 单标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>   换行<br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>   横线<br></code></pre></td></tr></table></figure><h3 id="注释">0.2.3. 注释</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--********--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="meta">0.2.4. meta</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">meta标签主要分为两大类，一类对页面进行设置，另一类对搜索引擎进行设置。<br><br>对页面进行设置的格式：&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;名称&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;值&quot;</span>/&gt;<br>对搜索引擎进行设置的格式：&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;名称&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;值&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">http-equiv用法示例：<br><br>页面使用国标汉字码gb2312<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;text/html&quot;</span>;<span class="hljs-attr">Charset</span>=<span class="hljs-string">&quot;gb2312&quot;</span>/&gt;</span><br><br>页面停留20秒后跳转到www.educoder.net<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Refresh&quot;</span>  <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;20;Url=www.educoder.net&quot;</span>/&gt;</span> <br><br>网页于2020年7月26号8点过期<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">http-equiv</span> =<span class="hljs-string">“Expires”</span>  <span class="hljs-attr">Content</span>=<span class="hljs-string">“Thur,26</span> <span class="hljs-attr">Jul</span> <span class="hljs-attr">2020</span> <span class="hljs-attr">08:00:00</span> <span class="hljs-attr">GMT</span>”/&gt;</span> <br><br>设置cookie并进行页面缓存<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">http-equiv</span> =<span class="hljs-string">“Set-Cookie”</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">“cookievalue</span> = <span class="hljs-string">xxx;</span> <span class="hljs-attr">expires</span>= <span class="hljs-string">Thur,26</span> <span class="hljs-attr">Jul</span> <span class="hljs-attr">2020</span> <span class="hljs-attr">08:00:00</span> <span class="hljs-attr">GMT</span>; <span class="hljs-attr">path</span>=<span class="hljs-string">/”</span>&gt;</span> <br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">name用法示例：<br><br>用于标注网页的作者和Email<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">name</span> = <span class="hljs-string">“Author”</span>  <span class="hljs-attr">Content</span> = <span class="hljs-string">“刘明，Liuming@sina.com”</span> /&gt;</span> <br><br>为搜索引擎提供网站简介<br><span class="hljs-tag">&lt;<span class="hljs-name">Meta</span> <span class="hljs-attr">name</span> =<span class="hljs-string">“Description”</span>  <span class="hljs-attr">Content</span> =<span class="hljs-string">“网站简介”/</span>&gt;</span> <br><br>为搜索引擎提供关键字<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;漫步时尚广场,时尚,购物,影视,餐饮&quot;</span>/&gt;</span> <br><br>为搜索引擎提供编辑器类型<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generator&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Dreamweaver CS6&quot;</span>/&gt;</span> <br><br>为搜索引擎提供提供最新版本信息<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">“revised</span>&quot; <span class="hljs-attr">content</span>=<span class="hljs-string">“David,2020/8/8“/</span>&gt;</span> <br></code></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">charset<br>charset是HTML5新增的字符编码属性。属性取值必须是标准字符集的名称，常用的字符编码如下：<br><br>ISO<span class="hljs-string">-8859</span><span class="hljs-string">-1</span>：国际标准化组织针对不同的字母表/语言定义的标准字符集（ 拉丁字母表的字符编码），是浏览器默认的字符集<br>utf<span class="hljs-string">-8</span>：Unicode 联盟开发的标准，utf<span class="hljs-string">-8</span> 是网页和电子邮件的首选编码。<br>gb2312：信息交换用汉字编码字符集，中国国家标准总局1980年发布。适用于汉字处理、汉字通信等系统之间的信息交换。<br>用法示例：<br><br>设置utf<span class="hljs-string">-8</span>字符编码标准<br>&lt;meta charset=utf<span class="hljs-string">-8</span>/&gt; <br></code></pre></td></tr></table></figure><h2 id="HTML文档的编写规范">0.3. HTML文档的编写规范</h2><ol><li>所有的标签均以&lt;开始、以&gt;结束</li><li>根据标签的类型，正确输入标签，单个标签最好在右尖括号前面加一个/，如换行标签是单标签<br>，成对的标签最好同时输入起始标签和结束标签，以免忘记</li><li>标签可以嵌套使用名单时不能交叉使用</li><li>在HTML代码中不区分大小写</li><li>标签中可以设置各种属性，属性值建议用双引号标注起来</li><li>书写开始与结束标签时，在左尖括号与标签名或斜杠/之间不能留有多余的空格，否则浏览器对标签不能识别，导致错误标签直接显示在页面上，影响页面的美观效果</li></ol>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2HTML文档头部的标签</title>
    <link href="/gzguo/2020/09/28/Web/2HTML5/2.2HTML%E6%96%87%E6%A1%A3%E5%A4%B4%E9%83%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A0%87%E7%AD%BE/"/>
    <url>/gzguo/2020/09/28/Web/2HTML5/2.2HTML%E6%96%87%E6%A1%A3%E5%A4%B4%E9%83%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="2-2HTML文档头部的标签">0.0.0.1. 2.2HTML文档头部的标签</h4><span id="more"></span><h2 id="title">0.1. title</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">主要用于定义HTML页面的标题，即给网页取一个名字，必须位于<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>之内<br></code></pre></td></tr></table></figure><h3 id="title的作用：">0.1.1. title的作用：</h3><ul><li>在浏览器的标题栏中显示</li><li>可以用作默认的快捷方式或者收藏夹的名称</li><li>可以作为搜索引擎结果中的页面标题</li></ul><h3 id="应用时应注意">0.1.2. 应用时应注意</h3><ul><li>一个网页只能有一个标题</li><li>标题的长度不超过64个字符数</li><li>标题标记对之间不允许有其他的标签存在</li></ul><h2 id="meta">0.2. meta</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">用于定义页面的元信息，可重复出现在<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>头部标记中<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">详细信息在   HTML5语法标准中<br></code></pre></td></tr></table></figure><h2 id="link">0.3. link</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">用<span class="hljs-keyword">link</span>来引用外部的文件，一个页面允许使用多个<span class="hljs-keyword">link</span>标记引用多个外部文件<br></code></pre></td></tr></table></figure><h2 id="style">0.4. style</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">用于为HTML文档定义样式信息，位于<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>之中<br></code></pre></td></tr></table></figure><h2 id="script">0.5. script</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">用于在<span class="hljs-selector-tag">HTML</span>页面中加载脚本文件：如javascript<br></code></pre></td></tr></table></figure><h2 id="base">0.6. base</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">描述了基本的链接地址/链接目标，该标签作为<span class="hljs-selector-tag">HTML</span>文档中所有的链接标签的默认链接<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识数据结构</title>
    <link href="/gzguo/2019/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/gzguo/2019/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="数据结构预备知识">0.0.0.1. 数据结构预备知识</h4><span id="more"></span><p>先介绍几本书：</p><p>严蔚敏、吴伟民(伪算法)(清华)</p><p>高一凡(实现了上面这本书的所有伪算法)(西电)</p><p>黄国瑜(台湾人) 自己手写了一本数据结构</p><h2 id="数据结构概述">0.1. 数据结构概述</h2><h3 id="定义">0.1.1. 定义</h3><p>我们如何吧现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中，以及在此基础上为实现某个功能(比如查找某个元素，删除某个元素，对所有的元素进行排序)而执行的相应操作，这个相应操作也叫算法</p><p>数据结构 = 个体的存储方式 + 个体关系的存储方式</p><p>算法 = 对存储数据的操作</p><p>广义的讲数据结构包含算法</p><h3 id="算法">0.1.2. 算法</h3><p>算法 = 对存储数据的操作</p><p>广义算法：算法和存储关系没有关系</p><p>狭义算法：存储方式不一样，那么执行的操作就不一样</p><p>我们现在研究的是 狭义算法</p><p>算法：解题的方法和步骤</p><h3 id="衡量算法的标准">0.1.3. 衡量算法的标准</h3><p>时间复杂度：大概程序要执行的次数，而非执行时间 (执行的机器不一样，会影响时间，执行时间依赖硬件)</p><p>空间复杂度：算法执行过程中大概所占用的最大内存(消耗内存的多少)</p><p>难易程度：尽量容易理解</p><p>健壮性： 一个问题你可能并没有考虑全面<br>                这时你写了一个算法，健壮性强，就说明如果遇到你考虑之外的东西也能处理<br>                健壮性差就说明这个算法刚刚符合你自己考虑的 </p><h3 id="数据结构的地位">0.1.4. 数据结构的地位</h3><p>数据结构是软件中<u>最核心</u>的课程</p><p>程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p><h2 id="预备知识">0.2. 预备知识</h2><h3 id="指针">0.2.1. 指针</h3><p>指针的重要性：指针是c语言的灵魂</p><h4 id="定义-1">0.2.1.1. 定义</h4><p><strong>地址</strong>：内存单元的编号。(32位)从0开始的非负整数，范围0-FFFFFFFF(0-4G-1)(这里的G和硬盘的G意义相同)</p><p><strong>指针</strong>：指针就是地址，地址就是指针。</p><p>指针变量是存放内存单元地址的变量。</p><p>指针的本质：是一个操作受限的非负整数(不能加减乘除、只能在某些特殊情况下才能减)</p><p>指针的分类：1.基本类型的指针 2.指针和数组的关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">p是个指针变量名字，</span><br><span class="hljs-comment">int * 表示该p变量只能存储int类型变量的地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">int</span>* p; <br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> j;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">修改p的值不会改变i的值</span><br><span class="hljs-comment">修改i的值不会改变p的值</span><br><span class="hljs-comment">*p就是i变量</span><br><span class="hljs-comment">*/</span><br>p = &amp;i;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">*p没有指向任何东西的时候，</span><br><span class="hljs-comment">p里面很有可能会指向一个垃圾值</span><br><span class="hljs-comment">这个垃圾值很可能是某个变量的地址</span><br><span class="hljs-comment">*/</span><br>j = *p;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>,i, j);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>整个硬件是由操作系统控制。</p><p>程序向操作系统申请内存，所谓<strong>分配</strong>是指系统把内存分配给程序，操作系统吧这块内存的状态修改为已占用</p><p><strong>交还</strong>就是程序告诉操作系统不再需要这个内存空间了，操作系统吧这个内存空间的状态改为空闲</p><p>整个过程中没有对内存中的数据进行删除操作，所以所有的内存在使用之前大概率都会保存着垃圾数字。</p><p>操作系统不会清空内存中遗留下来的数字，只是修改了使用权限</p><p>如果在内存状态为已占用的情况下，这块内存又被访问的话，这个访问的东西就叫病毒</p><p>cpu只能直接访问内存，不能直接访问硬盘</p><p>逻辑上来讲，cpu和内存之间进行交互有三条总线进行调节：地址线（找位置、控制数据单元）、控制线（控制读写）、数据线（数据传输）</p><p>32位的电脑，内存最大为4G，因为地址线只能控制2的32次方个数据单元，内存再大没有任何意义</p><p>因为内存中的空间不会被清除，所以java中的局部变量必须初始化才能使用，Java中的属性不需要初始化就可以使用，因为他默认初始化了。不管怎么样，在使用之前必须初始化。</p><h4 id="注意事项">0.2.1.2. 注意事项</h4><ol><li>指针变量也是变量，只不过他存放的不能是内存单元的内容，只能存放内存单元的地址</li><li>普通变量前不能加*</li><li>常量和表达式前不能加&amp;</li></ol><p>形参也属于局部变量</p><p>指针变量统一的只占4个字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **q)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span>* p;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>p = &amp;i;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %p\n&quot;</span>, p);<br><br><span class="hljs-comment">//想要改变指针类型变量 p 的值</span><br><span class="hljs-comment">//要把p的地址传给函数</span><br><span class="hljs-comment">//然后才能通过函数来修改p变量的值</span><br><span class="hljs-built_in">f</span>(&amp;p);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %p\n&quot;</span>, p);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">一级指针变量：</span><br><span class="hljs-comment">可以用一级指针变量 来保存 变量的地址</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">一级指针变量的地址是 &amp;p</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">p是一级指针变量的名字</span><br><span class="hljs-comment">*p 就是p指向的内存</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">二级指针变量：</span><br><span class="hljs-comment">用一个二级指针变量 来保存 一级指针变量的地址</span><br><span class="hljs-comment">相当于int ** q = &amp;p;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">q 是 二级指针变量的名字</span><br><span class="hljs-comment">*q 是 一级指针的地址（*q就是指向的一级指针）</span><br><span class="hljs-comment">**q 是 一级指针的地址中存放的地址 （**q就是*p）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">一定要记得q是个变量名，是个二级指针类型的变量名</span><br><span class="hljs-comment">他本身存放着的是一级指针的地址</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">总而言之</span><br><span class="hljs-comment">变量就是变量，什么时候都可以取地址</span><br><span class="hljs-comment">如果是指针类型的变量，加一颗星就是他指向的那个变量，再加星就是他指向的那个变量指向的变量</span><br><span class="hljs-comment">知道没有星可以加为止</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **q)</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----------------------f()开始执行----------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;**q = %d\n&quot;</span>, **q);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*q = %p\n&quot;</span>, *q);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;q = %p\n&quot;</span>, q);<br><br>*q = (<span class="hljs-keyword">int</span>*)<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----------------------q改变了p的地址----------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*q = %p\n&quot;</span>,*q);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----------------------f()执行完毕----------------------\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">p = 0133F774</span><br><span class="hljs-comment">-----------------------f()开始执行----------------------</span><br><span class="hljs-comment">**q = 10</span><br><span class="hljs-comment">*q = 0133F774</span><br><span class="hljs-comment">q = 0133F780</span><br><span class="hljs-comment">-----------------------q改变了p的地址----------------------</span><br><span class="hljs-comment">*q = 00000001</span><br><span class="hljs-comment">-----------------------f()执行完毕----------------------</span><br><span class="hljs-comment">p = 00000001</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="结构体">0.2.2. 结构体</h3><h4 id="为什么会出现结构体">0.2.2.1. 为什么会出现结构体</h4><p>为了表示一些复杂的数据，而普通的基本类型变量无法满足要求</p><h4 id="什么叫结构体">0.2.2.2. 什么叫结构体</h4><p>结构体是用户根据自己的需要自己定义的复合<strong>数据类型</strong></p><h4 id="如何使用结构体">0.2.2.3. 如何使用结构体</h4><p>两种方式：</p><p>第一种方式：st.sid 结构体变量名</p><p>第二种方式：</p><p>pst-&gt;sid 指针（这句话的意思是：pst所指向的结构体变量中的sid这个成员）</p><p>推荐使用第二种方式，因为第二种方式省时间，省内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//结构体是数据类型</span><br><span class="hljs-comment">//结构体不是变量</span><br><span class="hljs-comment">//定义结构体不会分配内存空间，只是一个模板</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br><span class="hljs-keyword">int</span> sid; <span class="hljs-comment">//成员 在java中叫属性</span><br><span class="hljs-keyword">char</span> name[<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> age;<br>&#125;; <span class="hljs-comment">//分号不能省略</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">st</span> =</span> &#123;<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;sna&quot;</span>,<span class="hljs-number">20</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sid = %d\nname = %s\nage = %d\n&quot;</span>, st.sid, st.name, st.age);<br>st.sid = <span class="hljs-number">99</span>;<br><span class="hljs-comment">//st.name = &quot;lisi&quot;; //error</span><br><span class="hljs-built_in">strcpy_s</span>(st.name, <span class="hljs-string">&quot;lisi&quot;</span>);<br>st.age = <span class="hljs-number">22</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sid = %d\nname = %s\nage = %d\n&quot;</span>, st.sid, st.name, st.age);<br><br><span class="hljs-comment">//上面是实现赋值的第一种方式</span><br><span class="hljs-comment">//下面通过结构体指针来实现更改结构体内存的功能</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>* <span class="hljs-title">pst</span>;</span> <span class="hljs-comment">//这个指针占4个字节 </span><br><span class="hljs-comment">//因为我们的地址总线是32位的，可以控制2的32次方</span><br><span class="hljs-comment">//所以内存大小是4G</span><br><span class="hljs-comment">//每个内存由32个位组成，32个位就是4个字节</span><br><span class="hljs-comment">//所以一个指针占4个字节</span><br><br>pst = &amp;st;<br>pst-&gt;sid = <span class="hljs-number">999</span>; <span class="hljs-comment">//这里的pst-&gt;sid等价于(*pst).sid</span><br><span class="hljs-comment">//(*pst).sid等价于st.sid，所以pst-&gt;sid等价于st.sid</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sid = %d\nname = %s\nage = %d\n&quot;</span>, st.sid, st.name, st.age);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意事项-1">0.2.2.4. 注意事项</h4><ol><li><p>结构体变量不能加减乘除但<strong>可以相互赋值</strong></p></li><li><p>普通结构体变量和结构体指针变量作为函数传参的问题（感受指针的方便之处，可以在传参时节省内存空间，提升程序的运行效率，减少了运行时间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br><span class="hljs-keyword">int</span> sid;<br><span class="hljs-keyword">char</span> name[<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> age;<br>&#125;; <span class="hljs-comment">//分号不能省略</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(struct Student * pst)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(struct Student st)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">st</span>;</span> <span class="hljs-comment">//分配了空间，但是存储的是垃圾值</span><br><span class="hljs-comment">//现在我要通过f()函数来修改他里面的值</span><br><span class="hljs-comment">//只用了4个字节的空间</span><br><span class="hljs-built_in">f</span>(&amp;st);<br><br><span class="hljs-comment">//通过g()函数来输出st中的值</span><br>    <span class="hljs-comment">//把整个st传过去，传了至少208个字节</span><br>    <span class="hljs-comment">//损耗内存，损耗时间，不推荐</span><br><span class="hljs-built_in">g</span>(st);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(struct Student* pst)</span> </span>&#123;<br>(*pst).sid = <span class="hljs-number">2000</span>;<br><span class="hljs-built_in">strcpy_s</span>((*pst).name,<span class="hljs-string">&quot;xiaohong&quot;</span>);<br>(*pst).age = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(struct Student st)</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sid = %d\nname = %s\nage = %d\n&quot;</span>, st.sid, st.name, st.age);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="动态内存的分配和释放">0.2.3. 动态内存的分配和释放</h3><p>malloc函数分配内存</p><p>free函数释放内存</p><p>必须通过free释放，如果没有free的话，<em>即使函数已经终止了，这个内存也不会释放</em>，直到这个<strong>程序终止</strong>的时候，这个内存才有可能会被释放</p><p>但是也不一定，可能会出现内存泄漏的问题。这也是我们的系统越用越慢的原因，内存会变得越来越少</p><p>为什么说java很安全？</p><p>在java里面不需要自己malloc和自己free，java有一个java虚拟机会自动进行回收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//这个数组是一个静态数组</span><br><span class="hljs-comment">//只要写了5，就不能再发生改变</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span> &#125;;<br><br><span class="hljs-keyword">int</span> len;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入您所需要分配的数组的长度：len = &quot;</span>);<br><span class="hljs-built_in">scanf_s</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;len);<br><span class="hljs-comment">//sizeof() 可以帮助我们返回某个类型所占用的字节数</span><br><span class="hljs-comment">//sizeof(int) * len 这个的意思是为分配多少个int类型的空间</span><br><span class="hljs-comment">//如果len是5，那么sizeof(int) * len等于20</span><br><span class="hljs-comment">//malloc()，我们的这个函数可以请求我们的操作系统，为我们的程序分配20个内存空间</span><br><span class="hljs-comment">//要有20个字节，这么大的空间的读写权限给我，让我可以直接对他进行处理</span><br><span class="hljs-comment">//为什么要强制转换？</span><br><span class="hljs-comment">//因为我们的malloc()只能返回第一个字节的地址</span><br><span class="hljs-comment">//我们把返回的地址叫做干地址，无意义的地址</span><br><span class="hljs-comment">//所以我们要强转来告诉我们编译器，我们返回的第一个地址是int还是double</span><br><span class="hljs-keyword">int</span>* pArr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * len);<br>*pArr = <span class="hljs-number">4</span>; <span class="hljs-comment">//相当于a[0] = 4</span><br>pArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">//类似于a[1] = 100</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pArr[%d] = %d\n&quot;</span>,i,pArr[i]);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(pArr + %d) = %d\n&quot;</span>,i,*(pArr + i));<br>&#125;<br><br><span class="hljs-comment">//下面的代码，可以把pArr所代表的动态分配的20个字节的内存释放</span><br><span class="hljs-built_in">free</span>(pArr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memory-内存、记忆-跨函数使用内存">0.2.4. memory(内存、记忆) 跨函数使用内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我想要跨函数来使用内存</span><br><span class="hljs-comment">什么意思呢？</span><br><span class="hljs-comment">就是说我要通过一个函数来将一个指针指向确定的内存空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **q)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span>* p;<br><span class="hljs-comment">//我们想要通过f()改变p的值，必须传p的地址</span><br><span class="hljs-built_in">f</span>(&amp;p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ** q)</span> </span>&#123;<br><span class="hljs-comment">//在这里，我们必须使用malloc</span><br><span class="hljs-comment">//如果使用int s ;的话，在f()函数执行结束之后，我们s的内存就会被释放掉了</span><br><span class="hljs-comment">//不能满足我们的要求，不能指向确定的内存空间</span><br><span class="hljs-comment">//但是如果我们用malloc的话，malloc出来的内存空间不会因为函数f()执行完成而被释放</span><br><span class="hljs-comment">//malloc出来的空间只有遇到free()或者说是程序终止的时候才会被释放</span><br><span class="hljs-comment">//所以我们指向malloc出来的空间，不要free的话，就相当于指向了一个确定的内存空间</span><br>*q = (<span class="hljs-keyword">int</span>*)(<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们的java代码中，很多地方都是跨函数使用内存的，<strong>通过函数来让一个变量指向确定的内存</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br></code></pre></td></tr></table></figure><p>就相当于c++中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//A是类型 是结构体？</span><br>A *pa = (A*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A));<br></code></pre></td></tr></table></figure><p>更深层次的理解一下，通过函数来使用内存(跨函数使用内存)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> sid;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br><span class="hljs-function">struct Student* <span class="hljs-title">CreateStudent</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowStudent</span><span class="hljs-params">(struct Student * q)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//ps占四个字节</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>* <span class="hljs-title">ps</span>;</span><br><br><span class="hljs-comment">//st占八个字节</span><br><span class="hljs-comment">//printf(&quot;%d&quot;,sizeof(Student));</span><br><span class="hljs-comment">//上面这个东西的输出结果是 8</span><br><span class="hljs-comment">//struct Student st;</span><br><br><span class="hljs-comment">//跨函数使用内存</span><br>ps = <span class="hljs-built_in">CreateStudent</span>();<br><span class="hljs-built_in">ShowStudent</span>(ps);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">struct Student* <span class="hljs-title">CreateStudent</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>* <span class="hljs-title">pst</span> =</span> (struct Student*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct Student));<br>pst-&gt;sid = <span class="hljs-number">100</span>;<br>pst-&gt;age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> pst;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowStudent</span><span class="hljs-params">(struct Student* q)</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sid = %d\nage = %d\n&quot;</span>, q-&gt;sid, q-&gt;age);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_regular_start</title>
    <link href="/gzguo/2019/09/07/java/regular/start/"/>
    <url>/gzguo/2019/09/07/java/regular/start/</url>
    
    <content type="html"><![CDATA[<h4 id="特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫">0.0.0.1. 特殊字符、量词、零宽、匹配模式、分组、预搜索、java中的使用、网络爬虫</h4><span id="more"></span><p><strong>regular Expression</strong></p><h1 id="正则表达式的基本知识">1. 正则表达式的基本知识</h1><h2 id="基本语法">1.1. 基本语法</h2><p><em>为什么需要正则表达式</em>？文本的复杂处理</p><p><em>正则表达式的优势和用途</em>：1.一种强大的文本处理工具 2.大部分编程语言、数据库、文本编译器、开发环境都支持正则表达式</p><p><em>正则表达式的定义</em>：1.正如他的名字一样描述了一个规则，通过这个规则可以匹配一类字符串 2.学习正则表达式很大程度上就是学习正则表达式的语法规则</p><p>开发中使用正则表达式：</p><ul><li>分析所要匹配的数据，写出测试用的典型数据</li><li>在工具软件中进行匹配测试</li><li>在程；序调用通过测试的正则表达式</li></ul><p>正则表达式语法：</p><p>**1.**普通字符：字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符</p><p>**2.**简单的转义字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">\n 换行符<br>\t 制表符<br>\\ \本身<br>\^,\$,\.,\(, \),\&#123;, \&#125;,\?,\+,\*,\|,\[, \] 匹配这些字符本身<br></code></pre></td></tr></table></figure><p>**3.**标准字符集合：</p><p>1&gt;能够与“多种字符”匹配的表达式</p><p>2&gt;注意区分大小写，大写是相反的意思</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\d</span> 任意一个数字，0-9中任意一个<br><span class="hljs-symbol">\w</span> 任意一个字母或数字或下划线，也就是A-Z、a-z、0-9，_ 中任意一个<br><span class="hljs-symbol">\s</span> 包括空格、制表符、换行符等空白符的其中任意一个<br>. 小数点可以匹配任意一个字符(除了换行符)，如果要匹配“<span class="hljs-symbol">\n</span>”在内的所有字符，一般用[<span class="hljs-symbol">\s</span><span class="hljs-symbol">\S</span>]<br></code></pre></td></tr></table></figure><p>**4.**自定义字符集合：</p><p>[]方括号匹配方式，能够匹配方括号中任意一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[ab5@] 匹配“a”或“b”或“<span class="hljs-number">5</span>”或“@”<br>[^abc] 匹配“a”，“b”，“c”之外的任意一个字符<br>[f-k]  匹配“f”~“k”之间的任意一个字母<br>[^A-F0-<span class="hljs-number">3</span>] 匹配“A~F”，“<span class="hljs-number">0</span>~<span class="hljs-number">3</span>”之外的任意一个字符<br></code></pre></td></tr></table></figure><p>1&gt;正则表达式的特殊符号，被包含到了中括号中，则失去了意义，除了^ - 之外</p><p>2&gt;标准字符集合，除小数点外(小数点在中括号内只表示小数点，没有特殊含义)，如果被包含于中括号，自定义字符集合将包含该集合。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[\d.\-+] 将匹配：数字、小数点、+、-<br></code></pre></td></tr></table></figure><h3 id="量词">1.1.1. 量词</h3><p>量词：修饰匹配次数的特殊符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">贪婪模式：<br>&#123;n&#125; 表达式重复n次<br>&#123;m,n&#125; 表达式至少重复m次，最多重复n次<br>&#123;m,&#125; 表达式至少重复m次<br>? 匹配表达式<span class="hljs-number">0</span>次或者<span class="hljs-number">1</span>次，相当于&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;<br>+ 表达式至少出现<span class="hljs-number">1</span>次，相当于&#123;<span class="hljs-number">1</span>,&#125;<br>* 表达式不出现或出现任意次，相当于&#123;<span class="hljs-number">0</span>,&#125;<br><br>非贪婪模式：<br>&#123;n&#125;? 表达式重复n次<br>&#123;m,n&#125;? 表达式至少重复m次，最多重复n次<br>&#123;m,&#125;? 表达式至少重复m次<br></code></pre></td></tr></table></figure><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认！)</li><li>匹配次数中的非贪婪模式(匹配的字符越少越好，修饰匹配次数的特殊符号后再加上一个“？”号)</li></ul><h3 id="字符边界-零宽">1.1.2. 字符边界(零宽)</h3><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">^ 与字符串开始的地方匹配<br>$ 与字符串结束的地方匹配<br>\b 匹配一个单词边界<br><span class="hljs-comment">// \b匹配这样一个位置：前面的字符和后面的字符不全是\w</span><br></code></pre></td></tr></table></figure><h3 id="正则表达式的匹配模式">1.1.3. 正则表达式的匹配模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">IGNORECASE(ignorecase) 忽略大小写模式<br> <span class="hljs-number">1</span>&gt;匹配时忽略大小写<br> <span class="hljs-number">2</span>&gt;默认情况下，正则表达式是要区分大小写的<br>SINGLELINE(singleline) 单行模式<br> <span class="hljs-number">1</span>&gt;整个文本看作一个字符串，只有一个开头，一个结尾<br> <span class="hljs-number">2</span>&gt;使小数点“.”可以匹配包含换行符(\n)在内的任意字符<br>MULTILINE(multiline) 多行模式<br> <span class="hljs-number">1</span>&gt;每行都是一个字符串，都有开头和结尾<br> <span class="hljs-number">2</span>&gt;在指定MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z<br></code></pre></td></tr></table></figure><h3 id="选择符和分组">1.1.4. 选择符和分组</h3><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>| 分支结构</td><td>左右两边表达式之间“或”关系，匹配左边或者右边</td></tr><tr><td>() 捕获组</td><td>1&gt;在被修饰次数的时候，括号内的表达式可以作为整体被修饰   2&gt;取消匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到   3&gt;每一对括号会分配一个编号，使用()的捕捉根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression) 非捕获组</td><td>一些表达式中，不得不使用()，但又不需要保存()中的子表达式匹配的内容，这时可以用非捕获来抵消()带来的副作用</td></tr></tbody></table><h4 id="反向引用-nnn">1.1.4.1. 反向引用(\nnn)</h4><ol><li>每一对()会分配一个编号，使用()的捕捉<strong>根据左括号的顺序</strong>从1开始自动编号</li><li>通过反向引用，可以对分组已捕获的字符串进行引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">([a-z]&#123;<span class="hljs-number">2</span>&#125;)\<span class="hljs-number">1</span> 匹配gogo 、 toto 这类型的前两个字母是小写并且后两个字母和前两个字母相同<br>(?:[a-z]&#123;<span class="hljs-number">2</span>&#125;) 只利用括号的形式，没有存储捕获的内容。后面写\<span class="hljs-number">1</span>也失去了意义<br></code></pre></td></tr></table></figure><h2 id="高级语法">1.2. 高级语法</h2><h3 id="预搜索-零宽断言">1.2.1. 预搜索(零宽断言)</h3><p>预搜索(零宽断言)：也叫<strong>环视</strong></p><ul><li>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</li><li>这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定条件，但不匹配前后字符。是对位置的匹配</li><li>正则表达式匹配的过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">(?=exp) 断言自身出现的位置的后面能匹配表达式exp<br>(?&lt;=exp) 断言自身出现的位置的前面能匹配表达式exp<br>(?!exp) 断言此位置的后面不能匹配表达式exp<br>(?&lt;!exp) 断言此位置的前面不能匹配表达式exp<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[a-z]+(?=ing) 匹配以ing结尾的小写单词 例如：going、eating、doing，但是ing本身不会被匹配<br>[a-z]+(?=\d+) 匹配以数字结尾的单词，数字本身不计入匹配结果<br>+ ：至少出现一次<br></code></pre></td></tr></table></figure><h2 id="练习">1.3. 练习</h2><h3 id="电话号码">1.3.1. 电话号码</h3><p>电话号码验证：</p><ul><li>电话号码由数字和“-”构成</li><li>电话号码为7到8位</li><li>如果电话号码中包含有区号，那么区号为三位或四位，首位是0</li><li>区号用“-”和其他部分隔开</li><li>移动电话号码为11位</li><li>11位移动电话号码的第一位和第二位为“13”，“15”，“18”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-number">0</span>\d&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;-\d&#123;<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;)|(<span class="hljs-number">1</span>[<span class="hljs-number">35789</span>]\d&#123;<span class="hljs-number">9</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="电子邮箱">1.3.2. 电子邮箱</h3><p>电子邮箱地址验证：</p><ul><li>用户名：字母、数字、中划线、下划线组成</li><li>@</li><li>网址：字母、数字组成</li><li>组织域名：2-4位字母组成</li><li>不区分大小写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[\w\-]+@[a-z0-9A-Z]+(\.[A-Za-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;)&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br>\- 代表中划线<br></code></pre></td></tr></table></figure><h2 id="使用正则">1.4. 使用正则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">匹配中文字符：[\u4e00-\u9fa5]<br>匹配空白行：\n\s*\r<br>匹配HTML标记：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;^<span class="hljs-number">1</span>&gt;|&lt;.*?/&gt;<br>匹配首尾空白字符串：^\s*|\s*$<br>匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*<br>匹配网址URL：[a-zA-Z]+:<span class="hljs-comment">//[^\s]*</span><br>匹配国内电话号码：\d&#123;<span class="hljs-number">3</span>&#125;-\d&#123;<span class="hljs-number">8</span>&#125;|\d&#123;<span class="hljs-number">4</span>&#125;-\d&#123;<span class="hljs-number">7</span>&#125;<br>匹配腾讯QQ号：[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">4</span>,&#125;<br>匹配中国邮政编码：[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">5</span>&#125;(?!\d)<br>匹配身份证：\d&#123;<span class="hljs-number">15</span>&#125;|\d&#123;<span class="hljs-number">18</span>&#125;<br>匹配ip地址：\d+\.\d+\.\d+\.\d+<br></code></pre></td></tr></table></figure><h3 id="java中使用正则">1.4.1. java中使用正则</h3><ul><li>相关的类位于：java.util.regex包下面</li><li>类Pattern：1.正则表达式的编译表示形式 2.Pattern p = Pattern.compile(r,int); //建立正则表达式，并启用相应模式</li><li>类Matcher：1.通过解释Pattern对character sequence执行匹配操作的引擎 2.MAtcher m = p.matcher(str); //匹配str字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span><br>        <br>        <span class="hljs-comment">//表达式对象</span><br>        Pattern p = Pattern.compile(<span class="hljs-string">&quot;\\w+&quot;</span>); <span class="hljs-comment">//正则表达式中的\在java中变\\</span><br>        <br>        <span class="hljs-comment">//创建Matcher对象(匹配对象)</span><br>        Matcher m = p.matcher(<span class="hljs-string">&quot;asfsdf23323&quot;</span>);<br>        <br>        <span class="hljs-comment">//匹配一下，返回结果是boolean</span><br>        <span class="hljs-comment">//尝试将整个字符序列与该模式匹配</span><br>        <span class="hljs-keyword">boolean</span> yesorno = m.matches();<br>        <br>        <span class="hljs-comment">//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span><br>        <span class="hljs-comment">//boolean a = m.find();</span><br>        <span class="hljs-comment">//System.out.println(a); true //m.group() 把匹配到的内容返回</span><br>        <span class="hljs-comment">//System.out.println(a); true</span><br>        <span class="hljs-comment">//System.out.println(a); false</span><br>        <span class="hljs-comment">//System.out.println(a); false</span><br>        <span class="hljs-comment">//group()和group(0)匹配整个表达式的子字符串</span><br>        System.out.println(yesorno); <span class="hljs-comment">//true</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//find和group操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestGroup</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Pattern p = Pattern.compile(<span class="hljs-string">&quot;([a-z]+)([0-9]+)&quot;</span>);<br>        Matcher m = p.matcher(<span class="hljs-string">&quot;aa232**ssd445*sds223&quot;</span>);<br>        <span class="hljs-keyword">while</span>(m.find())&#123;<br>            System.out.println(m.group()); <span class="hljs-comment">//group(0)和group()一样</span><br>            System.out.println(m.group(<span class="hljs-number">1</span>)); <span class="hljs-comment">//第一个()中查到的内容</span><br>            System.out.println(m.group(<span class="hljs-number">2</span>));<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 输出结果：</span><br><span class="hljs-comment">             * aa232</span><br><span class="hljs-comment">             * aa</span><br><span class="hljs-comment">             * 232</span><br><span class="hljs-comment">             * ssd445</span><br><span class="hljs-comment">             * ss</span><br><span class="hljs-comment">             * 445</span><br><span class="hljs-comment">             * sds223</span><br><span class="hljs-comment">             * sds</span><br><span class="hljs-comment">             * 223</span><br><span class="hljs-comment">             */</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReplace</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Pattern p = Pattern.compile(<span class="hljs-string">&quot;[0-9]&quot;</span>);<br>        Matcher m = p.matcher(<span class="hljs-string">&quot;aa223**ss445*sds223&quot;</span>);<br>        <br>        <span class="hljs-comment">//替换</span><br>        String newStr = m.replaceAll(<span class="hljs-string">&quot;#&quot;</span>);<br>        System.out.println(newStr);<br>        <span class="hljs-comment">//输出结果：aa###**ss###*sds###</span><br>        <span class="hljs-comment">//并不会改变原有的字符串，newStr是新生成的字符串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分割</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSplit</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String str = <span class="hljs-string">&quot;aa223**ss445*sds223&quot;</span>;<br>        Pattern p = Pattern.compile(<span class="hljs-string">&quot;[0-9]&quot;</span>);<br>        Matcher m = p.matcher(str);<br>        <br>        <span class="hljs-comment">//分割</span><br>        String[] arrs = str.split(<span class="hljs-string">&quot;\\d+&quot;</span>);<br>        System.out.println(Arrays.toString(arrs));<br>        <span class="hljs-comment">//输出结果：[aa, **ss, *sds]</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="java复杂文本操作">2. java复杂文本操作</h1><h2 id="网络爬虫">2.1. 网络爬虫</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//网络爬虫取链接</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSpiderCore</span></span>&#123;<br>    <br>    <span class="hljs-comment">//获得url对应的网页的源码内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getURLContent</span><span class="hljs-params">(String URL)</span></span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            Url url = <span class="hljs-keyword">new</span> Url(URL);<br>            BufferedReader reader = <br>                <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader<br>                                   (url.openStream(),Charset.forName(<span class="hljs-string">&quot;gbk&quot;</span>)));<br>            String temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span>(temp = reader.readLine() != <span class="hljs-keyword">null</span>)&#123;<br>                sb.append(temp);<br>            &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (MalformedURLException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String destStr = getURLContent(<span class="hljs-string">&quot;http://www.163.com&quot;</span>);<br>        <br>        <span class="hljs-comment">//记得\变\\</span><br>        <span class="hljs-comment">//取到超链接中的所有内容</span><br>        <span class="hljs-comment">//Partten p = Partten.compile(&quot;&lt;a[\\s\\S]+?&lt;/a&gt;&quot;);</span><br>        <br>        <span class="hljs-comment">//取到超链接的地址</span><br>        <span class="hljs-comment">//Partten p = Partten.compile(&quot;href=\&quot;.+?\&quot;&quot;);</span><br>        <br>        <span class="hljs-comment">//只取超链接</span><br>        <span class="hljs-comment">//分组、预搜索(零宽断言)</span><br>        Partten p = Partten.compile(<span class="hljs-string">&quot;href=\&quot;(.+?)\&quot;&quot;</span>);<br>        <span class="hljs-comment">//String str = &quot;href=\&quot;([\\w\\s./:]+?)\&quot;&quot;;</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * ?简介：</span><br><span class="hljs-comment">         * 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，</span><br><span class="hljs-comment">         * 匹配模式是非贪婪的。</span><br><span class="hljs-comment">         * 非贪婪模式尽可能少的匹配所搜索的字符串，</span><br><span class="hljs-comment">         * 而默认的贪婪模式则尽可能多的匹配所搜索的字符串。</span><br><span class="hljs-comment">         * 例如，对于字符串 &quot;oooo&quot;，&#x27;o+?&#x27; 将匹配单个 &quot;o&quot;，而 &#x27;o+&#x27; 将匹配所有 &#x27;o&#x27;。</span><br><span class="hljs-comment">         */</span><br>        Matcher m = p.matcher(deseStr);<br>        <br>        <span class="hljs-keyword">while</span>(m.find())&#123;<br>            <span class="hljs-comment">//取到超链接的地址</span><br>            System.out.println(m.group());<br>            <br>            <span class="hljs-comment">//只取超链接</span><br>            System.out.println(m.group(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>regular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_network_start</title>
    <link href="/gzguo/2019/09/05/java/network/start/"/>
    <url>/gzguo/2019/09/05/java/network/start/</url>
    
    <content type="html"><![CDATA[<h4 id="java-network-start">0.0.0.1. java_network_start</h4><span id="more"></span><h4 id="网络编程和网页编程：">0.0.0.2. 网络编程和网页编程：</h4><p>网络编程关注的是底层数据的传输</p><p>网页编程关注的是与客户的交互</p><h4 id="什么是计算机网络？">0.0.0.3. 什么是计算机网络？</h4><ul><li>把分布在不同地理区域的计算机与专门的外部设备通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便的互相传递信息，共享硬件、软件、数据信息等资源</li><li>计算机网络的主要功能：1.资源共享 2.信息传输与集中处理 3.均衡负荷与分布处理 4.综合信息服务</li><li>什么是网络通信协议：计算机网络中实现通信必须有的一些约定即通信协议。对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准</li><li>网络通信接口：为了使两个节点之间能进行对话，必须在他们之间建立通信工具(即接口)，使彼此之间能进行信息交换。接口包括两部分：1.硬件装置：实现节点之间的信息传送 2.软件装置：规定双方进行通信的约定协议</li></ul><h4 id="什么是计算机网络？-自己的理解">0.0.0.4. 什么是计算机网络？(自己的理解)</h4><p>网络：将不同地区的计算机联系到一起，局域网、城域网、互联网</p><h4 id="在网络上如何查找计算机？">0.0.0.5. 在网络上如何查找计算机？</h4><p>我们有很多的计算机，每一台计算机都有自己的地址</p><p>地址：ip地址，确定互联网的计算机的绝对地址。相当于房子的地址</p><h4 id="端口号">0.0.0.6. 端口号</h4><p>一个计算机上的不同的软件之间的区分：端口号</p><p>端口号是计算机虚拟的，保证每个软件的不同，相当于我们的房门 （0-65535：一共65536个）</p><h4 id="端口号的注意事项">0.0.0.7. 端口号的注意事项</h4><p>在同一个协议下，端口号不能重复。但是在不同的协议下可以重复</p><p>1024以下的不要使用，给我们的操作系统预留。（80给http，21给ftp）</p><h4 id="数据的传输">0.0.0.8. 数据的传输</h4><h5 id="1-协议：TCP和UDP协议">0.0.0.8.1. 1.协议：TCP和UDP协议</h5><p>1&gt;TCP：电话 类似于三次握手 面向连接 安全可靠 效率低下</p><p>2&gt;UDP：短信 非面向连接 效率高</p><h5 id="2-传输">0.0.0.8.2. 2.传输</h5><p>1&gt;先封装</p><p>2&gt;后拆装</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>database</title>
    <link href="/gzguo/2019/09/02/database/start/"/>
    <url>/gzguo/2019/09/02/database/start/</url>
    
    <content type="html"><![CDATA[<h4 id="database">0.0.0.1. database</h4><span id="more"></span><p>根据数据库模型的发展，可以划分为三个阶段：</p><p>第一代：网状、层次数据库系统</p><p>第二代：关系型数据库</p><p>第三代：面向对象模型为主要特征的数据库系统</p><p>数据库：</p><p>IBM ：IMS(层次数据库，早期)   SQL/Ds(关系型数据库，后来)   DB2(关系型数据库，再后来)   </p><p>Oracle ：Oracle数据库(世界上流行的关系型数据库)</p><p>微软 ：SQL Server(关系型数据库)</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_io_start</title>
    <link href="/gzguo/2019/09/02/java/io/start/"/>
    <url>/gzguo/2019/09/02/java/io/start/</url>
    
    <content type="html"><![CDATA[<h4 id="java-io-start">0.0.0.1. java_io_start</h4><span id="more"></span><p>我们的程序和硬盘中的文件需要建立联系，建立联系的东西就是File。注意File并不是文件本身。我们需要操作io流来操作文件的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(File.pathSeparator);<br>        System.out.println(File.separator);<br>        <span class="hljs-comment">//路径的表示形式</span><br>        String path = <span class="hljs-string">&quot;E:\\xp\\test\\2.jpg&quot;</span>;<br>        <span class="hljs-comment">//这个可以做到跨平台，如果不是动态生成，那么不建议使用</span><br>        path = <span class="hljs-string">&quot;E:&quot;</span>+File.separator+<span class="hljs-string">&quot;xp&quot;</span>+File.separator+<span class="hljs-string">&quot;test&quot;</span>+File.separator+<span class="hljs-number">2.</span>jpg;<br>        path = <span class="hljs-string">&quot;E:/xp/test/2.jpg&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相对路径和绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String parentPath = <span class="hljs-string">&quot;E:/xp/test&quot;</span>;<br>        String name = <span class="hljs-string">&quot;2.jpg&quot;</span>;<br>        <span class="hljs-comment">//相对路径</span><br>        File src = <span class="hljs-keyword">new</span> File(parentPath,name);<br>        src = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">new</span> File(parentPath),name);<br>        <span class="hljs-comment">//输出</span><br>        System.out.println(src.getName());<br>        System.out,println(src.getPath());<br>        <span class="hljs-comment">//绝对路径</span><br>        src = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:/xp/test/2.jpg&quot;</span>);<br>        System.out.println(src.getName());<br>        System.out.println(src.getPath());<br>        <span class="hljs-comment">//没有盘符，在项目的工作空间构建</span><br>        src = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>        System.out.println(src.getName());<br>        System.out.println(src.getPath());<br>        System.out.println(src.getAbsolutePath());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_thread_next</title>
    <link href="/gzguo/2019/09/02/java/thread/next/"/>
    <url>/gzguo/2019/09/02/java/thread/next/</url>
    
    <content type="html"><![CDATA[<h4 id="线程的方法、优先级、并发、死锁">0.0.0.1. 线程的方法、优先级、并发、死锁</h4><span id="more"></span><h1 id="线程的方法">1. 线程的方法</h1><p>线程的基本信息</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>isAlive()</td><td>判断线程是否还”活着”，即线程是否还未终止</td></tr><tr><td>getPriority()</td><td>获得线程的优先级数值</td></tr><tr><td>setPriority()</td><td>设置线程的优先级数值</td></tr><tr><td>setName()</td><td>给线程一个名字</td></tr><tr><td>getName()</td><td>取得线程的名字</td></tr><tr><td>currentThread()</td><td>取得当前正在运行的线程对象也就是取得自己本身</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            <span class="hljs-comment">//Thread.currentThread().getName(),这是静态方法，放在那就代表哪个线程</span><br>            <span class="hljs-comment">//Thread.currentThread().getName(),代表当前的MyThread线程</span><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;：&quot;</span>+num++);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mian</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        MyThread t1 = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">//也可以用构造方法给线程起名字</span><br>        Thread proxy = <span class="hljs-keyword">new</span> Thread(t1);<br>        proxy.setName(<span class="hljs-string">&quot;test&quot;</span>);<br>        System.out.println(proxy.getName()); <span class="hljs-comment">//得到MyThread线程的名字</span><br>        System.out.println(Thread.currentThread().getName()); <span class="hljs-comment">//main线程</span><br>        proxy.start();<br>        Thread.sleep(<span class="hljs-number">200</span>);<br>        t1.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程的优先级">2. 线程的优先级</h1><p>线程的优先级：MAX_PRIORITY(max_priority)默认是10、NORM_PRIORITY默认是5、MIN_PRIORITY默认是1</p><p>优先级代表的是概率，不是绝对的先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            <span class="hljs-comment">//Thread.currentThread().getName(),这是静态方法，放在那就代表哪个线程</span><br>            <span class="hljs-comment">//Thread.currentThread().getName(),代表当前的MyThread线程</span><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;：&quot;</span>+num++);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        MyThread t1 = <span class="hljs-keyword">new</span> MyThread();<br>        Thread p1 = <span class="hljs-keyword">new</span> Thread(t1,<span class="hljs-string">&quot;t1&quot;</span>);<br>        MyThread t2 = <span class="hljs-keyword">new</span> MyThread();<br>        Thread p2 = <span class="hljs-keyword">new</span> Thread(t2,<span class="hljs-string">&quot;t2&quot;</span>);<br>        <br>        <span class="hljs-comment">//设置优先级</span><br>        <span class="hljs-comment">//优先级代表的是概率，不是绝对的先后顺序</span><br>        p1.setPriority(Thread.MIN_PRIORITY);<br>        p2.setPriority(Thread.MAX_PRIORITY);<br>        p1.start();<br>        p2.start();<br>        <br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        t1.stop();<br>        t2.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程并发-同步">3. 线程并发/同步</h1><p>同步也称为并发(<strong>多个线程访问同一份资源，造成资源不安全</strong>，我们就要确保资源安全)</p><p>线程安全：确保资源安全</p><h2 id="synchronize">3.1. synchronize</h2><p>synchronized同步(线程安全) 1.同步块  2.同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(引用类型|<span class="hljs-keyword">this</span>|类.class)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mian</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//创建真实角色</span><br>        Web12306 web = <span class="hljs-keyword">new</span> Web12306();<br>        <span class="hljs-comment">//代理</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;甲&quot;</span>); <br>        <span class="hljs-comment">//&quot;甲&quot; 是Thread.currentThread().getName()，是这个线程的名字</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;乙&quot;</span>);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;丙&quot;</span>);<br>        <br>        <span class="hljs-comment">//启动线程</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web12306</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            test();<br>        &#125; <br>    &#125;<br>    <br>    <span class="hljs-comment">//test和test1的效果是一样的</span><br>    <span class="hljs-comment">//线程安全，锁定正确</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;<br>            flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//跳出循环，结束线程</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">//模拟延时</span><br>        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到了&quot;</span>+num--);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//锁对象的this</span><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;<br>            flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//跳出循环，结束线程</span><br>            <span class="hljs-keyword">return</span>;<br>       &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">//模拟延时</span><br>        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到了&quot;</span>+num--);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例设计模式">3.2. 单例设计模式</h2><p>单例设计模式：确保一个类只有一个对象</p><p>懒汉式：</p><ol><li>构造器私有化，避免外部直接创建对象</li><li>声明一个私有的静态变量</li><li>创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jvm</span></span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jvm instance =  <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">//构造器私有化，避免外部直接创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Jvm</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Jvm <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>            instance = <span class="hljs-keyword">new</span> Jvm;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jvm</span></span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jvm instance =  <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">//构造器私有化，避免外部直接创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Jvm</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//创建一个对外的公共静态方法访问该变量，如果变量没有对象，创建该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jvm <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//this是成员的，是对象的，静态的没有。只能锁类</span><br>        <span class="hljs-comment">//和上面的效果是一样的</span><br>        <span class="hljs-keyword">synchronized</span>(Jvm.class)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>            instance = <span class="hljs-keyword">new</span> Jvm;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jvm <span class="hljs-title">getInstance2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//提供了已经存在的对象的访问效率</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>            <span class="hljs-comment">//this是成员的，是对象的，静态的没有。只能锁类</span><br>        <span class="hljs-comment">//和上面的效果是一样的</span><br>        <span class="hljs-keyword">synchronized</span>(Jvm.class)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>            instance = <span class="hljs-keyword">new</span> Jvm;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶汉式：</p><ol><li>构造器私有化，避免外部直接创建对象</li><li>声明一个私有的静态变量，同时创建该对象</li><li>对外提供访问属性的静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jvm</span></span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jvm instance =  <span class="hljs-keyword">new</span> Jvm();<br>    <br>    <span class="hljs-comment">//构造器私有化，避免外部直接创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Jvm</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jvm <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jvm</span></span>&#123;<br>    <br>    <span class="hljs-comment">//内部类，延缓加载时机</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JvmHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jvm instance =  <span class="hljs-keyword">new</span> Jvm();<br>    &#125;<br>    <br>    <span class="hljs-comment">//构造器私有化，避免外部直接创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Jvm</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jvm <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> JvmHodler.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="死锁">4. 死锁</h1><p>过多的同步容易造成死锁</p><p>死锁就是多份资源，但是资源的使用者有相同的，创建进程的时候就会出现死锁的现象</p><p>解决这个问题的思路：生产者、消费者模式</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>front_start</title>
    <link href="/gzguo/2019/09/01/front/start/"/>
    <url>/gzguo/2019/09/01/front/start/</url>
    
    <content type="html"><![CDATA[<h4 id="front-start">0.0.0.1. front_start</h4><span id="more"></span><h3 id="浏览器">0.0.1. 浏览器</h3><p>常见的浏览器：Opra、FireFox、InternetExplorer、Safari、Chrome(用户最多)、QQ浏览器</p><p>安卓的浏览器：(安卓是Google团队开发的) 安卓的浏览器本质上是Chrome</p><p>苹果的浏览器：Safari</p><p>微信的网页是由QQ浏览器支持的</p><h3 id="W3C">0.0.2. W3C</h3><p>W3C：软件行业最庞大、最权威的组织，它制定了很多的行业标准</p><p>W3C：World Wide Web Consortium 万维网联盟 ，不是公司，<strong>是非营利的组织</strong>，没有总部。</p><p>W3C在世界上建立了四个中心：麻省理工学院、欧洲数学与信息学研究联盟、东京庆应大学、北京航空航天大学</p><p>类似的组织：<strong>OpenSSL</strong>(全世界80%以上的网络通信都使用了OpenSSL提供的加密工具来保证信息的安全)</p><h3 id="HTML">0.0.3. HTML</h3><p>H5：HTML5 &lt; web前端</p><p>这些&lt;标记文字&gt;不再是普通的文字内容，他们不会显示在页面上，每个标记都有自己的作用，这些标记超越了普通文本的意义，叫做HyperText(超文本)他们全部以标记的形式来书写。所以我们才叫HTML(超文本标记语言 HyperText Markup Language)</p><h3 id="他们之间的关系">0.0.4. 他们之间的关系</h3><p>浏览器是网页的载体，网页需要在浏览器里运行</p><p>编写网页的语言叫HTML，规则由W3C制定</p><h1 id="start">1. start</h1><p>编译工具(器)：HbuilderX(VSCode、Sublime Text、WebStorm、Atom)</p><p>我们现在的HTML是HTML5(2014年) 相对于HTML(1997) 是一个重大的突破</p><p>我们要注意代码缩进，使用电脑上的tab键进行代码缩进</p><h2 id="网页的基本结构">1.1. 网页的基本结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span> <span class="hljs-comment">&lt;!--这句声明，就是告诉浏览器，请使用HTML5的标准来解析这个网页--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-comment">&lt;!--head表示网页的头部，这里的信息都是对网页的整体说明--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>这是网页的标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-comment">&lt;!--body表示网页的身体，网页的主要内容都写在这里--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            P标签代表段落，因此这里的内容会单独占一行<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里的内容不会显示在页面上，它通常用来注释我们的程序代码--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HbuilderX内置的服务器可以帮我们自动刷新页面，不需要手动点击刷新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    标题标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br>    标题标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>P标签代表段落，因此这里的内容会单独占一行，文字独占一行<br>    段落标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>加粗<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span> <span class="hljs-comment">&lt;!--加分割线/水平线--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-comment">&lt;!--换行--&gt;</span><br>&amp;nbsp <span class="hljs-comment">&lt;!--代表一个空格--&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>front</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>database_compared_start</title>
    <link href="/gzguo/2019/09/01/database/compared/start/"/>
    <url>/gzguo/2019/09/01/database/compared/start/</url>
    
    <content type="html"><![CDATA[<h4 id="database-compared-start">0.0.0.1. database_compared_start</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>compared</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_container_start</title>
    <link href="/gzguo/2019/08/31/java/container/start/"/>
    <url>/gzguo/2019/08/31/java/container/start/</url>
    
    <content type="html"><![CDATA[<h4 id="java-container-start">0.0.0.1. java_container_start</h4><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_exception_start</title>
    <link href="/gzguo/2019/08/30/java/exception/start/"/>
    <url>/gzguo/2019/08/30/java/exception/start/</url>
    
    <content type="html"><![CDATA[<h4 id="异常分类、处理、方法重写时的声明原则、自定义异常">0.0.0.1. 异常分类、处理、方法重写时的声明原则、自定义异常</h4><span id="more"></span><p>让大家写一个程序：将d:/a.txt复制到e:/a.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;d:/a.txt&quot;</span>这个文件存在)&#123;<br>    <span class="hljs-keyword">if</span>(e盘的空间大于a.exe文件长度)&#123;<br>        <span class="hljs-keyword">if</span>(文件复制一半io流断掉)&#123;<br>            停止copy，输出：io流出现问题！<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            copyFile(<span class="hljs-string">&quot;d:/a.txt&quot;</span>,<span class="hljs-string">&quot;e:/a.txt&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        输出：e盘的空间不足<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    输出：a.exe不存在<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的话有两个坏处：</p><ul><li>逻辑代码和错误处理代码放在一起</li><li>程序员本身需要考虑的例外情况比较复杂。对程序员本身要求比较高</li></ul><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序作出合理的处理？而不至于程序崩溃</p><p>常见的异常：</p><ul><li>用户输入错误</li><li>设备错误</li><li>硬件问题，比如打印机关掉、服务器问题</li><li>物理限制：硬盘满了</li></ul><h1 id="异常的概念">1. 异常的概念</h1><p>java异常是java提供的用于处理程序错误的一种机制</p><p>java是采用面向对象的方式来处理异常的。处理过程：</p><p>抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE</p><p>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法调用栈种查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止</p><p>类 java.lang.Throwable 的子类：Error、Exception</p><p>Error错误，不需要程序员处理，直接重启</p><p>Exception例外：需要程序员处理</p><h1 id="异常的分类">2. 异常的分类</h1><p>JDK中定义了很多异常类，这些类对应了各种各样的可能出现的异常事件，所有的异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以自己创建自己的异常类</p><p>Exception分为：CheckedException和(RuntimeException)UncheckedExcetion</p><h2 id="Error">2.1. Error</h2><ul><li>Error类层次描述了java运行时系统内部和资源耗尽的错误。这类错误是我们无法控制的，同时也是非常罕见的错误。所以在编程中，不去处理这类错误。</li><li>Error表明系统JVM已经处于不可恢复的崩溃状态中。</li><li>打开JDK包：java.lang.error，查看他的所有子类</li><li>注：我们不需要管理Error</li></ul><h2 id="Exception">2.2. Exception</h2><ul><li><p>所有异常的父类，其子类对应了各种各样可能出现的异常事件</p></li><li><p>Runtime Exception(Unchacked Exception)比较频繁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>一些特殊的异常，比如被<span class="hljs-number">0</span>除、数组下标超范围等，其产生比较频繁，处理麻烦，如果显式的声明或捕捉将会对程序可读性和运行效率影响很大。因此由系统自动检测并将他们交给缺省的异常处理程序<br><span class="hljs-number">2.</span>常见的Runtime Exception：<br>AirthmeticException/NullPointerException/ClassCastException/ArrayIndexOutOfBoundsException/NumberFormatException<br></code></pre></td></tr></table></figure></li><li><p>Checked Exception：这一类异常，我们需要捕获进行处理</p></li></ul><h1 id="异常处理">3. 异常处理</h1><h2 id="trycatch">3.1. trycatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//没有异常，就不会执行catch</span><br><span class="hljs-comment">//遇到异常的话，会在catch块中做处理</span><br><span class="hljs-comment">//不管有没有异常，finally都会执行</span><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//语句1</span><br>    <span class="hljs-comment">//语句2</span><br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-comment">//语句3</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//语句4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="try">3.1.1. try</h3><p>try语句制定了一段代码，该代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，他后面的catch语句要分别对这些异常做相应的处理</p><p>注：当异常处理的代码执行结束之后，是不会回到try语句去执行尚未执行的代码</p><h3 id="catch">3.1.2. catch</h3><ul><li><p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象</p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">toString()方法，显示异常的类名和产生异常的原因<br>getMessage()方法，只显示产生异常的原因，但不显示类名<br>printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容<br><span class="hljs-comment">//这些方法均继承自Throwable类</span><br></code></pre></td></tr></table></figure></li><li><p>Catch捕获异常时的顺序：如果异常之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面</p></li></ul><h3 id="finally">3.1.3. finally</h3><p>有些语句，不管是否发生了异常，都必须执行，那么就可以把这样的语句放到finally语句块中</p><p>通常在finally中关闭程序快已打开的资源，比如，文件流、释放数据库连接等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestException</span></span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        FileReader reader = <span class="hljs-keyword">null</span>;<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;d:/a.txt&quot;</span>);<br>            <span class="hljs-keyword">char</span> temp = (<span class="hljs-keyword">char</span>)reader.read();<br>            System.out.println(<span class="hljs-string">&quot;读出的内容：&quot;</span>+temp);<br>        &#125; <span class="hljs-keyword">catch</span>(FileNotFoundException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;文件没有找到&quot;</span>);<br>            e.printlnStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;读取文件错误&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;不管有没有异常，我肯定会被执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                reader.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-catch、finally、return的执行顺序">3.1.3.1. try catch、finally、return的执行顺序</h4><ul><li>执行try、catch，给返回值赋值，没有立即返回</li><li>执行finally</li><li>return //finally里面一般不要加retun，会把之前返回值赋的值覆盖掉</li></ul><h2 id="throw">3.2. throw</h2><p>声明异常：throws子句</p><ul><li>当Checked Exception产生时，不一定立刻处理它，可以再把异常Throws出去</li><li>如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔</li></ul><h3 id="方法重写中声明异常的原则">3.2.1. 方法重写中声明异常的原则</h3><ol><li>父类没有声明异常，子类也不能</li><li>不可抛出原有方法抛出异常类的父类或上层类</li><li>抛出的异常类型的数目不可以比原有的方法抛出的还多(不是指某个类型的个数)</li></ol><h2 id="手动抛出throw">3.3. 手动抛出throw</h2><ul><li><p>java异常类对象除在程序执行过程中出现异常时系统自动生成并抛出，也可以根据需要的手工创建并抛出</p></li><li><p>在捕获一个异常前，必须要有一段代码先生成异常对象并将他们抛出。这个过程我们可以手工做，也可以由JRE来实现，但是他们调用的都是throw子句</p></li><li><p>对于一个已经存在的异常类，抛出该异常对象过程如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.找到一个合适的异常类<br>2.创建一个该类的对象<br>3.将对象抛出java<br></code></pre></td></tr></table></figure></li></ul><h1 id="自定义异常">4. 自定义异常</h1><p>自定义异常：</p><ul><li><p>在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这种情况下可以创建自己的异常类</p></li><li><p>从Exception类或者他的子类派生一个子类即可</p></li><li><p>习惯上，定义的类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器</p></li><li><p>事列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyException</span></span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MyException</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">new</span> TestMyException().test();<br>        &#125; <span class="hljs-keyword">catch</span>(MyException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用异常机制建议">4.1. 使用异常机制建议</h2><p>使用异常机制的建议：</p><ul><li>要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率下降</li><li>处理异常不可以代替简单测试，只在异常情况下使用异常机制</li><li>不要进行小力度的异常，应该将整个任务包装在一个Try语句块中</li><li>异常往往在高层处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_thread_start</title>
    <link href="/gzguo/2019/08/29/java/thread/start/"/>
    <url>/gzguo/2019/08/29/java/thread/start/</url>
    
    <content type="html"><![CDATA[<h4 id="基本概念、开启线程、线程状态、线程阻塞">0.0.0.1. 基本概念、开启线程、线程状态、线程阻塞</h4><span id="more"></span><h1 id="进程线程基本概念">1. 进程线程基本概念</h1><p>程序、进程和线程的基本概念：</p><ul><li><p>程序：Program指令集，静态概念，就相当于一个项目的代码，写完就放在那不动了</p></li><li><p>进程：Process操作系统调度程序，动态概念，一个程序就是一个进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>进程是程序的一次动态执行过程，占用特定的地址空间<br><span class="hljs-number">2.</span>每个进程都是独立的，由三部分组成cpu、data、code<br><span class="hljs-number">3.</span>缺点：内存的浪费，cpu的负担<br></code></pre></td></tr></table></figure></li><li><p>线程：thread在进程内多条执行路径，随着程序的复杂，由于一条路径无法满足条件，就出现了多条路径，也就是我们看到的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>线程又被称为轻量级进程<br><span class="hljs-number">2.</span>一个进程可拥有多个并行的线程<br><span class="hljs-number">3.</span>一个进程中的线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且他们从同一堆中分配对象，通信、数据交换、同步操作<br><span class="hljs-comment">//第三句话的意思就是说，线程可以共享数据，共享一份数据，就容易造成并发</span><br><span class="hljs-number">4.</span>由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快<br><span class="hljs-comment">//还是在同一条道路上，在进程上，所以信息交互很方便</span><br></code></pre></td></tr></table></figure></li></ul><p>异常、main方法、gc这三者，在底层的实现，就是依靠多线程</p><h1 id="进程和线程的区别">2. 进程和线程的区别</h1><table><thead><tr><th>区别</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>作为资源分配单位</td><td>调度和执行的单位</td></tr><tr><td>开销</td><td>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销</td><td>线程可以看成轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小</td></tr><tr><td>所处环境</td><td>在操作系统中能同时进行多个任务(程序)</td><td>在同一应用程序中有多个顺序流同时执行</td></tr><tr><td>分配内存</td><td>系统在运行的时候会为每个进程分配不同的内存区域</td><td>除了CPU之外，不会为线程分配内存(线程所使用的资源是它所属的进程资源)，线程组只能共享资源</td></tr><tr><td>包含关系</td><td>没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线(线程)共同完成的</td><td>线程是进程的一部分，所有线程有的时候被称之为是轻权进程或者轻量级的进程</td></tr></tbody></table><h1 id="java中实现多线程">3. java中实现多线程</h1><h2 id="继承Thread">3.1. 继承Thread</h2><p><strong>1.继承Thread + 重写run()；2.启动：创建子类对象 + 对象.start()</strong></p><p>java实现多线程：</p><ul><li>在java中负责线程的这个功能是java.lang.Thread这个类</li><li>可以通过创建Thread的实例来创建新的线程</li><li>每个线程都是通过某个特定Thread对象所对应的run()来完成其操作的，方法run()称为线程体。run就相当于程序中的main方法，是个入口。run方法里面的内容就是线程体</li><li>通过调用Thread类的start()方法来启动一个线程</li></ul><p>继承Thread的缺点：(解决方案：实现Runnable)</p><ul><li><p>继承Thread类方式的缺点：那就是如果我们的类已经从一个类继承(如小程序必须继承自Applet类)，则无法再继承Thread类</p></li><li><p>通过Runnable接口实现多线程</p></li><li><p>优点：可以同时实现继承。实现Runnable接口方式要通用一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">通过实现Runnable，来实现多线程的优点：<br><span class="hljs-number">1.</span>避免单继承<br><span class="hljs-number">2.</span>方便共享资源，同一份资源，多个代理访问<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino">  <br><br>### 模拟龟兔赛跑<br><br>思路：<br><br><span class="hljs-number">1.</span> 创建多线程，继承Thread + 重写<span class="hljs-built_in">run</span>(线程体)<br><span class="hljs-number">2.</span> 使用线程：创建子类对象 + 对象.<span class="hljs-built_in">start</span>()方法<br><br>​```java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span>&#123;</span><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//线程体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;兔子跑了&quot;</span>+i+<span class="hljs-string">&quot;步&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitApp</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>        <span class="hljs-comment">//创建子类对象，只不过是线程类的对象而已</span><br>        Rabbit rab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rabbit</span>();<br>        <span class="hljs-comment">//调用start方法，start会把对象加到线程中，start相当于开辟一条路</span><br>        rab.<span class="hljs-built_in">start</span>(); <span class="hljs-comment">//不要调用run方法，run方法在start内部被调用</span><br>        <span class="hljs-comment">//如果调用run，就不会加到线程中，没有开辟路径，不是多线程，还是单线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="继承Thread的缺点">3.1.1. 继承Thread的缺点</h3><ul><li><p>继承Thread类方式的缺点：那就是如果我们的类已经从一个类继承(如小程序必须继承自Applet类)，则无法再继承Thread类</p></li><li><p>通过Runnable接口实现多线程</p></li><li><p>优点：可以同时实现继承。实现Runnable接口方式要通用一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">通过实现Runnable，来实现多线程的优点：<br><span class="hljs-number">1.</span>避免单继承<br><span class="hljs-number">2.</span>方便共享资源，同一份资源，多个代理访问<br></code></pre></td></tr></table></figure></li></ul><p>Runnable接口使用了一种代理模式：称为<strong>静态代理</strong></p><h2 id="静态代理-Runnable">3.2. 静态代理(Runnable)</h2><p>静态代理(Runnable接口实现多线程)：<strong>1.实现Runnable + 实现run()；2.启动：使用静态代理</strong></p><p>具体的实现步骤：<strong>1.创建真实角色</strong> <strong>2.创建代理角色 Thread + 引用</strong> <strong>3.代理角色.start()</strong></p><p>推荐使用接口：<strong>1.避免单继承的局限性 2.便于共享资源</strong></p><p>静态代理模式的条件：</p><ul><li>真实角色</li><li>代理角色：持有真实角色的引用</li><li>二者要实现相同的接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟个人和婚庆公司，初步体会面向接口开发</span><br><br><span class="hljs-comment">//接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Marry</span></span>&#123;<br>    <span class="hljs-comment">/*public abstract*/</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//真实角色，实现Marry</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Marry</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marry</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;you and me&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理角色，实现Mary</span><br><span class="hljs-keyword">public</span> WeddingCompany implements Marry&#123;<br>    <br>    <span class="hljs-keyword">private</span> Marry you;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeddingCompany</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeddingCompany</span><span class="hljs-params">(Marry you)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.you = you;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;布置房间&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收拾房间&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Marry</span><span class="hljs-params">()</span></span>&#123;<br>        you.marry();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//创建真实角色</span><br>        <span class="hljs-comment">/*Marry*/</span>You you = <span class="hljs-keyword">new</span> You();<br>        <span class="hljs-comment">//创建代理角色+真实角色的引用</span><br>        <span class="hljs-comment">/*Marry*/</span>WeddingCompany company = <span class="hljs-keyword">new</span> WeddingCompany(you);<br>        <br>        <span class="hljs-comment">//执行任务</span><br>        company.marry();<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 执行结果：</span><br><span class="hljs-comment">         * 布置房间</span><br><span class="hljs-comment">         * you and me</span><br><span class="hljs-comment">         * 收拾房间</span><br><span class="hljs-comment">         */</span><br>        <br>        <span class="hljs-comment">//真正结婚的是你</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多线程静态代理的实现：(我们需要做的只有：<strong>1.创建真实角色重写run；2.交给Thread</strong>)</p><p>Runnable接口：Thread已经实现了，相当于代理角色</p><p><strong>我们只需要创建一个真实角色</strong>，后续的操作交给Thread处理就行</p><p>真实角色中只要<strong>重写run方法</strong>即可</p><p>还有最后一个问题：</p><p>代理角色怎么<strong>持有真实角色的引用</strong>？Thread(Runnable target);构造方法/构造器</p><p>都弄好之后，这就是一个静态代理</p><p><em>后面会学习反射的时候会学到动态代理：静态代理和动态代理的实现的功能是一样的，静态代理的代理角色是写死的。但是动态代理的话，这个类是运行过程中动态创建的，是一个动态的行为</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟表演，都要实现Runnable</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用Runnable创建线程</span><br><span class="hljs-comment"> * 1.类实现Runnable接口 + 重写run() //这个类是我们的真实角色</span><br><span class="hljs-comment"> * 2.启动多线程，使用静态代理</span><br><span class="hljs-comment"> *   1&gt;创建真实角色</span><br><span class="hljs-comment"> *   2&gt;创建代理角色 + 对真实角色的引用</span><br><span class="hljs-comment"> *   3&gt;调用.start() 启动线程</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真实角色</span><br><span class="hljs-comment"> * 类实现Runnable接口 + 重写run()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//线程体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;创建角色的表演&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgrammerApp</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//1&gt;创建真实角色</span><br>        Programmer pro = <span class="hljs-keyword">new</span> Programmer();<br>        <span class="hljs-comment">//2&gt;创建代理角色 + 对真实角色的引用</span><br>        Thread proxy = <span class="hljs-keyword">new</span> Thread(pro);<br>        <span class="hljs-comment">//3&gt;调用.start() 启动线程</span><br>        proxy.start();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;主程序的表演&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>推荐使用Runnable创建线程：(面向接口编程)</p><ol><li><p>避免单继承的局限性</p></li><li><p>便于共享资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟购票，实现了购票功能</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web12306</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <br>    <span class="hljs-comment">//票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">50</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//跳出循环，结束线程</span><br>        &#125;<br>        &#125;<br>        <br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到了&quot;</span>+num--);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mian</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//创建真实角色</span><br>        Web12306 web = <span class="hljs-keyword">new</span> Web12306();<br>        <span class="hljs-comment">//代理</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;甲&quot;</span>); <br>        <span class="hljs-comment">//&quot;甲&quot; 是Thread.currentThread().getName()，是这个线程的名字</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;乙&quot;</span>);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;丙&quot;</span>);<br>        <br>        <span class="hljs-comment">//启动线程</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Callable">3.3. Callable</h2><p>实现Runnable接口来实现多线程的缺点：<strong>1.不能抛异常；2.没有返回值</strong></p><p>通过Callable接口实现多线程：</p><ul><li><p>优点：可以获取返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable和Future接口<br>Callable是类似于Runnable的接口，实现Callable接口和实现Runnable的类都是可被其他线程执行的任务<br>Callable和Runnable的不同：<br> <span class="hljs-number">1</span>&gt;Callable规定的方法是call(),而Runnable规定的方法是run()<br> <span class="hljs-number">2</span>&gt;call()方法可抛出异常,而run()方法不能抛出异常<br> <span class="hljs-number">3</span>&gt;Callable的任务执行后可返回值，它提供了检查计算是否完成的方法，以待计算的完成，并检索计算的结果<br>Future表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果，通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果<br></code></pre></td></tr></table></figure></li><li><p>缺点：<strong>繁琐</strong></p></li></ul><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>创建Callable实现类+重写call<br><span class="hljs-number">2.</span>借助执行调度服务ExecutorService，获取Future对象<br>  <span class="hljs-number">1</span>&gt;ExecutorService ser = Excutors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>  <span class="hljs-number">2</span>&gt;Future result = ser.submit(实现类对象);<br><span class="hljs-number">3.</span>获取值result.get()<br><span class="hljs-number">4.</span>停止服务ser.shutdownNow()<br></code></pre></td></tr></table></figure><h3 id="模拟龟兔赛跑">3.3.1. 模拟龟兔赛跑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Race</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> time;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>; <span class="hljs-comment">//步</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Race</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Race</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Race</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> time)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.time = time;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            Thread.sleep(time); <span class="hljs-comment">//延时</span><br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用Callable创建线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Testcall</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span></span><br><span class="hljs-function">        IntereuptedException,ExecutionException</span>&#123;<br>        <span class="hljs-comment">//创建线程</span><br>        ExecutorService ser = Executors.newFixedThreadPool(<span class="hljs-number">2</span>); <span class="hljs-comment">//数字代表创建几个线程</span><br>        Race tortoise = <span class="hljs-keyword">new</span> Race(<span class="hljs-string">&quot;乌龟&quot;</span>,<span class="hljs-number">1000</span>);<br>        Race rabbit = <span class="hljs-keyword">new</span> Race(<span class="hljs-string">&quot;兔子&quot;</span>,<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//获取值</span><br>        Future&lt;Integer&gt; result1 = ser.submit(tortoise);<br>        Future&lt;Integer&gt; result2 = ser.submit(rabbit);<br>        <br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        tortoise.setFlag(<span class="hljs-keyword">false</span>);<br>        rabbit.setFlag(<span class="hljs-keyword">false</span>);<br>        <br>        <span class="hljs-keyword">int</span> num1 = result1.get();<br>        <span class="hljs-keyword">int</span> num2 = result2.get();<br>        <br>        System.out.println(<span class="hljs-string">&quot;乌龟跑了&quot;</span>+num1+<span class="hljs-string">&quot;步&quot;</span>); <span class="hljs-comment">//输出结果：step</span><br>        System.out.println(<span class="hljs-string">&quot;兔子跑了&quot;</span>+num2+<span class="hljs-string">&quot;步&quot;</span>);<br>        <br>        <span class="hljs-comment">//停止服务</span><br>        ser.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程状态">4. 线程状态</h1><p>创建之后是新生状态，调用start方法之后进入就绪状态，CPU调度到之后进入运行状态，在时间片内完成了任务就进入死亡状态，没有执行完就进入挂起(就绪状态)</p><p>线程状态：</p><ul><li>新生状态：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态(runnable)</li><li>就绪状态：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，他就会从等待执行状态进入执行状态，系统挑选的动作称之为”CPU调度“。一旦获取CPU，线程就进入运行状态并自动调用自己的run方法</li><li>运行状态：在运行状态的线程执行自己的run方法中的代码，直到调用其他方法而终止、或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态</li><li><strong>阻塞状态</strong>：处于运行状态的线程在某些情况下，如执行了sleep(睡眠)方法，或等待IO设备等资源，将让出CPU并暂时停止自己的运行，进入到阻塞状态。在阻塞状态的线程不能就如就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等到的IO设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行</li><li>死亡状态：死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它全部的工作，另一个是线程被强制性的终止，如通过执行stop或destory方法来终止一个线程(不推荐使用这两个方法。前者会产生异常，后者是强制终止，不会释放锁)</li></ul><h2 id="停止线程">4.1. 停止线程</h2><ol><li><p>自然终止：线程体正常执行完毕</p></li><li><p>外部干涉：通过改变标识，来结束循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Study</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//1.线程类中定义线程体使用的标识</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//2.线程体使用该标识</span><br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;study thread……&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//3.对外提供改变标识的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Study s = <span class="hljs-keyword">new</span> Study();<br>        <span class="hljs-keyword">new</span> Thread(s).start();<br>        <span class="hljs-comment">//4.外部干涉</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">50</span> == i)&#123;<br>                s.stop();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;main……&quot;</span>+i)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="线程阻塞">5. 线程阻塞</h1><h2 id="join">5.1. join</h2><p>join：合并线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Join</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> <span class="hljs-title">throws</span> <span class="hljs-title">InterruptedException</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Join j = <span class="hljs-keyword">new</span> Join();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(j); <span class="hljs-comment">//新生</span><br>        t.start(); <span class="hljs-comment">//就绪</span><br>        <br>        <span class="hljs-comment">//CPU调度到了就运行</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">50</span> == i)&#123;<br>                t.join() <span class="hljs-comment">//main停下来，等待t执行完，再执行。</span><br>                <span class="hljs-comment">//main阻塞了</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;join……&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main……&quot;</span>)+i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="yield">5.2. yield</h2><p>yield：暂停当前正在执行的线程对象，并执行其他线程，static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yield</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> <span class="hljs-title">throws</span> <span class="hljs-title">InterruptedException</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Join j = <span class="hljs-keyword">new</span> Join();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(j); <span class="hljs-comment">//新生</span><br>        t.start(); <span class="hljs-comment">//就绪</span><br>        <br>        <span class="hljs-comment">//CPU调度到了就运行</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">20</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//Thread.yield()是静态方法，写在谁的线程体里面就暂停谁</span><br>                <span class="hljs-comment">//暂停本线程：main</span><br>                Thread.yield();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;yield……&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main……&quot;</span>)+i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sleep">5.3. sleep</h2><p>每一个对象都有一把锁，这个对象占用了资源，获得了这个资源的一把排他锁(互斥锁)，其他的线程访问不了这个对象</p><p>sleep：暂停线程多少时间，在指定的毫秒数内进行休眠。休眠的时候不释放锁</p><p>sleep一般用于两种形式：1&gt;与时间相关：倒计时   2&gt;模拟网络延时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//倒数10个数，，一秒内打印一个</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>System.out.println(num--);<br>Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//休眠main</span><br><span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//倒计时</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//System.currentTimeMillis()+10*1000</span><br>        <span class="hljs-comment">//上面这个代表当前时间的后10秒</span><br>        <span class="hljs-comment">//new date()也可以代表当前时间</span><br>Date endTime = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()+<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">long</span> end = endtime.getTime();<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;mm:ss&quot;</span>).format(endTime));<br><span class="hljs-comment">//等待1秒</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//构建下一秒的时间</span><br>endTime = <span class="hljs-keyword">new</span> Date(endTime.getTime()-<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//10秒以内继续否则退出</span><br><span class="hljs-keyword">if</span>(end-<span class="hljs-number">10000</span>&gt;endTime.getTime())&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟网络延时</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//真实角色</span><br>        Web12306 web = <span class="hljs-keyword">new</span> Web12306();<br>        <span class="hljs-comment">//代理</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;甲&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;乙&quot;</span>);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(web,<span class="hljs-string">&quot;丙&quot;</span>);<br>        <span class="hljs-comment">//启动线程</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        <br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web12306</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-comment">//run方法不能对外声明异常</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//run方法不能对外声明异常,只能try、catch</span><br>                <span class="hljs-comment">//并发，资源冲突</span><br>                <span class="hljs-comment">//输出结果会出现0和-1，由于并发或资源冲突</span><br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到了&quot;</span>+num--);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_next</title>
    <link href="/gzguo/2019/08/20/java/basis/next/"/>
    <url>/gzguo/2019/08/20/java/basis/next/</url>
    
    <content type="html"><![CDATA[<h4 id="java类型转换、控制语句、语句块、递归">0.0.0.1. java类型转换、控制语句、语句块、递归</h4><span id="more"></span><h1 id="类型转换">1. 类型转换</h1><h2 id="自动类型转换">1.1. 自动类型转换</h2><p>自动类型转化指的是容量小的数据类型可以自动转换为容量大的数据类型</p><p>容量不是按字节算的：</p><p>long 8 byte</p><p>float 4 byte</p><p>但long类型的值可以自动转为float，因为float表示的范围要比long类型大，但是转的时候会损失一定的精度</p><p><img src="/images/typechange.png" alt="红色的可以自动转，蓝色的转的时候会损失精度"></p><p>特例：</p><p>可以将整形常量直接赋值给byte、short、char等类型变量，而不需要进行强制类型转换，只需要不超过其表数范围即可</p><h2 id="强制类型转换">1.2. 强制类型转换</h2><p>强制类型转化，又称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出</p><p>运算符()中的type表示将值var想要转换成的目标数据类型</p><p>注意：</p><ul><li>操作比较大的数时，要留意是否溢出</li><li>不要命名名字为l的变量，小写l容易与1混淆</li><li>举个例子：只要有一个long类型的数，则经过运算之后结果为long类型的数。</li></ul><h1 id="使用Scanner获取键盘输入">2. 使用Scanner获取键盘输入</h1><p>需要导包java.util.Scanner</p><p>测试获得键盘的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>System.out.println(<span class="hljs-string">&quot;输入你的名字：&quot;</span>);<br><br>String name = scanner.nextLine();<br><br>System.out.println(<span class="hljs-string">&quot;请输入你的爱好：&quot;</span>)；<br><br>String favor = scanner.nextInt();<br><br>System.out.println(<span class="hljs-string">&quot;请输入你的年龄：&quot;</span>)；<br><br><span class="hljs-keyword">int</span> age = scanner.nextInt();<br><br>System.out.println(<span class="hljs-string">&quot;###########&quot;</span>);<br>Syetem.out.println(name);<br>System.out.println(favor);<br>System.out.println(age);<br></code></pre></td></tr></table></figure><h1 id="控制语句">3. 控制语句</h1><h2 id="流程控制语句">3.1. 流程控制语句</h2><p>流程控制语句是用来控制程序中个语句执行的顺序</p><ul><li>顺序结构：代表先执行a，在执行b的逻辑</li><li>选择结构：代表 如果……，则……的逻辑</li><li>循环结构：代表 如果……，则……再继续的逻辑</li></ul><p>任何软件和程序，小到一个练习，大到一个操作系统，本质上都是由变量、选择语句、循环语句组成</p><h2 id="选择结构">3.2. 选择结构</h2><h3 id="if单选择结构">3.2.1. if单选择结构</h3><ul><li>如果if语句不写{}，则只能作用于后面的第一条语句</li><li>强烈建议，任何时候都写上{}，即使里面只有一句话</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">TestIf</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> d = Math.random(); <span class="hljs-comment">//返回0-1之间的随机数，不包含1</span><br>        <span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)(<span class="hljs-number">6</span>*Math.random()+<span class="hljs-number">1</span>); <span class="hljs-comment">//生成1-6之间的随机数</span><br>        <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">3</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;小&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-else双选择结构">3.2.2. if-else双选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestItElse</span></span>&#123;<br>    <span class="hljs-keyword">int</span> h = (<span class="hljs-keyword">int</span>)(<span class="hljs-number">6</span>*Math.random()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(h &lt;= <span class="hljs-number">3</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;小&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;大&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-else-if-else多选择结构">3.2.3. if-else if-else多选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>()&#123;<br>    <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()&#123;<br>    <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()&#123;<br>    <br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="switch多选择结构">3.2.4. switch多选择结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        语句序列<span class="hljs-number">1</span>;<br>        [<span class="hljs-keyword">break</span>];<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        语句序列<span class="hljs-number">1</span>;<br>        [<span class="hljs-keyword">break</span>];<br>    [<span class="hljs-keyword">default</span>:<br>        默认语句;]<br>&#125;<br><span class="hljs-comment">//[代表可选]</span><br><span class="hljs-comment">//switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句末尾。如果表达式的值与任一case不匹配，则进入default语句(如果存在default语句的情况)</span><br></code></pre></td></tr></table></figure><h2 id="循环结构">3.3. 循环结构</h2><p>循环结构分两大类：一类是当型、一种是直到型</p><h3 id="while">3.3.1. while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">100</span>)&#123;<br>        sum += i;<br>        i++;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>do-while:先执行后判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span>&#123;<br>    sum += i;<br>    i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">100</span>);<br><br>System.out.println(<span class="hljs-string">&quot;Sum = &quot;</span>+sum);<br></code></pre></td></tr></table></figure><h3 id="for循环">3.3.2. for循环</h3><p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//i++就是所谓的迭代</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++)&#123;<br>        sum += i;<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;sum = &quot;</span>+sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过,可以隔开多个初始化语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = i + <span class="hljs-number">10</span>; i &lt; <span class="hljs-number">5</span>; i++,j = i*<span class="hljs-number">2</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;i = &quot;</span>+i+<span class="hljs-string">&quot;j = &quot;</span>+j);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化变量作用域：只在for循环内部</p><h2 id="嵌套循环">3.4. 嵌套循环</h2><p>嵌套循环：在一个循环语句内部再嵌套一个或多个循环，称之为嵌套循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)&#123;<br>            System.out.print(i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            System.out.print(j+<span class="hljs-string">&quot;*&quot;</span>+i+<span class="hljs-string">&quot;=&quot;</span>+i*j+<span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i+=<span class="hljs-number">2</span>)&#123;<br>        sum += i;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;100以内奇数的和：&quot;</span>+sum);<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">100</span>; i+=<span class="hljs-number">2</span>)&#123;<br>        sum += i;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;100以内偶数的和：&quot;</span>+sum);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;<br>System.out.print(i+<span class="hljs-string">&quot;\t&quot;</span>);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">5</span>)&#123;<br>            System.out.println();<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="break和continue">3.5. break和continue</h2><p>break用于强制退出循环，不执行循环中剩余的语句</p><p>continue退出本次循环，继续下一次</p><p>goto关键字很早就在程序设计语言中出现。尽管goto仍然是java的一个保留字，但并未在java语言中得到正式使用；Java没有goto语句</p><p>带标签的break和continue，我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//打印101到150之间的所有质数</span><br>    outer: <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">101</span>; i &lt; <span class="hljs-number">150</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i/<span class="hljs-number">2</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span> outer;<br>            &#125;<br>        &#125;<br>        System.out.println(i + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="语句块">4. 语句块</h1><p>语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中的变量，因为语句块中定义的变量作用域只限于语句块</p><h2 id="方法">4.1. 方法</h2><p>方法说白了就是给代码块加了一个名字，可以被我们反复的调用</p><p>方法就是一段用来完成特定功能的代码片段，类似于其他语言的函数</p><p>方法用于定义该类的实例的行为特征和功能的实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。<strong>面向对象中，整个程序的基本单位是类</strong>，方法是从属于类和对象的</p><p>方法是可以传参数的，想打印啥，你就给他传啥，他就会按照你的意愿去打印</p><h3 id="方法的详细说明">4.1.1. 方法的详细说明</h3><ul><li>形式参数：在方法声明时用于接受外界传入的数据</li><li>实参：调用方法时实际传给方法的数据</li><li>返回值：方法在执行完毕后返回给调用它的环境数据</li><li>返回值类型：实现约定的返回值的数据类型，如无返回值，必须显示指定的void</li></ul><p>方法中return的两个作用：</p><ol><li>结束该方法</li><li>返回返回值</li></ol><p>注意事项：</p><ul><li>实参的数目、数据类型、次序必须和所调用的方法声明的形式参数列表匹配</li><li>return语句终止方法的执行并指定要返回的数据</li><li>java中进行方法调用中传递参数时，遵循<strong>值传递</strong>的原则(传递的都是数据的副本)</li><li>基本类型传递的是该数据值的copy值</li><li>引用类型传递的是该对象引用的copy值，但指向的是同一个对象</li></ul><h3 id="方法的重载">4.1.2. 方法的重载</h3><p>overload</p><p>重载的方法，实际上是完全不同的方法，只是名称相同而已</p><p>重载的方法，形参个数或者类型不同</p><p>参数名称不同，不能构成重载</p><p>返回值类型不同，不能构成重载，这两种情况无法区分</p><h2 id="递归结构">4.2. 递归结构</h2><p>递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法会直接或者间接的调用自己</p><p>利用递归可以用简单的程序来解决一些复杂的问题。</p><p>递归结构包括两个部分：</p><ul><li>定义递归头。解答：什么时候不调用自身的方法。如果没有头，也就是递归的结束条件</li><li>递归体：解答：什么时候需要调用自身的方法</li></ul><p>递归的缺陷：耗时耗力</p><p>注意事项：</p><ul><li>任何使用递归解决的问题也能使用迭代解决，当递归方法可以更加自然的反应问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归</li><li>在高性能的情况下尽量避免使用递归，递归调用既浪费时间，又消耗内存</li></ul><p>爬虫是递归</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_jdbc_start</title>
    <link href="/gzguo/2019/08/16/java/jdbc/start/"/>
    <url>/gzguo/2019/08/16/java/jdbc/start/</url>
    
    <content type="html"><![CDATA[<h4 id="JDBC全面了解">0.0.0.1. JDBC全面了解</h4><span id="more"></span><h1 id="JDBC简介">1. JDBC简介</h1><ul><li>jdbc是Java Database Connectivity的缩写，即java数据库连接思想，使用jdbc可以实现对数据库的访问</li><li>我们都知道，java是跨操作平台的，而通过jdbc可以实现跨数据库平台，jdbc只是一个抽象的编程接口，通过加载不同的数据库驱动，可以实现不同数据库的通信，例如：Mysql、Oracl、SqlServer</li><li>在java中有两个包java.sql和javax.sql包含jdbc编程的所有接口</li><li>在java中常用接口和类如下：DriverManger 驱动管理器获得数据库链接、Connect 数据库连接接口、Statement 语句接口，用来静态操作SQL语句、PreparedStatement 预定义语句，用来动态操作SQL语句、CallableStatement 可以调用存储过程的预定义语句、ResultSet 结果集，保存数据记录的结果集合、ResultMetaData 结果集元数据，如：列名称、列类型 、DatabaseMetaData 数据库元数据，如：数据库名称、版本</li><li>jdbc的编程步骤：1.加载数据库驱动（jar文件） 2.获取数据库连接 3.创建语句 4.执行查询 5.遍历结果集 6.关闭数据库连接</li></ul><h1 id="数据库连接">2. 数据库连接</h1><ul><li>获得数据库连接是操作数据库的第一步，是应用程序和数据库的一个“握手”过程</li><li>数据库打开的连接数是有限的，所以连接使用完成需要关闭</li><li>获得数据库连接的步骤：1.加载驱动(Class.forName) 2.获得连接(DriverManager 是获取数据库连接的一个工厂(实例化的作用) DriverManager.getConnection()) </li></ul><p><strong>创建数据库连接的时候，可以通过配置文件来加载固定格式的url、username、password等</strong></p><h1 id="Statement语句">3. Statement语句</h1><ul><li>Statement语句是SQL语句的描述，使用它可以操作各种SQL语句，包括DDL(数据库定义语句，如创建表)、DML(CRUD)和DCL等</li><li>使用Statement创建表</li></ul><h1 id="ResultSet结果集">4. ResultSet结果集</h1><ul><li>用来获得SQL语句查询结果</li><li>结果集包含了SQL语句的查询结果数据</li><li>调用语句的excuteQuery方法返回结果集对象</li><li><strong>ResultSet常用方法 next：返回boolean类型数据，用来判断结果集中是否有数据   getXXX：获得结果集中的数据项(可以根据列名称、可以根据列索引)</strong></li></ul><h1 id="PreparedStatement">5. PreparedStatement</h1><ul><li><p>PreparedStatement为预定义语句，继承Statement</p></li><li><p>Statement只能静态操作SQL语句，如果要操作动态SQL，这里可以使用PreparedStatement来动态操作SQL语句，PreparedStatement通过使用占位符“？”，来预生成SQL语句，从而达到动态操作的功能</p></li><li><p>```java<br>static void insert(String name,String email){</p><pre><code>String sql = &quot;insert into CustomrTbl(name,email) values(?,?);&quot;;Connection conn = DBUtil.open();try&#123;    PreparedStatement pstmt = conn.prepareStatement(sql);    pstmt.setString(1,name);    pstmt.setString(2,email);&#125; catch (SQLException e) &#123;    e.printStackTrace();&#125; finally &#123;    DBUtil.close(conn);&#125;</code></pre><p>}</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>  <br><br># CallableStatement<br><br>调用后台写好的存储过程<br><br>- CallableStatement继承PreParedStatement，提供了调用存储过程的能力<br>- CallableStatement用法：<span class="hljs-number">1.</span>调用简单的存储过程 <span class="hljs-number">2.</span>调用有输入参数的存储过程 <span class="hljs-number">3.</span>调用有输入、输出参数的存储过程<br>- 实例：<span class="hljs-number">1.</span>命令行创建存储过程：create procedure/pro all<span class="hljs-constructor">_customers()</span> select<span class="hljs-operator"> * </span>from CustomerTbl; <span class="hljs-number">2.</span>命令行调用：call all<span class="hljs-constructor">_customers()</span>; <span class="hljs-number">3.</span>使用CallableStatement调用<br><br>```java<br>static void test<span class="hljs-literal">()</span>&#123;<br>    Connection conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DBUtil</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        CallableStatement cstmt = conn.prepare<span class="hljs-constructor">Call(<span class="hljs-string">&quot;&#123;call all_customers()&#125;&quot;</span>)</span>;<br>        ResultSet rs = cstmt.execute<span class="hljs-constructor">Query()</span>;<br>        <span class="hljs-keyword">while</span>(rs.next<span class="hljs-literal">()</span>)&#123;<br>            <span class="hljs-built_in">int</span> id = rs.get<span class="hljs-constructor">Int(1)</span>;<br>            String name = rs.get<span class="hljs-constructor">String(2)</span>;<br>            String email = rs.get<span class="hljs-constructor">String(3)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;id:&quot;</span>+id+<span class="hljs-string">&quot;,&quot;</span>+<span class="hljs-string">&quot;name:&quot;</span>+name+<span class="hljs-string">&quot;,&quot;</span>+<span class="hljs-string">&quot;email:&quot;</span>+email);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>这是创建存储过程，<span class="hljs-keyword">in</span>代表输入参数<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> insert_customer(<span class="hljs-keyword">in</span> myname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">in</span> myemail <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> CustomerTbl(name,email) <span class="hljs-keyword">values</span>(myname,myemail);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> getnamebyid(<span class="hljs-keyword">in</span> cid <span class="hljs-type">int</span>,<span class="hljs-keyword">out</span> return_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">select</span> name <span class="hljs-keyword">into</span> return_name <span class="hljs-keyword">from</span> CustomerTbl <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> cid;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    Connection conn = DBUtil.open();<br>    <span class="hljs-keyword">try</span>&#123;<br>        CallableStatement cstmt = conn.prepareCall(<span class="hljs-string">&quot;&#123;call getnamebyid(?,?)&#125;&quot;</span>);<br>        cstmt.setInt(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//注册输入参数</span><br>        cstmt.registerOutParameter(<span class="hljs-number">2</span>,Types.CHAR);<br>        cstmt.excute();<br>        String email = cstmt.getString(<span class="hljs-number">2</span>);<br>        cstmt.executeUpdate();<br>        System.out.println(email);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span>&#123;<br>        DBUtil.close(conn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DAO设计模式">6. DAO设计模式</h1><ol><li>DAO简介 DAO的全称是：Data Access Object，数据访问对象，使用DAO设计模式，来封装数据库持久层操作(CRUD)，使低级的数据逻辑和高级的业务逻辑分离，达到解耦合的目的</li><li>一个典型的DAO实现有如下的组件：一个DAO接口、数据传输对象(有时称为值对象)、一个实现DAO接口的具体类、一个DAO工厂类</li><li>以维护一个客户信息为例，具体组件如下：CustomerDao接口、Customer值对象(VO)、CustomerDaoImpl(接口工具实现类)、CustomerFactory(工厂类、实例化用)</li></ol><p>Dao接口：里面写很多方法来进行增删改查</p><p>Dao实现类：实现这些方法</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdbc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_mysql_start</title>
    <link href="/gzguo/2019/08/16/java/mysql/start/"/>
    <url>/gzguo/2019/08/16/java/mysql/start/</url>
    
    <content type="html"><![CDATA[<h4 id="mysql对数据库和数据表的操作">0.0.0.1. mysql对数据库和数据表的操作</h4><span id="more"></span><h2 id="mysql操作数据库和数据表">0.1. mysql操作数据库和数据表</h2><p>create table 表名(字段名 类型 主键 非空);   建表</p><p>create database 数据库名;   建库 </p><p>use 数据库名;   使用某个数据库</p><p>show databases：查看数据库</p><p>show tables：查看数据表</p><p>describe/desc 表名：查看表结构</p><p>select * from 表名：查看表内数据</p><h2 id="mysql增删改查">0.2. mysql增删改查</h2><p>select * from 表名;   //get</p><p>insert into 表名(字段名) values(字段值);   //post</p><p>update 表名 set 字段名 = ‘字段值’;   //put</p><p>delete from 表名 where id = ‘字段值’;   //delete</p><h2 id="mysql的约束">0.3. mysql的约束</h2><p><strong>primary key主键约束</strong>：是每条信息的唯一信息，主键不能重复，主键禁止为空，主键一般标志到无意义的字段上</p><p><strong>auto_increment自动递增</strong>：从一开始自增</p><p><strong>唯一约束</strong>：约束修饰的字段的不能重复</p><p><strong>非空约束</strong>：<strong>not null</strong>不能为null</p><p><strong>默认约束</strong>：<strong>default</strong>当我们插入字段的时候，如果没有传值，就会使用默认值</p><p><strong>外键约束</strong>：<strong>foreign key</strong> <strong>references</strong></p><p>结论：<em>1.主表中没有的数据，在副表中是不可以使用的</em></p><p>​            <em>2.主表中的记录被副表引用，那么主表中的这条记录是不可以被删除的</em></p><p>涉及到两个表：父表、子表（主表、副表）</p><p><em>主表不能随意删，副表不能随便加</em></p><p>小例子：foreigen key(子表字段名) references 父表(父表中的字段名);</p><h2 id="mysql对时区和密码的操作">0.4. mysql对时区和密码的操作</h2><p>SELECT @@global.time_zone;  // global.time_zone<br>SELECT @@global.system_time_zone;  // globle.system_time<br>show variables like “%time_zone%”;  // Variable_name,Value<br>select now();  // now()</p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;   修改数据库密码</p><p>select @@autocommit;  mysql的事务开启状态：是否自动提交 1 自动提交 2 非自动提交</p><h2 id="mysql修改表结构：">0.5. mysql修改表结构：</h2><p><strong>给某个字段添加主键约束</strong>：</p><p>alter table 表名 add primary key(字段名);   //直接增加</p><p>alter table 表名 modify 字段名 类型 primary key; //修改字段间接增加</p><p><strong>删除主键约束</strong>：alter table 表名 <u>drop</u> primary key;</p><p><strong>添加唯一约束</strong>：</p><p>alter table 表名 add unique(字段名);</p><p>alter table 表名 modify 字段名 类型 unique;</p><p><strong>删除唯一约束</strong>：alter table 表名 drop index 字段名;</p><h2 id="设计数据库的格式：">0.6. 设计数据库的格式：</h2><h3 id="第一范式：">0.6.1. 第一范式：</h3><p><strong>数据表中的所有字段都是不可分割的原子值</strong></p><p>根据字段值还可以继续拆分的，不满主第一范式</p><p>范式，设计的越详细，对于某些实际操作可能更好，但不一定都是好处</p><h3 id="第二范式">0.6.2. 第二范式</h3><p>满足第一范式的前提下，第二范式要求，<strong>除主键外的每一列都必须完全依赖于主键</strong></p><p>如果要出现不完全依赖，只可能发生在联合主键的情况下</p><p>除主键之外的其他列，只依赖与主键的部分字段：<strong>拆表</strong></p><h3 id="第三范式">0.6.3. 第三范式</h3><p>必须满足第二范式</p><p><strong>除主键列的其他列之间不能用传递依赖关系</strong></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_basis_start</title>
    <link href="/gzguo/2019/08/16/java/basis/start/"/>
    <url>/gzguo/2019/08/16/java/basis/start/</url>
    
    <content type="html"><![CDATA[<h4 id="运行情况、符号和数据类型">0.0.0.1. 运行情况、符号和数据类型</h4><span id="more"></span><h1 id="java程序的运行">1. java程序的运行</h1><p>机器语言、汇编语言、高级语言</p><h2 id="计算机高级语言的类型">1.1. 计算机高级语言的类型</h2><p>语言类型可以分为编译型和解释型</p><p>定义：<br>编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。<br>解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！<br>区别：<br>编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。<br>解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。</p><p>特点：</p><p>编译型语言，代码运行之后不能修改，除非重新运行修改后的代码</p><p>解释型语言，每行代码都可以单独运行，可以一边编程一边运行</p><p>代表：</p><p>编译型语言，c++、c（源码被编译完之后直接给系统）</p><p>解释型语言，javascript、Python、Php</p><p>脚本语言：javascript、Python、Php</p><p>编译语言：java</p><p>标记语言：Html、xml</p><p>探究java：</p><p>java程序的执行过程：</p><ol><li>编译源代码xxx.java</li><li>编译xxx.java文件生成字节码文件xxx.class</li><li>JVM中的类加载器加载字节码文件</li><li>JVM中的执行引擎找到入口方法main()，执行其中的方法</li></ol><p>javac程序是Java编译器，它可以将文件编译成.class文件，并发送到java虚拟机，让虚拟机来执行编译器放在class文件中的字节码。</p><p><img src="/images/20180731134336249.png" alt="JVM加载class文件的原理机制"></p><p>类加载器把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件。然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可以用。当类被加载后就进入连接阶段，这一阶段包括验证、准备和解析三个步骤。最后是JVM对类进行初始化（ 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类; 2)如果类中存在初始化语句，就依次执行这些初始化语句。 ） 类加载器包括:根加载器(BootStrap)、扩展加载器(Extension)、 系统加载器(System)和用户自定义类加载器(java.lang.ClassLoader 的子类) 。类加载器在JVM中。</p><p><a href="https://www.jianshu.com/p/8743d8062bb6">类加载器的介绍</a></p><p>JVM的一些基础知识：</p><p>JVM运行的是字节码文件，只要是这种格式的文件就行，所以，时间上JVM并不像我之前想象的那样与java语言紧紧的捆绑在一起</p><p>字节码文件简单强大，他存放了这个类的各种信息：字段、方法、父类、实现的接口等各种信息</p><p>JVM在执行java程序的过程中会把它所管理的内存分为如干个不同的区域，这些区域都有各自的用途</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">虚拟机中的区域：</span><br><span class="hljs-comment">    1、程序计数器：可以看作是当前线程所执行的字节码的行号指示器（指示当前线程，所以是线程私有的），字节码解释器工作时需要通过改变这个程序计数器的值来选取下一条所需要执行的字节码指令，循环、跳转、异常处理、线程恢复等基础功能都要依赖它来完成。</span><br><span class="hljs-comment">    2、JVM栈：描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接和方法出口等信息。每一个方法从调用直到执行完成的过程，就对应一个栈帧从虚拟机栈中入栈到出栈的过程。</span><br><span class="hljs-comment">    3、本地方法栈：虚拟机栈执行的是Java方法（也就是字节码）服务，而本地方法栈则为虚拟机所使用到的Native方法服务。</span><br><span class="hljs-comment">    4、堆：是被所有线程共享的一块区域，在虚拟机创建是创建，此内存的唯一目的是存放对象实例，它也是垃圾收集器管理的主要区域。</span><br><span class="hljs-comment">    5、方法区：也是所有线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>JVM的功能模块主要包括类加载器、执行引擎和垃圾回收系统。 </p><p><img src="/images/QQ%E5%9B%BE%E7%89%8720191106162305.png" alt="java的Write Once，Run Anywhere"></p><p>java是编译型语言和解释型语言的结合（源码文件（.java）被编译为class文件（字节码文件）然后被JRE处理（类加载器、字节码校验器、解释器（虚拟机）））最后JRE给了系统*<strong>java–&gt;JVM–&gt;底层操作系统，经过这么一个中介我们java避免了与操作系统直接打交道，这样实现跨平台的核心机制（JRE是java运行时环境，包括了虚拟机JVM）</strong>。</p><p>这里我们注意一下，上面是网上的言论，如果是纯粹的java(不谈虚拟机)，那么java是编译型语言，纯粹的编译型语言，只不过他把代码经过编译之后生成字节码文件交给了JVM，由JVM进行解释</p><p>谈到JVM，不得不谈JRE和JDK：</p><p>JVM 是java虚拟机。JVM的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，保护用户免被恶意程序骚扰。 JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的 组成包括 JVM 指令集，符号表以及一些补助信息。<br>JRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 在JDK的安装目 录里你可以找到jre目录，里面有两个文件夹bin和lib,在 这里可以认为bin里的就是jvm，lib中则是jvm工 作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件 和jre一起打包发给朋友，这样你的朋友就 可以运行你写程序了。（jre里有运行.class的java.exe）</p><p>JDK是java开发工具包。一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包 含JVM。</p><p> 1.bin:最主要的是编译器(javac.exe)<br> 2.include:java和JVM交互用的头文件<br> 3.lib:类库<br> 4.jre:java运行环境<br>注意：这里的bin、lib文件夹和jre里的bin、lib是 不同的，总的来说JDK是用于java程序的开发,而jre则 是只能运行class而没有编译的功能。eclipse、idea等 其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你 选中jre路径就ok了。</p><p><a href="https://blog.csdn.net/axi295309066/article/details/60469630">JDK、JRE、JVM</a></p><p>最后不得不谈到javac和java命令：</p><p>javac是编译器，把java文件编译生成class文件；java是虚拟机，java把class文件运行了，得到了最终的Hello World!</p><p>javaw和java都是java虚拟机，下面我们讨论一下两者之间的区别：</p><p>javaw运行程序时不会输出控制台信息，如果是双击打开jar文件的话，那么根本就不会出现控制台窗口，主要用来运行带窗体的应用程序，其中”w”的意思就是window的意思，所以用它来运行控制台程序虽然不会报错，但不会输出任何结果。而java无论运行控制台程序，还是执行窗体程序都没有任何问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//控制台程序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/QQ%E5%9B%BE%E7%89%8720191106170952.png" alt="javac和java"></p><p>如果运行的是GUI程序：</p><ol><li>如果用cmd的方式打开jar文件，由System.out.println的代码，java会正常输出，而javaw就不会输出，但控制台窗口都不会消失</li><li>如果是右键运行jar文件的话，那么用java打开文件还会保留一个控制台窗口，javaw则不会出现，所以运行窗体程序一般都用javaw</li></ol><h2 id="高级语言">1.2. 高级语言</h2><p>安卓开发：<strong>Kotlin</strong></p><p>苹果（IOs）开发：<strong>Objective-C</strong>、<strong>Swift</strong></p><p> <strong>Fortran</strong>世界上第一种高级语言IBM公司提出的</p><p><strong>Basic</strong>、<strong>COBOL</strong>、<strong>Pasacl</strong>都是老一辈的开发语言</p><p><strong>java</strong>：称之为c++-，广泛用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。IBM、Oracle、Sun（被Oracle收购）都支持java，形成了一个生态体系，主要是因为Java的开源性。java的优势：跨平台/可移植性、多线程、分布式、高性能、健壮性</p><p><strong>Python</strong>：蟒蛇，又称之为胶水语言（可以和c、c++整合），广泛应用于：图形处理、科学计算、web编程、多媒体应用、引擎开发；尤其是在未来大热方向机器学习和人工智能上有非常大的潜力</p><p><strong>c语言</strong>、**c++<strong>、</strong>c#**都很优秀，所有的语言都是c发展而来的</p><p><strong>php</strong>是世界上最好的语言，用于大型web开发</p><p><strong>javascript</strong>：用于前端页面渲染</p><h1 id="java标识符、关键字、变常量">2. java标识符、关键字、变常量</h1><p>在介绍这些之前先简单介绍一下java的命名规范：</p><ol><li><p>项目名全部小写</p></li><li><p>包名全部小写</p></li><li><p>类名<strong>首字母大写</strong>，如果类名由多个单词组成，每个单词的首字母都要大写</p></li><li><p>变量名、方法名首字母小写，如果名称由多个单词组成，<strong>每个单词的首字母都要大写</strong></p></li><li><p><strong>常量名全部大写</strong></p></li><li><p>所有命名规范必须遵循以下规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.名称只能由字母、数字、下划线、$符号组成</span><br><span class="hljs-comment">2.不能以数字开头</span><br><span class="hljs-comment">3.名称不能使用JAVA中的关键字</span><br><span class="hljs-comment">4.坚决不允许出现中文及拼音命名</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><p>提到命名规范，就要提到注释规范：</p><ol><li><p>类注释：在每个类前面必须加上注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* FileName: Test.java</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 类的详细说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 类创建者姓名</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@Date</span>    创建日期</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.00</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>属性注释：在每个属性前面必须加上属性注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 提示信息 */</span><br></code></pre></td></tr></table></figure></li><li><p>方法注释：在每个方法前面加上方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 类方法的详细使用说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> 参数1 参数1的使用说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> 返回结果的说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> 异常类型.错误代码 注明从此类方法中抛出异常的说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>构造方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 构造方法的详细使用说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> 参数1 参数1的使用说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> 异常类型.错误代码 注明从此类方法中抛出异常的说明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>方法内部注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在方法内部使用单行或多行注释，该注释根据实际情况添加</span><br><span class="hljs-comment">//如：背景颜色</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="标识符">2.1. 标识符</h2><blockquote><p>变量名(方法名)、类名、常量名中用到了大写字母，项目名、包名小写</p><p>所有参与命名的必须是字母、数字、下划线、$，且不能以数字开头</p></blockquote><p>标识符定义：</p><ol><li>java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li><li>凡是自己可以起名字的地方都叫标识符</li></ol><p>如Welcome、main、System、age、name、gender等。</p><p>标识符需要遵守一定的规则：</p><ul><li>标识符必须以字母、下划线_、美元符号$开头</li><li>标识符其他部分可以是字母、下划线、美元符和数字的任意组合</li><li>java标识符大小写敏感，且长度无限制</li><li>标识符不可以是关键字</li></ul><p><a href="https://blog.csdn.net/renrenzhong/article/details/53983348">java标识符定义及其规则规范</a></p><h3 id="标识符的使用规范">2.1.1. 标识符的使用规范</h3><ul><li>表示类名的标识符：每个单词的首字母大写，如Man，GoodMan</li><li>表示<strong>方法</strong>和<strong>变量</strong>的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为”驼峰原则”，如eat()，eatFood()</li><li>注意：java不采用通常语言使用的ASCII字符集，而是使用Unicode这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符</li></ul><h2 id="关键字-保留字">2.2. 关键字/保留字</h2><p>定义：Java的关键字对Java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><p>java关键字是保留供内部使用的，如class用于定义类。关键字也可以称为保留字，他们的意思是一样的，我们不能使用关键字作为变量名或方法名</p><p>分类：</p><ol><li>访问控制 private、protected、public</li><li>类、方法和变量修饰符 abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li><li>程序控制 break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li><li>错误处理 try、catch、throw、throws、finally</li><li>包相关 import、package</li><li>基本类型 boolean、byte、char、double、float、int、long、short、null、true、false</li><li>变量引用 super、this、void</li><li>保留字 goto、const</li></ol><p>注意一下：final和abstract是对立的，abstract意味着必须扩展类，final意味着不能扩展类。一个方法不能同时是abstract又是final。abstract意味着必须重写方法，final意味着不能重写方法。两者互相矛盾。</p><p>介绍一下native(本地)：</p><p>native关键字可以用于方法，以指示该方法是用java以外的语言实现的，方法对应的实现不是在当前文件，而是在用其他语言实现的文件中</p><p>java不是完美的，Java的不足除了体现在运行速度上要比传统的c++慢许多之外，java无法访问到操作系统底层，为此java使用native方法来扩展java程序的功能</p><p>可以将native方法比作java程序同c程序的接口，其实现步骤：</p><ol><li>在java中声明native方法，然后编译</li><li>用javah产生一个.h文件</li><li>写一个.cpp文件实现native方法，其中需要包含第二部产生的.h文件</li><li>将第三步的.cpp文件编译成动态链接库文件</li><li>在java中使用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在java中被访问了</li></ol><p>介绍一下new：</p><p>new关键字用来创建类的新实例</p><p>new关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数(必须带括号)。参数集合必须与类的构造方法的参数匹配，=赋值符号的左边变量的类型必须要与实例化的类或接口具有赋值兼容关系</p><p>介绍一下static：</p><p>static修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态成员变量；一个对象对该类静态成员变量进行修改，其他对象的该静态成员变量的值也会发生变化。如果一个成员变量是static的，那么我们可以通过”类名.成员变量名”的方式来使用这个变量</p><p>static修饰方法：static修饰的方法叫做静态方法。对于静态方法来说，可以使用”类名.方法名”的方式来访问该静态方法。静态方法只能继承，不能重写(Override)，因为重写是用于表现多态的，重写只能适用于实例方法，而静态方法是可以不生成实例直接用类名来调用的。这就会与重写的定义冲突，与多态所冲突，所以静态方法不能重写，只能是隐藏</p><p>static方法与非static方法：不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态变量。可以在非静态方法中访问静态的成员变量。因为静态方法可以直接用类名来调用，而非静态成员变量是在创建对象实例时才为变量分配内存空间和初始化变量值的。</p><p>不能在静态方法中使用this关键字。因为静态方法可以直接用类名来调用，而this实际上是创建实例时，实例对象的一个应用，所以不能在静态方法中使用this</p><p>static修饰代码块：静态代码块。静态代码块的作用也是完成一些初始化工作。首先执行静态代码块，然后执行构造方法。静态代码块在类加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到java虚拟机上，然后又jvm加载这个类来生成对象</p><p>类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所以静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以new一次就会调用构造方法一次。如果继承体系中既有构造方法，又有静态代码块，那么首先执行的最顶层的类的静态代码块，一直执行到最底层的类的静态代码块，然后去执行最顶层的类的构造方法，一直执行到最底层的类的构造方法。注意：静态代码块只会执行一次</p><p>static修饰类：这个优点特殊，首先，static是可以用来修饰类的，但是static是不允许用来修饰普通类，只能用来修饰内部类，被static修饰的内部类可以用new关键字来直接创建一个实例，不需要线创建外部类的实例。static内部类可以被其他类实例化和引用</p><p>其实理解起来很简单。因为static主要是修饰类里面的成员，包括内部类、属性和方法这些。修饰这些变量的目的也很单纯，那就是暗示这个成员在该类中时唯一的一份拷贝，即便时不断的实例化该类，所有的这个类的对象都会共享这些static成员。这样就好办了。因为是共享的、唯一的，所以，也就不需要在实例化这个类以后再通过这个类的对象来调用这个成员了，显然可以直接通过类名调用。然而这样设计之后，就出现了一个限制，就是static方法之中不能访问非static属性，因为这个时候非static属性可能还没有给他分配内存，该类还没有实例化</p><p><a href="http://cyw3.github.io/YalesonChan/2016/Java-key.html">关键字详解</a></p><h2 id="变量">2.3. 变量</h2><h3 id="变量的本质">2.3.1. 变量的本质</h3><ul><li>变量的本质上就是代表一个“可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可以通过变量名来访问”对应的存储空间“，从而操纵这个”存储空间“存储的值。</li><li>java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。比如，int a=3;表示变量a变量的空间大小为4个字节。</li><li>变量作为程序中最基本的存储单元，其要素包括变量名、变量类型和作用域。变量在使用前必须对其声明，只有在变量声明以后，才能为其分配相应长度的存储空间。</li><li>不同的数据类型的常量会在内存中分配不同的空间</li></ul><h3 id="注意事项">2.3.2. 注意事项</h3><ul><li>每个变量都会有类型，类型可以是基本类型，也可以是引用类型</li><li>变量名必须是合法的标识符</li><li>变量声明是一条完整的语句，因此每一个声明都必须以分号结束</li><li>方法中的变量必须声明、赋值之后才可以使用</li></ul><h3 id="变量的分类">2.3.3. 变量的分类</h3><ul><li><p><strong>局部变量</strong>：方法或语句块内定义的变量。生命周期从声明位置开始到方法语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//语句块</span><br>&#123;<br> <span class="hljs-keyword">int</span> age;   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>成员变量</strong>：(实例变量)方法外部、类的内部定义的变量。从属于对象，生命周期伴随着对象始终。如果不自行初始化，他会自动初始化成该类型的默认初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> b = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;\u0000&#x27;</span>;<br>boolen = <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态变量</strong>：(类变量)方法外部、类的内部定义的变量。使用static定义，从属于类，生命周期伴随类始终，从类加载到卸载(通常系统启动时会把相应的类进行加载，系统结束的时候卸载这些类)，如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始化值</p></li></ul><h2 id="常量-Constant">2.4. 常量(Constant)</h2><p>常量一旦被赋值就不能被改变</p><p>通过添加关键字final可以将一个变量转变成符号常量</p><p>通常1，2，3，’a’这些称之为字面常量</p><h2 id="变量和常量命名规范">2.5. 变量和常量命名规范</h2><ol><li>所有的变量、方法名、类名：见名知义</li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则</li><li>方法名首字母小写和驼峰原则</li></ol><h1 id="java数据类型">3. java数据类型</h1><h2 id="数据类型的分类">3.1. 数据类型的分类</h2><p>基本数据类型：(primitive data type)：</p><ul><li>数值型：byte(1 byte)、short(2 byte)、int(4 byte)、long(8 byte)、float(4 byte)、double(8 byte)</li><li>字符型：char(2 byte)</li><li>布尔型：boolean(1 bit)</li></ul><p>1 byte(字节) = 8 bit(位)</p><p>引用数据类型：(引用对象和变量，4byte)</p><ul><li>类(class)</li><li>接口(interface)</li><li>数组</li></ul><h2 id="整形变量-常量">3.2. 整形变量/常量</h2><ul><li>byte(1 byte)</li><li>short(2 byte)</li><li>int(4 byte)</li><li>long(8 byte)</li></ul><h3 id="整型常量的四中表示形式">3.2.1. 整型常量的四中表示形式</h3><ul><li>十进制整数：99</li><li>八进制整数，要求以0开头：015</li><li>十六进制数，要求以0x或0X开头，0x15</li><li>二进制数，要求0b或0B开头，0b01110011</li></ul><p>整型常量默认为int类型，整型常量后面要加L/l才表示这是一个long类型的常量。这里涉及到了类型转换的问题</p><h2 id="浮点变量-常量">3.3. 浮点变量/常量</h2><ul><li>十进制数形式：3.14</li><li>科学计数法形式：314e2(31400)、314E2(31400)、314E-2(3.14)</li></ul><p>浮点常量的默认类型是double，浮点常量后面加F/f表示这是一个float类型的常量</p><p>浮点数是不精确的，一定不要用于比较。如果非要比较，可以引用java.math包下的两个有用类BigInteger、BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。</p><h2 id="字符型变量-常量">3.4. 字符型变量/常量</h2><p>2 byte</p><p>注意一下转义字符</p><p>看一下String</p><h2 id="布尔类型变量-常量">3.5. 布尔类型变量/常量</h2><p>占 1 bit</p><p>布尔类型有两个常量值：true和false，不可以使用0或非0整数替代true和false，这点和c语言不同。boolean类型用来判断逻辑条件，一般用于程序流程控制</p><h1 id="运算符">4. 运算符</h1><h2 id="运算符分类-operator">4.1. 运算符分类(operator)</h2><ul><li>算术运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>条件运算符</li><li>字符串连接符</li></ul><h2 id="算术运算符">4.2. 算术运算符</h2><h3 id="二元运算符">4.2.1. 二元运算符</h3><p>算术运算符中+、-、*、/、%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。</p><h4 id="二元运算符的运算规则">4.2.1.1. 二元运算符的运算规则</h4><h5 id="整数运算">4.2.1.1.1. 整数运算</h5><ol><li>如果两个操作数有一个为Long，则运算结果也为Long</li><li>没有Long时，结果为int。即使操作数全为short、byte，结果也是int</li></ol><h5 id="浮点运算">4.2.1.1.2. 浮点运算</h5><ol><li>如果有一个数为浮点，则结果为浮点</li><li>如果两个操作数有一个是double，则结果为double</li><li>只有两个操作数都为float，则结果才为float</li></ol><h5 id="取模运算">4.2.1.1.3. 取模运算</h5><ol><li>其操作数可以为浮点数，一般使用整数，结果是余数，余数符号和左边操作数相同，如7%3=1，-7%3=-1，7%-3=1</li></ol><h2 id="一元运算符">4.3. 一元运算符</h2><p>自增、自减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> b = a++; <span class="hljs-comment">//执行完后b=3，先给b赋值，再自增</span><br>a = <span class="hljs-number">3</span>;<br>b = ++a; <span class="hljs-comment">//执行完后b=4，a先自增，再给b赋值</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符及扩展赋值运算符">4.4. 赋值运算符及扩展赋值运算符</h2><p>赋值运算符：=</p><p>扩展赋值运算符：+=、-=、*=、/=、%=</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a *= b + <span class="hljs-number">3</span>; <span class="hljs-comment">//相当于a = a * (b + 3)，始终先算后面的结果</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符">4.5. 关系运算符</h2><p>==、!=、&gt;、&lt;、&gt;=、&lt;=</p><h3 id="注意事项-1">4.5.1. 注意事项</h3><ul><li>=是赋值运算符，而真正的判断两个操作数是否相等的运算符是==</li><li>==、!=是所有(基本类型、引用类型)数据类型都可以使用</li><li>&lt;、&lt;=、&gt;、&gt;= 仅针对数值类型(byte、short、int、long，float、double，以及char)</li></ul><h2 id="逻辑运算符">4.6. 逻辑运算符</h2><ul><li>逻辑与：&amp; 操作两个布尔值，两个都是true才是true</li><li>逻辑或：| 操作两个布尔值，有一个是true就是true</li><li>短路与：&amp;&amp; 操作两个布尔值，只要有一个false，就直接返回false</li><li>短路或：|| 操作两个布尔值，只要有一个true，就直接返回true</li><li>逻辑非：! 操作一个布尔值，true就是false</li><li>逻辑异或：^ 操作两个布尔值，两个值相同就是false</li></ul><h2 id="位运算符">4.7. 位运算符</h2><ul><li><p>~：取反</p></li><li><p>&amp;：按位与 3&amp;4 (0011&amp;0100：0000)</p></li><li><p>|：按位或</p></li><li><p>^：按位异或</p></li><li><p>&lt;&lt;：左移运算符，左移一位相当于乘2</p></li><li><p>(&gt;&gt;)：右移运算符，右移一位相当于除2取商</p></li><li><p>```java<br>int a = 3 &lt;&lt; 2;<br>//a的值是12</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">## 字符串连接符</span><br><br>+：如果左右两边有一个是字符串，那么+就是字符串连接符<br><br>```java<br>String a = <span class="hljs-string">&quot;3&quot;</span>;<br>int b = <span class="hljs-number">4</span>;<br>int c = <span class="hljs-number">5</span>;<br>char d = <span class="hljs-string">&#x27;a&#x27;</span>;<br>a + b; <span class="hljs-regexp">//</span>结果为<span class="hljs-number">34</span><br>a + c; <span class="hljs-regexp">//</span>结果为<span class="hljs-number">35</span><br>a + b + c; <span class="hljs-regexp">//</span><span class="hljs-number">345</span> 因为从左到右依次计算<br>b + c + a; <span class="hljs-regexp">//</span><span class="hljs-number">93</span><br>d + <span class="hljs-number">4</span>; <span class="hljs-regexp">//</span><span class="hljs-number">101</span> <span class="hljs-string">&#x27;a&#x27;</span>=<span class="hljs-number">97</span>,<span class="hljs-number">97</span>+<span class="hljs-number">4</span>=<span class="hljs-number">101</span>,这里是算术运算符，不是字符串连接符<br></code></pre></td></tr></table></figure></li></ul><h2 id="条件运算符">4.8. 条件运算符</h2><p>x:y:z</p><p>其中x为boolean表达式，先计算x的值，若为true，则整个运算结果为表达式y的值。否则整个运算结果为表达式z的值，他是三目运算符</p><h2 id="运算符的优先级">4.9. 运算符的优先级</h2><p><a href="https://blog.csdn.net/xiaoli_feng/article/details/4567184">优先级</a></p><h3 id="一些建议">4.9.1. 一些建议</h3><ul><li>不需要去刻意的去记这些优先级，表达式里面有限使用小括号来组织</li><li>逻辑与、逻辑或、逻辑非的优先级：逻辑非&gt;逻辑与&gt;逻辑或</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_mysql_end</title>
    <link href="/gzguo/2019/08/16/java/mysql/end/"/>
    <url>/gzguo/2019/08/16/java/mysql/end/</url>
    
    <content type="html"><![CDATA[<h4 id="mysql事务">0.0.0.1. mysql事务</h4><span id="more"></span><h2 id="mysql事务-1">0.1. mysql事务</h2><p>mysql中，事务其实是一个最小的不可分割的单元，事务能保证一个业务的完整性</p><p>比如我们的银行转账</p><p>a –&gt;-100</p><p>update user set money = money - 10 where name = ‘a’;</p><p>b –&gt;+100</p><p>update user set money = money + 10 where name = ‘b’;</p><p>实际的程序中：如果只有一条语句执行成功，而另外一条没有执行成功出现数据前后不一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>多条sql语句，可能会有同时成功的要求，不然的话就同时失败</p><h2 id="mysql如何控制事务：">0.2. mysql如何控制事务：</h2><p>1.mysql默认是开启事务的(自动提交)</p><p>mysql&gt; select @@autocommit;<br>+————–+<br>| @@autocommit |<br>+————–+<br>|            1 |<br>+————–+<br>1 row in set (0.03 sec)</p><p>默认事务开启的作用是：当我们去执行sql语句的时候，效果会立刻体现出来且不能回滚</p><p>create database bank;</p><p>mysql&gt; create table user(<br>    -&gt; id int primary key,<br>    -&gt; name varchar(20),<br>    -&gt; money int<br>    -&gt; );<br>Query OK, 0 rows affected (0.04 sec)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>事务回滚：撤销sql语句执行效果</p><p>即使执行了rollback，仍然回不到插入数据之前，说明现在不能回滚，有什么办法可以反悔呢？</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 rows in set (0.04 sec)</p><p>有什么办法可以反悔呢？</p><p><u><em>设置mysql自动提交为false：<strong>set autocommit = 0;</strong></em></u></p><p>上面的操作关闭了mysql的自动提交（commit）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.03 sec)</p><p>mysql&gt; <u><em>rollback;</em></u><br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>+—-+——+——-+<br>1 row in set (0.02 sec)</p><p>现在可以取消插入的操作了</p><p>mysql&gt; insert into user values(2,’b’,1000);<br>Query OK, 1 row affected (0.01 sec)</p><p>mysql&gt; <u><em>commit;</em></u><br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.03 sec)</p><p><em><u>事务：自动提交 autocommit = 1</u></em></p><p><em><u>手动提交 自己打commit命令</u></em></p><p><em><u>事务回滚 rollback</u></em></p><p>如果说这个时候转账</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;                                                                                               <br>update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>mysql&gt; update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.05 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>事务给我们提供一个反悔的机会</p><h2 id="begin-或者start-transaction">0.3. begin;或者start transaction</h2><p>;都可以帮我们手动开启一个事务</p><p>mysql&gt; update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p><strong>begin;</strong> 手动开启事务（start transaction）                                                                                                                                                                            </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;                                                                                               <br>update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>mysql&gt; begin;                                                                                                                                                                                      update user set money = money - 10 where name = ‘a’;                                                                                               update user set money = money + 10 where name = ‘b’;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   980 |<br>|  2 | b    |  1020 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——+——-+<br>| id | name | money |<br>+—-+——+——-+<br>|  1 | a    |   990 |<br>|  2 | b    |  1010 |<br>+—-+——+——-+<br>2 rows in set (0.04 sec)</p><p>注意事务开启之后，一旦commit（提交），就不可以回滚（事务在提交的时候就结束了）</p><h2 id="事物的特征：">0.4. 事物的特征：</h2><p>事物的四大特征：</p><p>1.原子性（A）：事务是最小的单位，不可再分割</p><p>2.一致性（C）：事务要求，同一事务的sql语句，必须保证同时成功或者同时失败</p><p>3.隔离性（I）：事务1和事务2之间是具有隔离性的</p><p>4.持久性（D）：事务一旦结束（commit，rollback），就不可返回</p><p>事务开启：</p><p>1.修改默认提交：set sutocommit = 0;</p><p>2.begin;</p><p>3.start transaction;</p><p>事务手动提交：commit;</p><p>事务手动回滚：rollback;</p><h3 id="事物的隔离性">0.4.1. 事物的隔离性:</h3><p>1.read uncommitted;   读未提交的</p><p>2.read committed;   读已提交的</p><p>3.repeatable read;   可以重复读</p><p>4.serializable;   串行化</p><h4 id="1-read-uncommitted">0.4.1.1. 1.read uncommitted;</h4><p>如果有事务a和事务b，a事务对数据进行操作，事务没有被提交，但是b可以看到a操作的结果</p><p>bank数据库 user表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;淘宝店&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>小明去淘宝店买东西，淘宝店查看钱是否到账？</p><p>如何查看数据库的隔离级别？</p><p>mysql8.0</p><p>系统级别：</p><p>select @@global.transaction_isolation;</p><p>会话级别：</p><p>select @@transaction_isolation;</p><p>mysql&gt; select @@global.transaction_isolation;</p><p>mysql默认隔离级别：</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| REPEATABLE-READ                |<br>+——————————–+<br>1 row in set (0.04 sec)</p><p>mysql 5.x</p><p>select @@global.tx_isolation;</p><p>select @@tx_isolation;</p><p>如何修改隔离级别？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global transaction isolation level <span class="hljs-built_in">read</span> uncommitted;<br></code></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level read uncommitted;<br>Query OK, 0 rows affected (0.02 sec)</p><p>mysql&gt; select @@global.transaction_isolation;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-UNCOMMITTED               |<br>+——————————–+<br>1 row in set (0.04 sec)</p><p>好了开始转帐，小明买鞋子：800块钱</p><p>小明》》城都 ATM</p><p>淘宝店》》广州 ATM</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.05 sec)</p><p>start transaction;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money<span class="hljs-number">-800</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小明&#x27;</span>;<br><br>update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money<span class="hljs-operator">+</span><span class="hljs-number">800</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;淘宝店&#x27;</span>;<br></code></pre></td></tr></table></figure><p>mysql&gt; start transaction;</p><p>update user set money = money-800 where name = ‘小明’;</p><p>update user set money = money+800 where name = ‘淘宝店’;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |   200 |<br>|  4 | 淘宝店 |  1800 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>给淘宝店打电话，说你去查一下，是不是到账了</p><p>淘宝店在广州查账</p><p>发货</p><p>淘宝店晚上请女朋友吃好吃的</p><p>1800</p><p>小明rollback</p><p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>结账的时候发现钱不够</p><p>如果两个不同的地方，都在进行操作，如果事务a开启之后，他的数据可以被其他事务读取到</p><p>这样就会出现脏读</p><p>脏读：一个事务读取到另外一个事物没有提交的数据就叫做脏读</p><p>实际开发不允许脏读出现</p><h4 id="2-read-committed">0.4.1.2. 2.read committed;</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global transaction isolation level <span class="hljs-built_in">read</span> committed;<br><br>select @@global.transaction_isolation;<br></code></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level read committed;</p><p>select @@global.transaction_isolation;<br>Query OK, 0 rows affected (0.00 sec)</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-COMMITTED                 |<br>+——————————–+<br>1 row in set (0.03 sec)</p><p>bank数据库 user表</p><p>小张：银行的会计</p><p>start transaction;</p><p>select * from user;</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>+—-+——–+——-+<br>4 rows in set (0.04 sec)</p><p>小张上厕所去了。。。顺便抽烟</p><p>小王：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>commit;</p><p>mysql&gt; start transaction;</p><p>insert into user values(5,’c’,100);</p><p>commit;<br>Query OK, 0 rows affected (0.00 sec)</p><p>Query OK, 1 row affected (0.01 sec)<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; select * from user;<br>+—-+——–+——-+<br>| id | name   | money |<br>+—-+——–+——-+<br>|  1 | a      |   980 |<br>|  2 | b      |  1020 |<br>|  3 | 小明   |  1000 |<br>|  4 | 淘宝店 |  1000 |<br>|  5 | c      |   100 |<br>+—-+——–+——-+<br>5 rows in set (0.04 sec)</p><p>小张上完厕所抽完烟回来了，小王没有commit的时候，小张执行select * from user；</p><p>mysql&gt; select * from user;<br>+—-+———–+——-+<br>| id | name      | money |<br>+—-+———–+——-+<br>|  1 | a         |   980 |<br>|  2 | b         |  1020 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+—-+———–+——-+<br>5 rows in set (0.00 sec)</p><p>但是执行select avg(money) from user;</p><p>mysql&gt; select avg(money) from user;<br>+————+<br>| avg(money) |<br>+————+<br>| 820.0000   |<br>+————+<br>1 row in set (0.07 sec)</p><p>money的平均值不是1000，变少了</p><p>虽然我只能读到另一个事务提交的数据，但是还是会出现问题，就是读取同一个表的数据，发现前后不一致，这种不可重复读现象，read committed</p><h4 id="3-repeatable-read-可以重复读">0.4.1.3. 3.repeatable read;   可以重复读</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global transaction isolation level repeatable <span class="hljs-built_in">read</span>;<br><br>select @@global.transaction_isolation;<br></code></pre></td></tr></table></figure><p>mysql&gt; set global transaction isolation level repeatable read;</p><p>select @@global.transaction_isolation;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| REPEATABLE-READ                |<br>+——————————–+<br>1 row in set (0.03 sec)</p><p>张全蛋</p><p>start transaction;</p><p>insert into user values(6,’d’,1000);</p><p>张全蛋可以查到6号信息</p><p>王尼玛：</p><p>start transaction;</p><p>王尼玛查不到6号信息</p><p>但是王尼玛不能插入6号，会报错</p><p>这种现象叫做幻读</p><p>事务a和事务b同时操作一张表，事务a提交的数据，也不能读到，就可能造成幻读</p><h4 id="serializable-串行化">0.4.1.4. serializable:串行化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global transaction isolation level serializable;<br><br>select @@global.transaction_isolation;<br></code></pre></td></tr></table></figure><p>还是张全蛋和王尼玛，做了和上面一样的事</p><p>当user表被另外一个事务操作的时候，其他的事务是不可以执行的，进入排队状态，直到操作事务的那个人commit之后，才会执行</p><p>串行化commit之后，其他事务立刻执行，但时间长了，可能会失效</p><p>串行化问题：性能特差</p><p>read uncommitted &gt;read commited&gt;repeatable read&gt;serializable</p><p>隔离级别越高，性能越差</p><p>mysql默认隔离级别事 peteatable read</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_mysql_next</title>
    <link href="/gzguo/2019/08/16/java/mysql/next/"/>
    <url>/gzguo/2019/08/16/java/mysql/next/</url>
    
    <content type="html"><![CDATA[<h4 id="子查询">0.0.0.1. 子查询</h4><span id="more"></span><h2 id="select特殊功能：">0.1. select特殊功能：</h2><p>**distinct(排重)**：select distinct 字段名 from 数据表;</p><p><strong>between…and</strong>：select * from 数据表 where 字段名 between 值 and 值; 相当于select * from 数据表 where 字段名&gt;字段值 and 字段名&lt;字段值;</p><p><strong>in</strong>：select * from 数据表 where 字段名 in(85，86，87);</p><p><strong>or</strong>：select * from 数据表 where 字段名1 = ‘值’ or 字段名2 = ‘值’;(升序查询 asc从小到大)select * from 数据表 order by 字段名 asc; order by：系统默认是升序 desc降序（从大到小）</p><p>**count(统计)*<em>：select count(</em>) from 数据表 where 字段名 = 值; (聚合函数)</p><p>**avg(平均)**：select avg(字段名) from 数据表 where 字段名 = 值;(聚合函数)</p><p><strong>as</strong>：起别名</p><p>**like(%)**：模糊查询    %代表任意字段</p><p><strong>not like</strong>：模糊查询相反</p><p><strong>order by</strong>(降序查询  desc从大到小)：select * from 数据表 order by 字段名 desc;</p><p><strong>group by</strong>：需要和  <u><em>聚合函数</em></u>（例如：max（），count（），avg（）等）配合使用，使用时至少有一个分组标识字段（例如某一列的列名），分组标识的字段如果有多个相同的，那么搜索结果中只会出现第一次查到的这个字段的记录的信息，可以通过having</p><p><strong>having</strong>(分组条件)：作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p><p>可以包含<u><em>聚集函数</em></u>，但是where不能包含<u><em>聚集函数</em></u></p><p>**year(sbirthday)**：查询出生年份   year(now())：查看当前年份</p><p><strong>union</strong>：把两个查询的结果连接起来</p><p><strong>any</strong>：字段中 任意的某条记录</p><p><strong>all</strong>：字段中 所有的记录</p><p>*<em>count(</em>)**：函数返回由select语句返回的结果集中的行数</p><p>**max(字段名)**：字段中的最大值</p><p>**min(字段名)**：字段中的最小值</p><p><strong>查询字段中的最大最小</strong>：</p><p>一：（子查询）</p><p>select * from 数据表 where 字段名 = (select max(字段名) from 数据表);</p><p>1.找到最高分：select max(字段名) from 数据表;</p><p>2.根据最高分查询考生信息：select * from 数据表 where 字段名 = (select max(字段名) from 数据表);</p><p>二：（排序）</p><p>select * from 数据表 order by 字段名 desc limit 0,1;</p><p>limit：第一个数字是从多少条开始，第二个数字是查多少条</p><p>这个是降序，限制获得第一条，第一条就是最大的，获得最大值</p><p>注意：排序有缺陷，如果最大值有两条，她只能查到一条</p><p><strong>查询score表中至少有两名学生选修的并以3开头的课程的平均分数</strong></p><p><strong>having</strong>(分组条件)：having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> score <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(cno)<span class="hljs-operator">&gt;=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> cno <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;3%&#x27;</span>; <br></code></pre></td></tr></table></figure><p>  %代表的是任意的东西   3%代表以3开头的任意东西</p><h2 id="多表查询：">0.2. 多表查询：</h2><p><strong>精髓</strong>：他们是根据相等的地方进行联系的</p><p>两张表：</p><p>查询当条件相同时，把数据替换掉</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sname,cno,degree <span class="hljs-keyword">from</span> student,score <span class="hljs-keyword">where</span> student.sno <span class="hljs-operator">=</span> score.sno;<br></code></pre></td></tr></table></figure><p>三张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sname,cname,degree <span class="hljs-keyword">from</span> student,course,score <span class="hljs-keyword">where</span> student.sno <span class="hljs-operator">=</span> score.sno                                                                 <br><span class="hljs-keyword">and</span> course.cno <span class="hljs-operator">=</span> score.cno;<br></code></pre></td></tr></table></figure><h2 id="子查询：">0.3. 子查询：</h2><p><strong>精髓</strong>：分开步骤去查</p><p>查一个班的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查学生的分数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查一个班学生的平均成绩：                                                                     </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cno,<span class="hljs-built_in">avg</span>(degree)  <span class="hljs-keyword">from</span> score  <span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> sno <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>) <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno;<br></code></pre></td></tr></table></figure><p>查询选修3-105课程成绩高于109号同学3-105成绩的所有同学的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3-105&#x27;</span> <span class="hljs-keyword">and</span> degree<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> degree <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> sno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;109&#x27;</span> <span class="hljs-keyword">and</span> cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3-105&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查询成绩高于学号为109、课程号为3-105的成绩的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span><span class="hljs-operator">*</span> score <span class="hljs-keyword">where</span> degree<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> degree <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> sno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;109&#x27;</span> <span class="hljs-keyword">and</span> cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3-105&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查询与学号为108和101的同学同年出生的所有学生</p><p>查询学号为108和101的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span>(<span class="hljs-number">108</span>,<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><p>查询学号为108和101学生的出生年份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span>u<span class="hljs-operator">&gt;</span><span class="hljs-operator">*</span><span class="hljs-keyword">year</span>(sbirthday)<span class="hljs-operator">*</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>u<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span>(<span class="hljs-number">108</span>,<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span>(sbirthday) <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(sbirthday) <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span>(<span class="hljs-number">108</span>,<span class="hljs-number">101</span>));<br></code></pre></td></tr></table></figure><p>查询张旭教师任课的学生成绩：</p><p>教师表中查询tno：select tno from teacher where tname=’张旭’;</p><p>查询他任的课cno：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> cource <span class="hljs-keyword">where</span> tno<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> tno <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张旭&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> cno <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> cource <span class="hljs-keyword">where</span> tno<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> tno <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张旭&#x27;</span>));<br></code></pre></td></tr></table></figure><p>查询某课程的同学数多余5人的教师姓名：</p><p>课程数大于五的cno：select cno from score group by cno having count(*)&gt;5;</p><p>查询tno：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> tno <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> cno <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> score <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> tname <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tno <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> tno <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> cno<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> score <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> cno <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><p>查看计算机系和电子工程系不同职称的教师的tname和pref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> prof <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;电子工程系&#x27;</span> <span class="hljs-keyword">and</span> prof <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机系&#x27;</span>)<br></code></pre></td></tr></table></figure><p><u><em><strong>union</strong></em></u></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机系&#x27;</span> <span class="hljs-keyword">and</span> prof <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> prof <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;电子工程系&#x27;</span> );<br></code></pre></td></tr></table></figure><p>查询选修学号为3-105课程且成绩至少高于选修编号3-245的同学的Cno、Sno和Degree，并按Degree从高到底依次排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cno,sno,degree <span class="hljs-keyword">from</span> score                                         <br><span class="hljs-keyword">where</span> cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3-105&#x27;</span><br><span class="hljs-keyword">and</span> degree<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>u<span class="hljs-operator">&gt;</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-keyword">any</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>u<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> degree <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3-245&#x27;</span>)   <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> degree <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>   //从高到低</p><p>复制表数据做条件查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score a <span class="hljs-keyword">where</span> degree<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(degree) <span class="hljs-keyword">from</span> score b <span class="hljs-keyword">where</span> a.cno<span class="hljs-operator">=</span>b.cno);<br></code></pre></td></tr></table></figure><p>查询至少有两名男生的班级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> class <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> ssex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>按等级查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sno,cno,grade <span class="hljs-keyword">from</span> score,grade <span class="hljs-keyword">where</span> degree <span class="hljs-keyword">between</span> low <span class="hljs-keyword">and</span> upp;<br></code></pre></td></tr></table></figure><h2 id="sql的四种链接查询：">0.4. sql的四种链接查询：</h2><p><strong>内链接：</strong></p><p>inner join 或者 join</p><p><strong>外连接：</strong></p><p>1.左连接：left join 或者 left outer join</p><p>2.右连接：right join 或者 right outer join</p><p>3.完全外连接：full join 或者 full outer join</p><p>person表：id，name，cardId</p><p>card表：id，name</p><p>person表中的cardId来自于card表中的id</p><p>create table person(</p><p>​    id int,</p><p>​    name varchar(20),</p><p>​    cardId int</p><p>);</p><p>create table card(</p><p>​    id int,</p><p>​    name varchar(20)</p><p>);</p><p>insert into card values(1,’饭卡’);</p><p>insert into card values(2,’建行卡’);</p><p>insert into card values(3,’农行卡’);</p><p>insert into card values(4,’工商卡’);</p><p>insert into card values(5,’邮政卡’);</p><p>insert into person values(1,’张三’,1);</p><p>insert into person values(2,’李四’,3);</p><p>insert into person values(3,’王五’,6);</p><p>并没有创建外键，如果创建的话person里面的第三条数据插不进去</p><p><strong>inner join查询</strong>：(内连接)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person p <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> card c <span class="hljs-keyword">on</span> p.cardId <span class="hljs-operator">=</span> c.id;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person p, card c <span class="hljs-keyword">where</span> c.id <span class="hljs-operator">=</span> p.cardId;<br></code></pre></td></tr></table></figure><p>内联查询：其实就是相当于把两个表里面的数据，通过某个字段相对应，把有关系的数据查询出来</p><p>mysql&gt; select * from person p, card c where c.id = p.cardId;<br>+—-+——+——–+—-+——–+<br>| id | name | cardId | id | name   |<br>+—-+——+——–+—-+——–+<br>|  1 | 张三 |      1 |  1 | 饭卡   |<br>|  2 | 李四 |      3 |  3 | 农行卡 |<br>+—-+——+——–+—-+——–+</p><p>**left join:**（左外连接)outer</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> card <span class="hljs-keyword">on</span> person.cardId <span class="hljs-operator">=</span> card.id;<br></code></pre></td></tr></table></figure><p>左外连接：会把左边表里的数据全部取出来，而右边表里的数据有就显示出来，没有就会变成NULL</p><p>mysql&gt; select * from person left join card on person.cardId = card.id;<br>+—-+——+——–+——+——–+<br>| id | name | cardId | id   | name   |<br>+—-+——+——–+——+——–+<br>|  1 | 张三 |      1 |    1 | 饭卡   |<br>|  2 | 李四 |      3 |    3 | 农行卡 |<br>|  3 | 王五 |      6 | NULL | NULL   |<br>+—-+——+——–+——+——–+</p><p><strong>right join：</strong>(右外连接)outer</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> card <span class="hljs-keyword">on</span> person.cardId <span class="hljs-operator">=</span> card.id;<br></code></pre></td></tr></table></figure><p>左外连接：会把右边表里的数据全部取出来，而左边表里的数据有就显示出来，没有就会变成NULL</p><p>mysql&gt; select * from person right join card on person.cardId = card.id;<br>+——+——+——–+—-+——–+<br>| id   | name | cardId | id | name   |<br>+——+——+——–+—-+——–+<br>|    1 | 张三 |      1 |  1 | 饭卡   |<br>|    2 | 李四 |      3 |  3 | 农行卡 |<br>| NULL | NULL | NULL   |  2 | 建行卡 |<br>| NULL | NULL | NULL   |  4 | 工商卡 |<br>| NULL | NULL | NULL   |  5 | 邮政卡 |<br>+——+——+——–+—-+——–+</p><p><strong>full join：</strong>（全外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> card <span class="hljs-keyword">on</span> person.cardId <span class="hljs-operator">=</span> card.id;<br></code></pre></td></tr></table></figure><p>mysql&gt; select * from person full join card on person.cardId = card.id;<br>1054 - Unknown column ‘person.cardId’ in ‘on clause’</p><p>原因是mysql不支持full join</p><p><u><em>全外连接我们想要的结果：</em></u></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> card <span class="hljs-keyword">on</span> person.cardId <span class="hljs-operator">=</span> card.id          <br><span class="hljs-keyword">union</span>    <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> person <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> card <span class="hljs-keyword">on</span> person.cardId <span class="hljs-operator">=</span> card.id;     <br></code></pre></td></tr></table></figure><p>+——+——+——–+——+——–+<br>| id   | name | cardId | id   | name   |<br>+——+——+——–+——+——–+<br>|    1 | 张三 |      1 |    1 | 饭卡   |<br>|    2 | 李四 |      3 |    3 | 农行卡 |<br>|    3 | 王五 |      6 | NULL | NULL   |<br>| NULL | NULL | NULL   |    2 | 建行卡 |<br>| NULL | NULL | NULL   |    4 | 工商卡 |<br>| NULL | NULL | NULL   |    5 | 邮政卡 |<br>+——+——+——–+——+——–+                                                                   </p><p>连接的好处：<strong>可以不创建外键</strong></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_mybatis_start</title>
    <link href="/gzguo/2019/08/14/java/mybatis/start/"/>
    <url>/gzguo/2019/08/14/java/mybatis/start/</url>
    
    <content type="html"><![CDATA[<h4 id="mybatis使用不同方法进行增删改查">0.0.0.1. mybatis使用不同方法进行增删改查</h4><span id="more"></span><h2 id="对原生态jdbc程序问题的总结">0.1. 对原生态jdbc程序问题的总结</h2><p>（单独使用jdbc开发）</p><p>数据库用的时候连接，不用的时候释放，频繁操作   通过连接池节约资源</p><p>sql语句硬编码，不利于系统维护   使用配置文件把他配起来</p><h2 id="mybatis框架原理">0.2. mybatis框架原理</h2><h3 id="特点">0.2.1. 特点</h3><p>mybatis是持久层框架，是apache下的项目</p><p>mybatis让程序主要精力放在sql上，通过mybatis提供的映射方式，简化sql</p><p>mybatis将输入参数自动进行输入映射，将查询结果集映射成java对象</p><h3 id="mybatis框架">0.2.2. mybatis框架</h3><p>先完成基本配置：</p><p>SqlMapConfig.xml：是mybatis的全局配置文件（名称不固定）。配置了数据源（c3p0）、事务（spring）等mybatis运行环境。配置里有个特别的东西（mapper.xml）这个文件里是映射关系（配置sql语句）通过配置文件生成会话工厂（SqlSessionFactory）</p><p>操作数据库：</p><p>SqlSessionFactory（会话工厂）创建 -&gt;SqlSession（接口）：会话 作用：操作数据库（发出sql增删改查）内部通过执行器（Excutor接口）操作数据库,两种实现方式（基本执行器、缓存执行器）。</p><p>这个执行器需要很多参数，所以mybatis提供了一个<em>底层的封装对象（mapped statement）</em>作用：对数据库存储封装，包括sql语句，输入参数，输出结果类型，终于连接上了数据库</p><p>输入参数类型：pojo、java简单类型、hashmap</p><p>输出结果类型：pojo、java简单类型、hashmap</p><h2 id="mybatis入门程序">0.3. mybatis入门程序</h2><h3 id="增删改查">0.3.1. 增删改查</h3><p><em>lib下的一般是依赖包</em></p><h4 id="查询用户信息">0.3.1.1. 查询用户信息</h4><p>根据用户名称模糊查询用户信息</p><p><u>首先在映射文件中配置sql语句</u>   映射：（hibernate：orm：对象关系映射，实体类和数据表映射）咱们的xml映射分为输入映射、输出映射</p><p>映射文件名 :user.xml(ibatis)、xxxMapper.xml(mybatis)</p><p>namespace命名空间，sql的隔离</p><p>映射文件中的sql语句会封装到<em>mapped statement</em>对象中</p><p>在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;路径/xxxMapper.xml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>程序编写，创建会话工厂，连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//mybatis配置文件</span><br><br>String resource = <span class="hljs-string">&quot;sqlmap/SqlMapConfig.xml&quot;</span>;<br><br>得到配置文件的流<br><br>Resource.getResourceAsStream(resource);<br><br><span class="hljs-comment">//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流</span><br><br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br><br><span class="hljs-comment">//通过工厂得到会话SqlSession</span><br><br>SqlSession sqlSession = sqlSessionFactory.openSession();<br><br><span class="hljs-comment">//通过SqlSession操作数据库</span><br><br><span class="hljs-comment">//第一个参数：映射文件中的statement的id，等于=namespace+&quot;.&quot;+statement的id</span><br><br><span class="hljs-comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数</span><br><br>User user = sqlSession.selectOne(statement,parameter);<br><br><span class="hljs-comment">//提交事务</span><br><br>sqlSession.commit();<br><br><span class="hljs-comment">//释放资源</span><br><br>sqlSession.close();<br></code></pre></td></tr></table></figure><h5 id="sql语句的格式">0.3.1.1.1. sql语句的格式</h5><p>id：标识映射文件中的sql</p><p>将sql语句封装到mapped statement 对象中，所以id称为statement的id</p><p>parameterType：指定输入参数的类型</p><p>#{}表示一个占位符号</p><p>${}表示一个拼接符号，会引起sql注入（拼接的时候写where 1=1）</p><p>#{id}：其中的id表示接入输入的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意，可以实value或其他的名称都行</p><p>resultType：指定输出结果的类型，表示将单条记录映射成java对象</p><p>selectOne表示查询出1条记录进行映射</p><p>selectList表示查询出一个列表（多条记录）进行映射</p><h4 id="添加用户">0.3.1.2. 添加用户</h4><p>parameterType：指定输入参数类型是pojo（包括用户信息）</p><p>#{}中指定的pojo的属性名，接收到pojo对象的属性值OGNL获取对象的属性值</p><p>sql后面不要加;</p><p><strong>自增主键返回</strong>：执行insert提交之前自动生成一个自增主键。通过mysql函数获取到刚插入记录的自增主键（select last_insert_idid();）在inseert之后调用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span> = <span class="hljs-string">&quot;cn.itcast.mybatis.po.User&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">order：select last_insert_id()执行顺序，相对于insert语句来说他的执行顺序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">resultType:指定select last_insert_id()结果的类型--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br><br>    select last_insert_id();<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br><br>insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;adress&#125;)<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>非自增主键的返回</strong>：</p><p>mysql的uuid()函数生成主键，需要修改id字段类型的为String，长度设置为35位</p><p>执行思路：先通过uuid();查询到主键，将主键注入到sql语句中，执行uuid();语句顺序相对于insert语句之前执行</p><h4 id="删除用户">0.3.1.3. 删除用户</h4><p>sqlSession.update(statement,parameter);</p><p>sqlSession.delete(statement,parameter);</p><p>sqlSession.selectOne/List(statement,parameter);</p><p>sqlSession.insert(statement,parameter);</p><h4 id="更新用户">0.3.1.4. 更新用户</h4><h3 id="入门程序的总结">0.3.2. 入门程序的总结</h3><p>#{}表示一个占位符，接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中可以写成value或其他名称</p><p>#{}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值</p><p>${}表示一个拼接符，会出现sql注入，不建议使用。接受输入参数，类型可以是简单类型、pojo、hashmap，如果接受简单类型，#{}中只能写成value</p><p>${}接受pojo对象值，通过OGNL读取对象的属性值，通过属性.属性.属性…的方式获取属性值</p><h4 id="mybatis和hibernate本质区别和应用场景">0.3.2.1. mybatis和hibernate本质区别和应用场景</h4><p><strong>hibernate</strong>：入门门槛较高，是一个标准的ORM框架（对象关系映射），不需要程序员写sql，sql语句自动生成。对sql语句的优化、修改比较困难</p><p><strong>应用场景</strong>：适应于需求变化较少的中小型的项目，比如：后台管理系统，erp、orm、oa…</p><p><strong>mybatis</strong>：专注于sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，但是存在映射（输入映射、输出映射）</p><p><strong>应用场景</strong>：适应于需求项目较多的项目，比如：互联网项目</p><p>企业进行技术选型，以低成本、高回报作为技术选型的原则，根据项目组的项目力量进行选择</p><h2 id="mybatis开发dao的两种方法">0.4. mybatis开发dao的两种方法</h2><h3 id="SqlSession使用范围（单例）">0.4.1. SqlSession使用范围（单例）</h3><p>通过<strong>SqlSessionFactoryBuilder</strong>创建SqlSessionFactory，将SqlSessionFactoryBuilder当成一个工具类即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建工厂的时候只需要创建一次SqlSessionFactoryBuilder即可（因为下面的SqlSessionFactory是单例管理的）</p><p>通过<strong>SqlSessionFactory</strong>创建SqlSession，通过使用单例模式管理sqlSessionFactory（工厂一旦创建，就一直使用一个实例）</p><p>将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory</p><p>SqlSession：是一个面向用户（程序员）的接口提供了很多操作数据库的方法：如：selectOne、selectList。是线程不安全的，在SqlSession的实现类中，除了有接口中的方法（操作数据库的方法）、还有数据域的属性（多例不安全）。<em>SqlSession最佳的应用场合在方法体内，定义成局部变量</em></p><h3 id="原始dao开发方法">0.4.2. 原始dao开发方法</h3><h4 id="思路">0.4.2.1. 思路</h4><p><strong>需要编写dao接口和dao实现类</strong></p><p>需要向dao实现类中注入SqlSessionFactory，在方法体中通过SqlSessionFactory常见SqlSession</p><h4 id="dao接口">0.4.2.2. dao接口</h4><h4 id="dao接口实现类">0.4.2.3. dao接口实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需要向dao实现类中注入SqlSessionFactory</span><br><br>这里通过构造方法注入<br><br><span class="hljs-keyword">private</span> SqlSessionFactory sqlSessionFactory;<br><br><span class="hljs-keyword">public</span> 类名 (SqlSessionFactory sqlSessionFactory)&#123;<br><br><span class="hljs-keyword">this</span>.sqlSessionFactory = sqlSessionFactory;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/1565315234136.png"></p><p>@Befor是在测试类之前执行的类：需要创建会话工厂，供测试类通过构造器注入</p><p>@Text是测试类：创建UserDao这个实现类的时候，UserDaoImpl构造器需要一个sqlSessionFactory，有@Befor提供；创建成功后可以开始调用UserDao里面的方法</p><h4 id="总结原始dao开发的问题">0.4.2.4. 总结原始dao开发的问题</h4><p>1.dao接口的实现类的方法中存在大量的模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量</p><p>2.第一个参数：看这个蓝色的地方：是个硬编码（statement的id硬编码）</p><p>3.第二个参数的类型是泛型，即使传入参数错误，在编译阶段也不报错，不利于程序员开发</p><p><img src="/images/1565316318487.png"></p><h3 id="mybatis的mapper代理的开发方法">0.4.3. mybatis的mapper代理的开发方法</h3><p>程序员编写mapper.xml映射文件</p><p>程序员编写mapper接口（相当于dao接口）需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p>mybatis可以自动生成mapper接口实现类的代理对象</p><h4 id="开发规范">0.4.3.1. 开发规范</h4><p>1.在mapper.xml中namespace等于mapper接口的地址</p><p>2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致</p><p>3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致</p><p>4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致</p><h4 id="总结">0.4.3.2. 总结</h4><p>以上的开发规范主要是对下边的代码进行统一的生成</p><p>namespace变成了mapper.java的路径，mapper.java中的方法名是mapper.xml的staement的id，mybatis会自动拼接这两个东西生成原始Dao开发的第一个参数，第二个参数由第三条和第四条规范实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">User user = sqlSession.selectOne(<span class="hljs-string">&quot;namespace+statement的id&quot;</span>,占位符对应的输入参数);<br><br>sqlSession.insert(<span class="hljs-string">&quot;&quot;</span>,);<br><br><span class="hljs-comment">//开启会话，无论是什么开发，都得开启会话</span><br><br>SqlSession sqlSession = sqlSessionFactory.openSession();<br><br><span class="hljs-comment">//创建UserMapper对象,mybatis自动生成mapper代理对象</span><br><br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br><br>调用userMapper的方法<br></code></pre></td></tr></table></figure><p>注意：要在SqlMapConfig.xml中加载mapper.xml</p><h4 id="问题总结">0.4.3.3. 问题总结</h4><h5 id="代理对象内部调用selectOne或selectList">0.4.3.3.1. 代理对象内部调用selectOne或selectList</h5><p>如果mapper方法返回单个pojo对象（非集合对象），代理对象的内部通过selectOne查询数据库</p><p>如果mapper方法返回对象集合，代理对象内部通过selectList查询数据库</p><h5 id="mapper接口方法的参数个数">0.4.3.3.2. mapper接口方法的参数个数</h5><p>mapper接口方法的参数个数只能有一个，系统是否不利于系统维护</p><p>系统框架中，dao层的代码是被业务层共用的，即使mapper接口只有一个参数，可以使用包装类型的pojo瞒住不同业务方法的参数</p><p>注意：持久层中方法的参数可以用包装类型、map等，但是service方法中建议不要使用包装类型（不利于业务层的可扩展性）</p><h2 id="Mapper代理开发和dao原始开发总结">0.5. ***Mapper代理开发和dao原始开发总结</h2><h3 id="原始开发：">0.5.1. 原始开发：</h3><p>映射文件中的sql语句会封装到<em>mapped statement</em>对象中</p><p>在SqlMapConfig.xml中加载刚刚写好的xxxMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>   <br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;路径/xxxMapper.xml&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>程序编写，创建会话工厂，连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//mybatis配置文件</span><br><br>String resource = <span class="hljs-string">&quot;sqlmap/SqlMapConfig.xml&quot;</span>;<br><br>得到配置文件的流<br><br>Resource.getResourceAsStream(resource);<br><br><span class="hljs-comment">//创建会话工厂传入mybatis的配置文件信息，需要一个配置文件流</span><br><br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br><br><span class="hljs-comment">//通过工厂得到会话SqlSession，这个不论是怎么开发都必须有的</span><br><br>SqlSession sqlSession = sqlSessionFactory.openSession();<br><br><span class="hljs-comment">//通过SqlSession操作数据库</span><br><br><span class="hljs-comment">//第一个参数：映射文件中的statement的id，等于=namespace+&quot;.&quot;+statement的id</span><br><br><span class="hljs-comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷</span><br><br>User user = sqlSession.selectOne(statement,parameter);<br><br><span class="hljs-comment">//提交事务</span><br><br>sqlSession.commit();<br><br><span class="hljs-comment">//释放资源</span><br><br>sqlSession.close();<br></code></pre></td></tr></table></figure><p>自己配置SqlMapConfig.xml 和 mapper.xml</p><p>通过配置文件生成会话工厂（SqlSessionFactory）</p><p>通过会话工厂生成会话（SqlSession） </p><p>通过SqlSession操作数据库</p><p><strong>开发的流程：</strong></p><p>编写写sql的xml，在mybatis全局配置的xml中加载编写sql的xml</p><p><em>编写sql的xml里的namespace对应mapper.java的类的全路径，里面的sql的id对应类中的方法名（原始开发的第一个参数statementid）。mapper.java里面的方法入参和出参对应原始dao开发的第二个参数</em></p><h3 id="mapper代理开发">0.5.2. mapper代理开发</h3><h4 id="开发规范-1">0.5.2.1. 开发规范</h4><p>1.在mapper.xml中namespace等于mapper接口的地址</p><p>2.mapper.java接口中的方法名，和mapper.xml中的statement的id一致</p><p>3.mapper.java接口中的方法输入参数类型和mapper.xml中statement中的statement的parameterType指定的类型一致</p><p>4.mapper.java中的返回值类型和mapper.xml中的statement中的resultType指定的类型一致</p><p><strong>在原始开发中添加了开发规范，这些开发规范的作用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数：映射文件中的statement的id，等于=namespace+&quot;.&quot;+statement的id</span><br><br><span class="hljs-comment">//第二个参数：指定和映射文件中所匹配的parameterType类型的参数这里有缺陷，第二个参数是泛型</span><br><br>User user = sqlSession.selectOne(statement,parameter);<br></code></pre></td></tr></table></figure><p>第一条和第二条开发规范优化了SqlSession的第一个参数，系统可以自动拼接，不需要我们去传入了</p><p>第三条和第四条开发规范优化了SqlSession的第二个参数，可以判断他的parameterType和resultType，而不是原始开发中的泛型</p><h2 id="mybatis的配置文件SqlMapConfig-xml">0.6. mybatis的配置文件SqlMapConfig.xml</h2><p>mybatis的全局配置文件SqlMapConifig.xml，配置内容如下：</p><p>properties（属性)、setting（全局配置参数）、typeAliases（类型别名）、typeHandlers（类型处理器）、objectFactory（对象工厂）、plugins（插件）、environments（环境集合属性对象）（environment（环境子属性对象（transactionManager（事务管理）、dataSource（数据源））））、mappers（映射器）</p><h3 id="properties">0.6.1. properties</h3><p><strong>需求：</strong></p><p>将数据库连接的参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值（添加了一个配置文件），这样做的话，在SqlMapConfig.xml中就不需要对数据库的连接参数进行硬编码。</p><p>将数据库连接参数只配置在db.properties中的原因：方便对参数的统一管理，其他的xml可以引用改db.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SqlMapConfig.xml加载属性文件（db.properties）--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span> = <span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置数据库连接池--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span>&gt;</span><br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;$&#123;文件中的属性名称&#125;&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>properties特性：</strong></p><p>mybatis将按照下面的顺序来加载属性：</p><p>1.在properties元素体内定义属性首先被读取</p><p>2.然后会读取properties元素中resource或url加载的属性，他会覆盖已读取的同名属性</p><p>3.最后读取parameterType传递的属性，他会覆盖已读取的同名属性</p><p>因此，通过parameterType传递的属性具有最高优先级，resource或url加载的属性次之，最低优先级是properties元素体内定义的属性</p><p>建议：不要再properties元素体内添加任何属性值，只将属性值定义在properties文件中，在properties文件中定义属性名要有一定的特殊性，如xxx.xxx</p><h3 id="settings全局参数配置">0.6.2. settings全局参数配置</h3><p>mybatis运行时可以调整一些运行参数</p><p>比如：开启二级缓存，开启延迟加载</p><p><img src="/images/1565343104480.png"></p><p>这些参数会影响mybatis的运行行为，如果操作不当，可能会导致运行出现问题</p><h3 id="typeAliases（别名）">0.6.3. typeAliases（别名）</h3><p><strong>需求：</strong></p><p>在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数类型、需要resultType指定输出结果的映射类型</p><p>如果在指定类型的时候输入类型全路径，不方便进行开发，可以针对parameterType或ResultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发</p><p>mybatis有一些自己默认的别名，但是对于pojo需要自己定义别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br><br>​//单个别名的定义<br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;全路径名（pojo类的路径）&quot;</span> <span class="hljs-attr">alias</span> = <span class="hljs-string">&quot;别名&quot;</span> /&gt;</span><br><br>​//批量别名的定义<br><br>​指定包名，mybatis自动扫描包中的po类，别名就是类名（首字母大小写都可以）<br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;包名&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="typeHandlers（类型处理器）">0.6.4. typeHandlers（类型处理器）</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换</p><p>通常情况下，mybatis提供的处理器满足日常需要，不需要自定义</p><h3 id="mappers（映射配置）">0.6.5. mappers（映射配置）</h3><p>通过resource加载单个文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">maper</span> <span class="hljs-attr">class</span>/<span class="hljs-attr">resource</span>/<span class="hljs-attr">url</span>/ /&gt;</span><br><br><span class="hljs-comment">&lt;!--通过mapper接口加载映射文件，需要将mapper接口的类名和mapper.xml映射文件的名称保持一致，且在一个目录，上边规范的前提是使用mapper代理的方法--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">maper</span> <span class="hljs-attr">class</span> /&gt;</span>指定的不是映射文件，指定的是class<br><br>//批量加载mapper,指定mapper接口的包名，mybatis自动扫描包下的所有接口进行加载。这个遵循上面的规范<br><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="输入映射">0.6.5.1. 输入映射</h4><p>通过parameterType指定输入参数类型，类型可以实简单类型、hashmap、pojo的包装类型</p><p><strong>传递pojo的包装对象</strong>：</p><p>需求：完成用户信息的综合查询，需要传入查询条件很复杂（可能包含用户信息、其他信息，比如商品、订单的）</p><p>针对上面的需求建议使用自定义的pojo，自定义查询条件</p><h4 id="输出映射">0.6.5.2. 输出映射</h4><p><strong>resultType</strong>:</p><p>使用resultType进行输出映射，只有查询出来的列名和pojo的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。只要查询出来的列名和pojo中的属性有一个一致，就会创建一个pojo对象</p><p><strong>输出简单类型</strong>：用户信息的综合查询的列表总数，通过查询总数和上边用户综合查询列表才可以实现分页</p><p>小节：只有查询出来的只有一行且有一列才可以使用输出简单类型</p><p>输出pojo对象和pojo列表：不管输出的是pojo对象还是列表，在mapper.xml中resultType中指定的类型是一样的，但是在mapper.java中的返回值类型不一样（对象、集合），然后自动生成的mapper代理对象中是根据mapper方法的返回值类型确定是调用selectOne还是selectList</p><p><strong>resultMap</strong>：</p><p>mybatis中使用resultMap完成高级输出结果映射</p><p>使用方法：</p><p>如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间做一个映射关系</p><p>1.定义resultMap</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">//id是resultMAp的唯一标识<br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br>​//id表示查询结果的唯一标识 ，column sql语句中查询的列名，property：pojo中的属性名<br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">property</span> = <span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>resultMap：给定义的resultMap的id，如果这个resultMap在其他的mapper文档中，前边需要加namespace    </p><p>2.使用resultMap作为statement的输出映射类型</p><p>将下边的sql用UserCostom完成映射</p><p>userCustom类中的属性和上边的查询列名不一致</p><p><strong>小节</strong>：</p><p>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功，如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系</p><h4 id="动态sql">0.6.5.3. 动态sql</h4><h5 id="什么是动态sql">0.6.5.3.1. 什么是动态sql</h5><p>mybatis核心：对sql语句进行灵活的操作，通过表达式，对sql进行灵活判断，组装</p><p><strong>需求</strong>：</p><p>用户信息的综合查询列表和用户信息查询列表的总数 这两个statement的定义使用动态sql。对查询条件进行判断，查询条件不为空，我们才会对查询语句进行拼接</p><h5 id="if">0.6.5.3.2. if</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//可以去掉查询条件中的第一个and<br><br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><br>//判断条件<br><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">&quot;条件&quot;</span>&gt;</span>sql语句<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="foreach">0.6.5.3.3. foreach</h5><p>向sql传递数组或list，mybatis使用foreach解析</p><p>在用户查询列表和查询总数的statement中添加多个id输入查询</p><p>在输入参数类型中添加list<integer> ids传入多个id</integer></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">//使用foreach遍历传入的ids<br><br>//collections：指定输入对象中集合属性，item：每次遍历生成对象中的属性名，open：开始遍历时拼接的串，close：结束遍历时拼接串,separator:遍历的两个对象中间需要拼接的串<br><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collections</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">item</span> = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">open</span> = <span class="hljs-string">&quot;AND(&quot;</span> <span class="hljs-attr">close</span> = <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span>id = #&#123;这里填的时item里面填的东西&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="sql片段">0.6.5.3.4. sql片段</h5><p><strong>需求</strong>:</p><p>将上边实现的sql判断代码抽取出来，组成一个sql片段。其他的statement中就可以来引用这个sql片段</p><p>在mapper.xml中定义的statement的引用sql片段</p><p>1.定义sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">//sql片段的唯一标识,一般我们定义sql片段是基于单表来定义的，这样的话可重用性高。在sql片段中不要包括where<br><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">&quot;条件&quot;</span>&gt;</span>sql语句<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.引用sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">//引用sql片段的id，如果refid指定的id不再本mapper文件中，需要在前面加namespace<br><br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br><br>​<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><br>​//在这里还要引用其他的sql片段，所以sql片段不能加where<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_mybatis_end</title>
    <link href="/gzguo/2019/08/14/java/mybatis/end/"/>
    <url>/gzguo/2019/08/14/java/mybatis/end/</url>
    
    <content type="html"><![CDATA[<h4 id="mybatis高级映射及开发方法">0.0.0.1. mybatis高级映射及开发方法</h4><span id="more"></span><p><strong>课程复习</strong>：</p><p>mybatis是什么？mybatis和hibernate都是持久层框架，mybatis是一个不完全的ORM框架，sql语句需要程序员自己去编写，但mybatis也有映射（输入映射、输出映射）</p><p>mybatis入门门槛不高，学习成本低，让程序员把精力放在sql语句上，对sql语句优化非常方便，适用于需求变化较多的项目，比如互联网项目</p><p><strong>mybatis框架执行过程</strong>：</p><p>1.配置mybatis的配置文件，SqlMapConfig（名称不固定）</p><p>2.通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂。SqlSessionFactory实际使用时按单列管理</p><p>3.通过工厂创建SqlSession</p><p>SqlSession是一个面向用户的接口（提供操作数据库的方法），实现对象是线程不安全的，建议SqlSession应用场合在方法体内</p><p>4.调用SqlSession的方法去操作数据库</p><p>如果需要提交事务，需要执行SqlSession的commit()方法</p><p>5.释放资源，关闭SqlSession</p><p><strong>mybatis开发dao的方法</strong>：</p><p>1.原始dao方法：需要程序员编写dao接口和实现类。需要在dao实现类中注入一个SqlSessionFactory工厂</p><p>2.mapper代理开发方法：</p><p>只需要程序员编写mapper接口（就是dao接口）</p><p>程序员在编写mapper.xml（映射文件）和mapper.java需要遵循一个开发规范</p><p>a.在mapper.xml中namespace就是mapper.java的全路径</p><p>b.mapper.xml中statement的id和mapper.java中的方法名一致</p><p>c.mapper.xml中statement的parameterType指定的参数类型和mapper.java中方法的输入参数类型一致</p><p>d.mapper.xml中statement的resultType指定的参数类型和mapper.java中方法的输出参数类型一致</p><p><strong>输入映射</strong></p><p>parameterType：指定输入参数的类型可以是简单类型、pojo、hashmap，对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展</p><p><strong>输出映射</strong></p><p>resultType：查询道德列名和resultType指定的属性名一致，才能映射成功</p><p>resultMap：可以通过resultMap来完成高级的映射、复杂的映射，如果查询道德列名和pojo的属性不一致时，我们就可以通过resultMap来设置列名和属性名之间的映射关系。可以完成映射</p><p><strong>高级映射</strong></p><p>将关联查询的列映射到pojo的属性中（一对一）</p><p>将关联查询的列映射到List<pojo>中（一对多）</pojo></p><p><strong>动态sql</strong></p><p>if、where、foreach、sql片段</p><h2 id="订单商品数据模型分析">0.1. 订单商品数据模型分析</h2><h3 id="数据模型分析思路">0.1.1. 数据模型分析思路</h3><p>1.每张表记录的数据内容：分模块对每张表的内容进行熟悉，相当于你学习系统需求（功能）的过程</p><p>2.每张表重要数据字段设置：非空字段、有外键的字段</p><p>3.数据库级别表与表之间的关系：外键关系</p><p>4.表与表之间的业务关系：在分析表与表之间的业务关系时一定是建立在某个业务意义基础上去分析</p><p>先分析数据级别之间有关系的表之间的业务关系：</p><p>user和orders：</p><p>user—&gt;orders：一个用户可以创建多个订单，一对多</p><p>orders—&gt;user：一个订单可以由多个用户创建，一对一</p><p>orders和orderdetall：</p><p>orders—&gt;orderdetall：一个订单包含多个订单明细，一个订单可以购买多个商品，每个商品的购买信息都在orderdetail记录，一对多关系</p><p>orderdetall—&gt;orders：一个订单明细只能包括在一个订单中，一对一</p><h2 id="高级结果映射">0.2. 高级结果映射</h2><p><strong>一对一</strong></p><p>查询订单信息，关联查询创建订单用户信息</p><p>slq语句：查询订单信息，关联查询创建订单用户</p><p>resultType：</p><p>创建一个pojo让他字段名和属性名一一对应</p><p>创建的时候可以让他继承一下之前的pojo类，这样可以简化后台代码</p><p>resultMap：</p><p>使用resultMap将查询结果映射到Order对象中，在orders类中添加user属性，将关联查询出来的用户信息映射到orders对象中的user属性中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;% asset_img 1565493794869.png This is an image %&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/1565493794869.png"></p><p>实体类orders里面的实体类user</p><p>association里面的标签是配置查询的列和user实体类对应的信息</p><p>id：关联查询用户的唯一标识</p><p>javaType：需要映射的那个实体类的路径（user）</p><p>column：指定用户信息的列</p><p>property：user中的属性名</p><p><strong>resultType和resultMap</strong></p><p>实现一对一查询：</p><p>resultType：使用resultType实现较为简单，如果pojo中没有包括查询的列名，需要增加与列名对应的属性，即可完成映射</p><p>如果没有查询结果的特殊要求建议使用resultType</p><p>resultMap：需要定义resultMap，实现有点复杂，如果对查询结果由特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中</p><p>resulrMap可以实现延迟加载，而resultType无法实现延迟加载</p><p><strong>一对多</strong></p><p>查询订单及订单明细</p><p>sql语句：确定主查询表、确定关联查询表</p><p><strong>collection</strong>：一个订单关联出了多条明细，要使用collection进行映射。collection：对关联查询道德多条记录映射到集合对象中</p><p>property：将关联查询到的多条记录映射到集合对象的哪个属性中</p><p>ofType：集合对象的一条pojo对应的实体类的路径</p><p><strong>小结</strong></p><p>mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中</p><p>使用resultType实现：将订单明细映射到orders中的orderdetails中需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails</p><p><strong>多对多</strong></p><p><img src="/images/1565512910096.png"></p><p>总结：</p><p>将查询用户购买商品信息明细清单（用户名、用户地址、购买商品时间、购买商品数量）</p><p>针对上边的需求，将查询到的记录映射到扩展的pojo中，很简单实现明细清单的功能</p><p>使用resultMap对查询结果映射有特殊要求的功能</p><h2 id="mybatis延迟加载">0.3. mybatis延迟加载</h2><p><img src="/images/1565576908107.png"></p><p><img src="/images/1565576954595.png"></p><p>使用association中的select指定延迟加载去执行statement的id</p><p>延迟加载是什么？先执行简单查询语句，有条件的话，利用association来执行副表查询语句。减轻数据库的压力</p><p>不适用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载</p><p>实现方法如下：先去查询一个mapper方法，获取第一个mapper查询的订单信息。在程序中，按需去调用第二个mapper方法去查询用户信息</p><p>使用延迟加载是为了，先查询简单的sql，再去按需加载关联查询的其他信息</p><h2 id="mybatis查询缓存">0.4. mybatis查询缓存</h2><p><strong>一级缓存</strong>：sqlSession级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMAp）用于存储数据。不同的sqlSession之间缓存数据区域（HashMap）是互相不影响的</p><p><strong>二级缓存</strong>：mapper级别的缓存：多个sqlSession去操作同一个Mapper的sql语句，多个sqlSession可以共用二级缓存，二级缓存可以跨sqlSession的</p><p>为什么要用缓存？</p><p>如果存储中有数据就不用从数据库中获取，大大提高系统性能</p><h3 id="一级缓存">0.4.1. 一级缓存</h3><p>第一次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，如果没有，从数据库查询用户信息</p><p>得到用户信息，将用户信息存储到一级缓存中</p><p>第二次发起查询用户id位1的用户信息，先去缓存中查询是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息</p><p>如果sqlSession去执行commit操作（去执行、更新、删除），清空sqlSession中的一级缓存，这样做的目的是为了让缓存中的信息存储的是最新的信息，避免脏读</p><p>mybatis默认支持一级缓存，不需要在配置文件中去开启缓存</p><h3 id="一级缓存的应用">0.4.2. 一级缓存的应用</h3><p>正式开发：是将spring和mybatis进行整合开发，事务控制在service中</p><p>一个service方法中包括很多mapper方法调用</p><p>service：</p><p>开始执行时，开启事务，创建sqlSession对象</p><p>第一次调用mapper的方法。</p><p>第二次调用mapper的方法，从一级缓存中拿数据</p><p>方法结束，sqlSession关闭</p><p>如果执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空</p><p>这样的话，我们就需要学习二级缓存</p><h3 id="二级缓存">0.4.3. 二级缓存</h3><p>首先要手动开启mybatis的二级缓存</p><p>sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中</p><p>sqlSession2去查询用户id为1的用户信息，先去缓存中查找是否存在数据，如果存在直接从缓存中取出数据。</p><p>如果执行了commit的话，那么就会清空mapper对应的二级缓存下的数据</p><p><code>二级缓存和一级缓存的区别</code>，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。UserMapper有一个二级缓存区域，其他的Mapper也有缓存区域（按照namespace分的）。也就是说每一个namespace的mapper有一个二级缓存区域，两个mapper的namespace如果相同，那么这两个mapper执行sql查询到的数据将存储在相同的二级缓存区域中</p><h3 id="开启二级缓存">0.4.4. 开启二级缓存</h3><p>mybatis的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要再具体的mapper.xml中开启二级缓存</p><p>在UserMapper.xml中开启二级缓存，UserMapper.xml下的sql执行完成后会存储到他的缓存区域（HashMap）</p><p>开启本Mapper namespace下的二级缓存：<cache></cache></p><p>调用pojo类实现序列化接口：为了将缓存数据取出执行反序化操作，因为二级缓存数据介质多种多样，不一定在内存</p><h3 id="禁用二级缓存">0.4.5. 禁用二级缓存</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">userCatch</span> = <span class="hljs-string">&quot;false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样配置的话，这条语句每次都会去数据库查询，禁用二级缓存。针对每次查询都需要最新的数据sql</p><h3 id="总结">0.4.6. 总结</h3><p>一般情况下，执行完commit操作都需要刷新缓存，flushCache = “true”代表刷新缓存，这样可以避免数据库脏读</p><h3 id="刷新缓存">0.4.7. 刷新缓存</h3><p>刷新缓存是清空缓存，在mapper的同一个namespace中，如果有其他insert、update、delete操作后需要刷新缓存，如果不刷新缓存就会出现脏读</p><p>设置statement配置中的flushCache = “true”属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时会出现脏读,如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span> = <span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">flushCache</span> = <span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="mybatis整合ehcache">0.4.8. mybatis整合ehcache</h3><p>ehcache是一个分布式缓存框架</p><h4 id="分布缓存">0.4.8.1. 分布缓存</h4><p>我们的系统为了提高系统并发、性能，一般对系统进行分布式部署（集群部署方式）</p><p>不使用分布缓存，缓存的数据在各个服务单独存储，不方便开发。所以要使用分布式缓存对缓存数据进行集中管理</p><p>对缓存数据集中管理，我们要使用分布式缓存框架redis、memcached、ehcache</p><p>mybatis无法实现分布式缓存，不利于系统开发，需要和其他的分布式缓存框架进行整合</p><h4 id="整合的方法">0.4.8.2. 整合的方法</h4><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现自己的cache接口即可</p><p>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类</p><p>mybatis有默认实现的cache类</p><p>整合eacache：</p><p>1.导入包</p><p>2.实现cache类（配置mapper中的type为ehcache接口的实现类型）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="加入ehcache的配置文件">0.4.8.3. 加入ehcache的配置文件</h4><p><img src="/images/1565593058004.png"></p><p>在classpath下配置ehcache.xml</p><h3 id="二级缓存的应用场景">0.4.9. 二级缓存的应用场景</h3><p>对于访问多的查询请求且用户对查询结果实时要求不高，此时可以采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景如下：耗时较高的统计分析sql、电话账单查询sql等</p><p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新时间隔fulshInterval，比如设置为30分钟、60分钟、24小时等</p><h3 id="局限性">0.4.10. 局限性</h3><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下要求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都查询最新的商品信息，此时如果使用二级缓存就无法实现一个商品变化时只刷新该商品的缓存信息而不刷新其他商品的信息，因为mybatis的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有的商品信息的缓存数据全部清空。解决此类问题需要在服务层根据需求对数据进行有针对性的缓存</p><h2 id="mybatis和spring进行整合">0.5. mybatis和spring进行整合</h2><h3 id="整合思路">0.5.1. 整合思路</h3><p><strong>需要spring通过单列方式管理SqlSessionFactory</strong></p><p>spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession（spring和mybatis整合自动完成）</p><p><strong>持久层的mapper都需要由spring进行管理</strong></p><h3 id="整合环境">0.5.2. 整合环境</h3><p>创建一个新的java工程（接近实际开发的工程结构）</p><p>jar包：</p><p>mybatis3.2.7的jar包</p><p>spring3.2.0的jar包</p><p>mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供</p><h3 id="SqlSessionFactory">0.5.3. SqlSessionFactory</h3><p><strong>在applicationContext.xml中配置sqlSessionFactory和数据源</strong></p><p>sqlSessionFactory在mybatis的spring的整合包下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--加载配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源，使用dbcp或者（c3p0）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hljs-attr">destory-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="原始dao开发">0.5.4. 原始dao开发</h3><h4 id="mapper-xml">0.5.4.1. mapper.xml</h4><p>创建mapper.xml</p><p>在SqlMapConfig.xml中加载User.xml</p><h4 id="dao">0.5.4.2. dao</h4><p>dao接口实现需要注入SqlSessionFactory，通过spring进行注入</p><p>这里为了更好的让大家看见，这里用spring声明配置方式，配置dao的bean</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao class=&quot;</span><span class="hljs-attr">cn.itcast.ssm.dao.UserDaoImpl</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;SessionFactory&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>让UserDaoImpl实现类继承SqlSessionDaoSupport（extends SqlSessionDaoSupport ）。继承的这个东西里面有创建会话工厂的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//继承了这个东西之后，创建会话的方法</span><br>SqlSession sqlSession = <span class="hljs-keyword">this</span>.getSqlSession();<br></code></pre></td></tr></table></figure><p>在applicationContext.xml中配置dao</p><h3 id="mapper代理开发">0.5.5. mapper代理开发</h3><h4 id="mapper-xml-1">0.5.5.1. mapper.xml</h4><h2 id="mybatis逆向工程">0.6. mybatis逆向工程</h2><h3 id="什么是逆向工程？">0.6.1. 什么是逆向工程？</h3><p>mybatis需要程序员自己写sql语句，mybatis官方提供逆向工程，针对单表来生成代码，mybatis执行所需要的代码（mapper.java\mapper.xml\po）</p><p>企业的实际开发中，常用的逆向工程方式</p><p>由于数据库的表生成java代码</p><h3 id="下载逆向工程">0.6.2. 下载逆向工程</h3><h3 id="使用方法">0.6.3. 使用方法</h3><p>建议使用java程序方式，不依赖开发工具</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
