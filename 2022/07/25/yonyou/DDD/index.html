

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/gzguo/img/favicon.png">
  <link rel="icon" href="/gzguo/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="DDD入门！！！">
  <meta name="author" content="Little scholar">
  <meta name="keywords" content="IT">
  
  <title>DDD入门 - Learing</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/gzguo/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/agate.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/gzguo/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/gzguo/css/mac.css">
<link rel="stylesheet" href="/gzguo/css/toubudaziji.css">
<link rel="stylesheet" href="/gzguo/css/shubiao.css#.css">
<link rel="stylesheet" href="/gzguo/css/gundong.css">
<link rel="stylesheet" href="/gzguo/css/APlayer.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"github.com","root":"/gzguo/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"gc226JcELJOJ7J0n4C9IDFd1-gzGzoHsz","app_key":"Ix9equHpEbmzuf2eGJmCgvaB","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/gzguo/js/utils.js" ></script>
  <script  src="/gzguo/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/gzguo/">&nbsp;<strong>Jarvis</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gzguo/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gzguo/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gzguo/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gzguo/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/gzguo/img/bj.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="DDD入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-25 21:17" pubdate>
        2022年7月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      93
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
    <a href="https://github.com/gzguo/gzguo" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">DDD入门</h1>
            
            <div class="markdown-body">
              <p>DDD入门！！！</p>
<span id="more"></span>

<h1 id="专业名词解析">1. 专业名词解析</h1><h2 id="bo、vo、po的区别">1.1. bo、vo、po的区别</h2><p>**业务对象<code>Bo(business object)</code>**，Bo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。</p>
<p>**值对象<code>Vo(value object)</code>**，通常用于业务层之间的数据传递，由new创建，由GC回收。主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个Vo对象在控制层与视图层进行传输交换。</p>
<p>**持久层对象<code>Po(persistant object)</code>**，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。</p>
<h2 id="REST">1.2. REST</h2><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。</p>
<p>REST 定义了一组体系架构原则，您可以根据这些原则设计以系统资源为中心的 Web 服务，包括使用不同语言编写的客户端如何通过 HTTP 处理和传输资源状态。 如果考虑使用它的 Web 服务的数量，REST 近年来已经成为最主要的 Web 服务设计模型。 事实上，REST 对 Web 的影响非常大，由于其使用相当方便，已经普遍地取代了基于 SOAP 和 WSDL 的接口设计。</p>
<h2 id="硬件、软件和固件">1.3. 硬件、软件和固件</h2><p><strong>硬件（<code>Hardware</code>）</strong>，指创造了之后不可（或者很难）变更的东西。数据库对于开发来说，就属于”硬件“，数据库选型后基本上后面不会再变，比如：用了MySQL就很难再改为MongoDB，改造成本过高。</p>
<p><strong>软件（<code>Software</code>）</strong>，指创造了之后可以随时修改的东西。对于开发来说，业务代码应该追求做”软件“，因为业务流程、规则在不停的变化，我们的代码也应该能随时变化。</p>
<p><strong>固件（<code>Firmware</code>）</strong>，即那些强烈依赖了硬件的软件。我们常见的是路由器里的固件或安卓的固件等等。固件的特点是对硬件做了抽象，但仅能适配某款硬件，不能通用。所以今天不存在所谓的通用安卓固件，而是每个手机都需要有自己的固件。</p>
<h2 id="持久化和序列化">1.4. 持久化和序列化</h2><p>什么是持久化？把内存中的数据存储到关系型数据库中，也可以存储到磁盘文件、xml、数据文件中。</p>
<p>什么是序列化？把对象变为字节流</p>
<p>他们之间的相同之处？都希望把对象转换为其他的东西</p>
<h2 id="领域服务">1.5. 领域服务</h2><p>将个人动作和业务动作隔离开</p>
<h2 id="聚合出现的原因">1.6. 聚合出现的原因</h2><p>实体太多了，导致了聚合的出现</p>
<p>聚合是用来确保领域对象实现共同的业务逻辑，能保证数据的一致性</p>
<p><strong>聚合根</strong>：在聚合对象中选择一个对象专门对外进行访问，这个对象成为聚合根</p>
<p>聚合根的好处：聚合和聚合之间的关系变得简单，关系只在聚合根和聚合根之间，实体关系可以得到极大的简化。</p>
<p>在DDD中只有引起实体状态变化的称为业务</p>
<p>查询不属于DDD的业务，可以打破DDD的业务框架去做。</p>
<p>DDD也不是哪哪都好，涉及到了核心业务使用DDD维护会比较好。</p>
<h2 id="中台、领域仓库">1.7. 中台、领域仓库</h2><h2 id="微服务">1.8. 微服务</h2><p>微服务是技术，微服务是单个业务的能力，中台是整体的业务能力</p>
<h1 id="DDD入门">2. DDD入门</h1><h2 id="什么是DDD">2.1. 什么是DDD</h2><h3 id="定义">2.1.1. 定义</h3><p>**领域驱动设计<code>DDD(Domain-Driven Design)</code>**，是一种思潮、一种架构思想</p>
<p>DDD是个规范，让代码更加合理化分布，方便修改、维护、测试。DDD主要使用了dp的策略来实现自己的目的。</p>
<p>DDD不是一个特殊的架构设计，而是所有Transction Script代码经过合理重构后一定会抵达的终点。</p>
<h3 id="POP、OOP、DDD的思想">2.1.2. POP、OOP、DDD的思想</h3><p>要想了解DDD就要对比POP和OOP：</p>
<p><strong>面向过程编程（<code>POP</code>）</strong>，把需求自顶向下，逐层分解成函数</p>
<p><strong>面向对象编程（<code>OOP</code>）</strong>，把需求分解为对象</p>
<p><strong>领域驱动设计（<code>DDD</code>）</strong>，把需求分解为问题域，再把问题域分解为对象。</p>
<h2 id="DDD分层">2.2. DDD分层</h2><h3 id="java三层架构">2.2.1. java三层架构</h3><p><em>三层架构通过实体层（<code>entity layer</code>）联系起来,实体层不属于三层中的任何一层</em></p>
<p><strong>视图层（<code>View</code>）</strong>，用于接收用户提交请求的代码。</p>
<p><strong>业务逻辑层（<code>Service</code>）</strong>，系统的业务逻辑主要在这里完成。</p>
<p><strong>持久层（<code>DAO</code>）</strong>，直接操作数据库的代码，主要是做数据持久化的工作 。</p>
<h3 id="MVC分层">2.2.2. MVC分层</h3><p><strong>视图（<code>View</code>）</strong>，为用户提供使用界面，与用户直接进行交互。</p>
<p><strong>模型（<code>Model</code>）</strong>，承载数据，并对用户提交请求进行计算的模块。其分为两类： 一类称为数据承载 Bean：实体类，专门用户承载业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理用户提交请求的。</p>
<p><strong>控制器（<code>Controller</code>）</strong>，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。</p>
<h3 id="DDD分层-1">2.2.3. DDD分层</h3><p>我们直接在将dp作为最底层（领域层），将应用层简化，在应用层只有编排（Orchestration），我们把原先依赖的基础服务层放到基础服务层</p>
<p><strong>用户界面、展示层（<code>Interface</code>）</strong>，负责向用户展示信息以及解释用户的命令。</p>
<p><strong>应用层（<code>Application</code>）</strong>，是用来编排领域层中的领域对象的。</p>
<p><strong>领域层（<code>Domain</code>）</strong>，这一层是业务逻辑代码的核心。</p>
<p><strong>基础设施层（<code>Infrastructure</code>）</strong>，主要将内存（域实体）中的数据持久化到数据库或者另一个持久性存储区中。</p>
<h3 id="三层架构、MVC、DDD关系">2.2.4. 三层架构、MVC、DDD关系</h3><h4 id="MVC和三层架构">2.2.4.1. MVC和三层架构</h4><p><em>View（MVC）= View（三层架构）</em></p>
<p><em>Model（MVC）= Dao+Service（三层架构）</em></p>
<p><strong>MVC最大的变化就是增加了Controller层来协调Model和View</strong></p>
<h4 id="SSM和三层架构">2.2.4.2. SSM和三层架构</h4><p>SSM，即 <strong>SpringMVC</strong>、<strong>Spring</strong> 与 <strong>MyBatis</strong> 三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。</p>
<p>SSM可以具体实现MVC架构，SSM具体的实现、SSM在MVC每一层所用到的技术如下所示：</p>
<blockquote>
<p><strong>SpringMVC</strong>：作为 View 层的实现者，完成用户的请求接收功能。SpringMVC 的 Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。</p>
<p><strong>MyBatis</strong>：作为 Dao 层的实现者，完成对数据库的增、删、改、查功能。</p>
<p><strong>Spring</strong>：以整个应用大管家的身份出现。整个应用中所有 Bean 的生命周期行为，均由Spring 来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由 Spring 进行管理。</p>
</blockquote>
<h4 id="DDD和MVC">2.2.4.3. DDD和MVC</h4><p>DDD把MVC的代码顺序进行了调整。最大的变化就是把业务逻辑层分割开来，转换成了应用层和领域层。DDD将Controller层变薄。应用层就是对业务逻辑的整理。领域层就是代码逻辑，是对应用层接口的实现。</p>
<blockquote>
<p><em>用户接口层（DDD） = View（MVC）</em></p>
<p><em>应用层+领域层（DDD） = Model（MVC）</em></p>
<p>Controller层被薄化。基础层（DDD）为上面的领域层、应用层和用户接口层提供服务。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f63b80a343ca26d7858a53cbbf27ea64.png" srcset="/gzguo/img/loading.gif" lazyload alt="img"></p>
<p>​    </p>
<h2 id="构成要素">2.3. 构成要素</h2><p><strong>实体（<code>Entity</code>）</strong>，具备唯一ID，能够被持久化，具备业务逻辑，对应现实世界业务对象。</p>
<p><strong>值对象（<code>Value Object</code>）</strong>，不具有唯一ID，由对象的属性描述，一般为内存中的临时对象，可以用来传递参数或对实体进行补充描述。</p>
<p><strong>领域服务（<code>Domain Service</code>）</strong>，为上层建筑提供可操作的接口，负责对领域对象进行调度和封装，同时可以对外提供各种形式的服务。</p>
<p><strong>聚合根（<code>Aggregate Root</code>）</strong>，聚合根属于实体对象，聚合根具有全局唯一ID，而实体只有在聚合内部有唯一的本地ID，值对象没有唯一ID</p>
<p><strong>工厂（<code>Factories</code>）</strong>，主要用来创建聚合根，目前架构实践中一般采用<code>IOC</code>容器来实现工厂的功能。</p>
<p><strong>仓储（<code>Repository</code>）</strong>，封装了基础设施来提供查询和持久化聚合操作。</p>
<h2 id="DDD解决MVC中逻辑代码重复">2.4. DDD解决MVC中逻辑代码重复</h2><h3 id="原先mvc的问题">2.4.1. 原先mvc的问题</h3><blockquote>
<p>为什么要引入DDD的概念？因为原先的代码结构有很多的不足！</p>
<p>1、编码时不能够检查参数的正确性、方法名称和参数顺序不清晰<br>2、参数验证有大量的重复、可能用到try catch块，异常处理成本高<br>3、入参并不是最终想要的，需要重新处理，可以把处理代码抽离出来形成工具类，但是这样会导致静态工具类太多<br>4、p个测试用例，n个参数，m个校验逻辑，有太多的参数需要验证同样的校验逻辑</p>
</blockquote>
<p><strong>总而言之</strong>，最主要的原因就是MVC如果出现了新的需求，代码的改动会很大，带来很多的不方便。MVC中存在很多的业务脚本，这些业务脚本代码很冗长，不利于我们扩展、维护、修改。</p>
<p>MVC模式开发会有很多的类似的地方，我们可以称之为<strong>事务脚本</strong></p>
<h3 id="我们写代码应该遵守的原则">2.4.2. 我们写代码应该遵守的原则</h3><p><strong>单一职责原则</strong>，一个类只有一个引起他变化的原因。</p>
<p><strong>开放封闭原则</strong>，对扩展开放，对修改封闭。</p>
<p><strong>依赖反转原则</strong>，程序之间要依赖于抽象的接口，而不是具体实现。</p>
<h3 id="DDD的解决方法">2.4.3. DDD的解决方法</h3><p>使用dp（Domain Primitive），并且遵守他的三大原则：</p>
<p> <strong>将隐性的概念显性化（dp的第一个原则）</strong></p>
<p>将验证逻辑和对数据的操作都写在了constructor 中。原来的Integer Phone变成了一个新的对象Phone，他可以自己校验自己的逻辑，对自己进行分割等操作<br>以上的思想就是 将隐性的概念显性化（dp的第一个原则）Domain Primitive</p>
<p><strong>将 隐性的 上下文 显性化（dp的第二个原则）</strong><br>转账问题：参数只有金额和人的话，就会忽略货币类型<br>解决：我们可以将金额封装成money对象，money中含金额和货币类型，这样可以避免踩雷</p>
<p><strong>封装 多对象 行为（dp的第三个原则）</strong><br>把转换汇率的功能，涉及到了多个对象的，可以写成一个vo汇率对象</p>
<h3 id="总结">2.4.4. 总结</h3><p>所有的问题都可以通过dp来解决，增加了dp之后，我们的逻辑代码可以存放在dp中，原先的service层可以只写编排。越往上层走，在修改、维护、测试代码的时候就越容易修改、越容易维护、越容易测试。</p>
<h2 id="DDD解决外部服务在代码中大量出现的问题">2.5. DDD解决外部服务在代码中大量出现的问题</h2><h3 id="症结所在">2.5.1. 症结所在</h3><p>我们之前的代码逻辑主要面临的问题就是之前把第三方放到底层，在代码中调用次数太多，这就会导致一系列的问题，问题如下：</p>
<p>可维护性差：第三方服务的不确定性、中间件的更换、数据库结构的变化<br>可扩展性差：做第一个业务简单，后面的业务难度逐增加<br>可测试性差：一个测试需要很长的时间才能跑通</p>
<p>总之就是之前的服务我们直接把服务写在了代码中，维修、扩展和测试都受到了很大的影响，我们最好可以增加防腐层（ACL），通过加一层的方式来降低服务在代码中出现的次数。</p>
<h3 id="DDD的解决方法-1">2.5.2. DDD的解决方法</h3><h4 id="防腐层">2.5.2.1. 防腐层</h4><p><strong>防腐层（<code>Anti-Corruption Layer</code>）</strong>，是一种在不同语义的子系统间构建的一层功能，对子系统间的请求进行翻译适配，从而确保应用设计不受外部依赖的系统的限制。</p>
<h4 id="解决思路">2.5.2.2. 解决思路</h4><p>解决外部服务影响内部最直接的方法就是建立防腐层。</p>
<p>如何面对我们无法控制的外部系统？<strong>一种可行的方法，就是在应用系统自身与外部之间，构筑专门一层组件或者服务，对两个系统进行通讯转换和语义隔离。</strong>这一层组件或者服务，称为“防腐层”。为了防止基础服务在代码中大量出现，我们可以使用防腐层来隔离中间件和远程服务这些东西。防腐层只需要将第三方服务的成功和失败返回给系统，作为防腐层。其中的成功和失败的格式可以自己定义。</p>
<h4 id="代码模块化">2.5.2.3. 代码模块化</h4><p>types模块：放dp（Domain Primitives），纯pojo<br>domain模块：domain仅仅依赖types，纯pojo。这块是核心业务逻辑，变更频繁。<br>application模块：application仅仅依赖domain，还是纯pojo。可以在这块添加业务用例（这块不太清楚，他和domain有什么区别）<br>Infrastructure模块：数据库DAO的实现。基本不需要变更<br>web模块：Web模块包含Controller等相关代码<br>start模块：springboot启动类</p>
<p>所以在DDD架构中，能明显看出越外层的代码越稳定，越内层的代码演进越快，真正体现了领域“驱动”的核心思想。</p>
<h2 id="repository">2.6. repository</h2><h3 id="仓库存在的意义">2.6.1. 仓库存在的意义</h3><p>贫血领域模型</p>
<p>1、很多Java开发对Entity的理解停留在了数据映射层面，忽略了Entity实体的本身行为，造成今天很多的模型仅包含了实体的数据和属性，而所有的业务逻辑都被分散在多个服务、Controller、Utils工具类中，这个就是Martin Fowler所说的的Anemic Domain Model（贫血领域模型）。</p>
<p>2、通俗的讲，当前的entity只包含了实体的数据和属性，所有的业务逻辑分散在多个服务、Controller、Utils中。<br>3、模型贫血的表现：实体类中都是数据和属性、controller和service中都是逻辑、含有大量的utils工具类</p>
<p>Data Model只存在于数据层，而Domain Model在领域层，而链接了这两层的关键对象，就是<strong>Repository</strong>。</p>
<p>我们需要一个模式，能够隔离我们的软件（业务逻辑）和固件/硬件（DAO、DB），让我们的软件变得更加健壮，而这个就是Repository的核心价值。</p>
<h3 id="工厂和仓库">2.6.2. 工厂和仓库</h3><p>工厂存在的意义就是解决多对多关系中的关联表（关联表的存在没有任何的业务价值）。工厂主要就是用来做实体的组装的。</p>
<p>仓库和工厂来进行封装实体持久化操作，最终的形式是DTO形式。</p>
<h3 id="三种对象模型">2.6.3. 三种对象模型</h3><ul>
<li><strong>Data Object （DO、数据对象）：</strong>实际上是我们在日常工作中最常见的数据模型。但是在DDD的规范里，DO应该仅仅作为数据库物理表格的映射，不能参与到业务逻辑中。为了简单明了，DO的字段类型和名称应该和数据库物理表格的字段类型和名称一一对应，这样我们不需要去跑到数据库上去查一个字段的类型和名称。（当然，实际上也没必要一摸一样，只要你在Mapper那一层做到字段映射）</li>
<li><strong>Entity（实体对象）：</strong>实体对象是我们正常业务应该用的业务模型，它的字段和方法应该和业务语言保持一致，和持久化方式无关。也就是说，Entity和DO很可能有着完全不一样的字段命名和字段类型，甚至嵌套关系。Entity的生命周期应该仅存在于内存中，不需要可序列化和可持久化。</li>
<li><strong>DTO（传输对象）：</strong>主要作为Application层的入参和出参，比如CQRS里的Command、Query、Event，以及Request、Response等都属于DTO的范畴。DTO的价值在于适配不同的业务场景的入参和出参，避免让业务对象变成一个万能大对象。</li>
</ul>
<h3 id="对象模型之间的转化">2.6.4. 对象模型之间的转化</h3><p>我理解的DTO就是最终需要在页面上展示的数据，DO就是数据库的数据的映射，Entity要含有业务逻辑，最好是做到实体型，不要出现贫血型。</p>
<p>DTO Assembler的核心作用就是将1个或多个相关联的Entity转化为1个或多个DTO。在转化的时候可以用到映射的方法，其中最好的是静态映射中的MapStruct。</p>
<p>构造DTO的方法：</p>
<ul>
<li>动态映射：BeanUtils.copyProperties、能通过xml配置的Dozer等</li>
<li>静态映射：MapStruct</li>
</ul>
<p>这样把所有的对象区分开，虽然会导致代码量膨胀，但是会让我们代码的逻辑复杂性降低。</p>
<h2 id="龙与魔法（这是一个简单的例子）">2.7. 龙与魔法（这是一个简单的例子）</h2><h3 id="规则">2.7.1. 规则</h3><p>基础配置如下：</p>
<ul>
<li>玩家（Player）可以是战士（Fighter）、法师（Mage）、龙骑（Dragoon）</li>
<li>怪物（Monster）可以是兽人（Orc）、精灵（Elf）、龙（Dragon），怪物有血量</li>
<li>武器（Weapon）可以是剑（Sword）、法杖（Staff），武器有攻击力</li>
<li>玩家可以装备一个武器，武器攻击可以是物理类型（0），火（1），冰（2）等，武器类型决定伤害类型</li>
</ul>
<p>攻击规则如下：</p>
<ol>
<li>兽人对物理攻击伤害减半</li>
<li>精灵对魔法攻击伤害减半</li>
<li>龙对物理和魔法攻击免疫，除非玩家是龙骑，则伤害加倍</li>
</ol>
<p>开闭原则（OCP）规定“对象应该对于扩展开放，对于修改封闭“，继承虽然可以通过子类扩展新的行为，但因为子类可能直接依赖父类的实现，导致一个变更可能会影响所有对象。</p>
<p><em>oop全称Object Oriented Programming</em>,一般指面向对象程序设计,应该是一种计算机编程架构</p>
<h3 id="ECS游戏架构分析">2.7.2. ECS游戏架构分析</h3><h4 id="简介">2.7.2.1. 简介</h4><p><strong>Entity-Component-System（ECS）架构简介</strong>：ECS架构模式是其实是一个很老的游戏架构设计，最早应该能追溯到《地牢围攻》的组件化设计，但最近因为Unity的加入而开始变得流行（比如《守望先锋》就是用的ECS）。要很快的理解ECS架构的价值，我们需要理解一个游戏代码的核心问题：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-keyword">Entity</span>：用来代表任何一个游戏对象，但是在ECS里一个<span class="hljs-keyword">Entity</span>最重要的仅仅是他的EntityID，一个<span class="hljs-keyword">Entity</span>里包含多个<span class="hljs-keyword">Component</span><br><br><span class="hljs-keyword">Component</span>：是真正的数据，ECS架构把一个个的实体对象拆分为更加细化的组件，比如位置、素材、状态等，也就是说一个<span class="hljs-keyword">Entity</span>实际上只是一个Bag <span class="hljs-keyword">of</span> Components。<br><br>System（或者ComponentSystem，组件系统）：是真正的行为，一个游戏里可以有很多个不同的组件系统，每个组件系统都只负责一件事，可以依次处理大量的相同组件，而不需要去理解具体的<span class="hljs-keyword">Entity</span>。所以一个ComponentSystem理论上可以有更加高效的组件处理效率，甚至可以实现并行处理，从而提升CPU利用率。<br></code></pre></div></td></tr></table></figure>

<h4 id="特征">2.7.2.2. 特征</h4><p>entity主要的特征是组件化（将所有的小功能都变成组件）、行为抽离（把游戏角色的行为分离开）、数据驱动（将compontent的小功能结合起来实现复杂的行为）。这样分开的优势在与我们只需要添加好底层的组件，就可以在对应的行为系统中进行实现，最后绑定到玩家，这样就可以简单的实现一个新的组合功能（不需要推到重来和重新构建新的类，只需要在系统中注册和玩家功能绑定就可以）。</p>
<h4 id="理解">2.7.2.3. 理解</h4><p>entity是游戏玩家，component是游戏组件（实现游戏中的各种小功能），system用来组织component，负责entity的一个行为，比如说移动，移动的system就可以调用移动相关的component来实现移动。</p>
<h4 id="缺陷">2.7.2.4. 缺陷</h4><p>但我认为其最大的一个问题是ECS为了提升性能，强调了数据/状态（State）和行为（Behaivor）分离，并且为了降低GC成本，直接操作数据，走到了一个极端。而在商业应用中，数据的正确性、一致性和健壮性应该是最高的优先级，而性能只是锦上添花的东西，所以ECS很难在商业场景里带来特别大的好处。</p>
<p>Double Dispatch：是通过方法参数引入，不依赖别的类，直接把这个类对象作为参数传入</p>
<p>Double Dispatch是一个使用Domain Service经常会用到的方法，类似于调用反转。</p>
<p>感觉最大的不同就是把类自己的属性当做是注入的东西，这样的话就不用依赖其他的东西了，只有这一个地方会依赖这个属性，修改、测试、维护的时候会很方便。</p>
<h2 id="entity实体类">2.8. entity实体类</h2><p>大多数DDD架构的核心都是实体类，实体类包含了一个领域里的状态、以及对状态的直接操作。Entity最重要的设计原则是保证实体的不变性（Invariants），也就是说要确保无论外部怎么操作，一个实体内部的属性都不能出现相互冲突，状态不一致的情况。所以几个设计原则如下：</p>
<p>1、创建即一致<br>    1）constructor参数要包含所有必要属性，或者在constructor里有合理的默认值。增加一个强校验的constructor<br>    2）使用Factory模式来降低调用方复杂度，降低重复性的入参<br>    3）builder模式<br>2、尽量避免public setter<br>    【建议】在有些简单场景里，有时候确实可以比较随意的设置一个值而不会导致不一致性，也建议将方法名重新写为比较“行为化”的命名，会增强其语意。比如setPosition(x, y)可以叫做moveTo(x, y)，setAddress可以叫做assignAddress等。<br>3、通过聚合根保证主子实体的一致性</p>
<p>4、不可以强依赖其他聚合根实体或领域服务<br>    所以，正确的对外部依赖的方法有两种：<br>    1）只保存外部实体的ID：这里我再次强烈建议使用强类型的ID对象，而不是Long型ID。强类型的ID对象不单单能自我包含验证代码，保证ID值的正确性，同时还能确保各种入参不会因为参数顺序变化而出bug。具体可以参考我的Domain Primitive文章。<br>    2）针对于“无副作用”的外部依赖，通过方法入参的方式传入。比如上文中的equip(Weapon，EquipmentService）方法。<br>5、任何实体的行为只能直接影响到本实体（和其子实体）</p>
<h2 id="领域服务Domain-service">2.9. 领域服务Domain service</h2><h3 id="单对象策略性">2.9.1. 单对象策略性</h3><h3 id="跨对象事务型">2.9.2. 跨对象事务型</h3><h3 id="通用组件型">2.9.3. 通用组件型</h3><h2 id="分层">2.10. 分层</h2><h3 id="Interface接口层">2.10.1. Interface接口层</h3><p>接口层主要由以下几个功能组成：</p>
<p>1、网络协议的转化：通常这个已经由各种框架给封装掉了，我们需要构建的类要么是被注解的bean，要么是继承了某个接口的bean。<br>2、统一鉴权：比如在一些需要AppKey+Secret的场景，需要针对某个租户做鉴权的，包括一些加密串的校验<br>3、Session管理：一般在面向用户的接口或者有登陆态的，通过Session或者RPC上下文可以拿到当前调用的用户，以便传递给下游服务。<br>4、限流配置：对接口做限流避免大流量打到下游服务<br>5、前置缓存：针对变更不是很频繁的只读场景，可以前置结果缓存到接口层<br>6、异常处理：通常在接口层要避免将异常直接暴露给调用端，所以需要在接口层做统一的异常捕获，转化为调用端可以理解的数据格式<br>7、日志：在接口层打调用日志，用来做统计和debug等。一般微服务框架可能都直接包含了这些功能。</p>
<p>在DDD的分层架构中，我们单独会抽取出来Interface接口层，作为所有对外的门户，将网络协议和业务逻辑解耦。</p>
<p>Single Responsibility Principle单一职责原则</p>
<h3 id="Application层">2.10.2. Application层</h3><p>Application层的几个核心类：</p>
<ul>
<li>ApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑</li>
<li>DTO Assembler：负责将内部领域模型转化为可对外的DTO</li>
<li>Command、Query、Event对象：作为ApplicationService的入参</li>
<li>返回的DTO：作为ApplicationService的出参</li>
</ul>
<h4 id="cqe对象">2.10.2.1. cqe对象</h4><p>从本质上来看，这几种对象都是Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li>Command指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li>
<li>Query查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li>
<li>Event事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li>
</ul>
<h4 id="cqe和dto对象的区别">2.10.2.2. cqe和dto对象的区别</h4><p>ApplicationService的入参是CQE对象，但是出参却是一个DTO，从代码格式上来看都是简单的POJO对象，那么他们之间有什么区别呢？</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p>但可能最重要的一点：因为CQE是”意图“，所以CQE对象在理论上可以有”无限“个，每个代表不同的意图；但是DTO作为模型数据容器，和模型一一对应，所以是有限的。</p>
<h4 id="cqe的校验">2.10.2.3. cqe的校验</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@Validated</span> <span class="hljs-comment">// Spring的注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CheckoutService</span> </span>&#123;<br>    <span class="hljs-function">OrderDTO <span class="hljs-title">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> </span>&#123; <span class="hljs-comment">// 这里@Valid是JSR-303/380的注解</span><br>        <span class="hljs-comment">// 如果校验失败会抛异常，在interface层被捕捉</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckoutCommand</span> </span>&#123;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;用户未登陆&quot;)</span><br>    <span class="hljs-keyword">private</span> Long userId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span><br>    <span class="hljs-keyword">private</span> Long itemId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Min(value = 1, message = &quot;最少1件&quot;)</span><br>    <span class="hljs-meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer quantity;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="ApplicationService">2.10.3. ApplicationService</h3><h4 id="主要任务">2.10.3.1. 主要任务</h4><p>ApplicationService负责了业务流程的编排，是将原有业务流水账代码剥离了校验逻辑、领域计算、持久化等逻辑之后剩余的流程，是“胶水层”代码。</p>
<h4 id="注意事项">2.10.3.2. 注意事项</h4><p>ApplicationService应该永远返回DTO而不是Entity</p>
<h3 id="DTO-Assembler">2.10.4. DTO Assembler</h3><h4 id="主要任务-1">2.10.4.1. 主要任务</h4><p>因为我们操作的对象是Entity，但是输出的对象是DTO，这里就需要一个专属类型的对象叫DTO Assembler。DTO Assembler的唯一职责是将一个或多个Entity/VO，转化为DTO。注意：DTO Assembler通常不建议有反操作，也就是不会从DTO到Entity，因为通常一个DTO转化为Entity时是无法保证Entity的准确性的。</p>
<h4 id="entity转换成dto的方式">2.10.4.2. entity转换成dto的方式</h4><p>通常，Entity转DTO是有成本的，无论是代码量还是运行时的操作。手写转换代码容易出错，为了节省代码量用Reflection会造成极大的性能损耗。所以这里我还是不遗余力的推荐MapStruct这个库。MapStruct通过静态编译时代码生成，通过写接口和配置注解就可以生成对应的代码，且因为生成的代码是直接赋值，其性能损耗基本可以忽略不计。</p>
<p>Data Mapper，DTO、Entity和DataObject之间的关系如下图：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220719151655073.png" srcset="/gzguo/img/loading.gif" lazyload alt="image-20220719151655073"></p>
<h3 id="Anti-Corruption-Layer防腐层ACL">2.10.5. Anti-Corruption Layer防腐层ACL</h3><p>Repository可以认为是一种特殊的ACL，屏蔽了具体数据操作的细节，即使底层数据库结构变更，数据库类型变更，或者加入其他的持久化方式，Repository的接口保持稳定，ApplicationService就能保持不变。</p>
<h2 id="项目架构分析">2.11. 项目架构分析</h2><p>项目：<br>api模块都是接口<br>service模块都是实现</p>
<p>接口层：web-interface是controller相关代码</p>
<p>服务层：app-api、mdd-adapter、app主要是编排逻辑</p>
<p>领域层：domain-api、domain、adapter-api、repository-api代码逻辑</p>
<p>适配层：adapter、repository、infra-api、infra。包括防腐层、持久化等，为上面的三层提供服务</p>
<p>external-api：假设所有外部依赖都命名为ExternalXXXService</p>
<p>accounting</p>
<p>common</p>
<p>datasheet</p>
<p>message</p>
<p>realco</p>
<p>rule</p>
<h3 id="前台">2.11.1. 前台</h3><p><strong>接口层</strong></p>
<h4 id="fiepam-front-web-interface">2.11.1.1. fiepam-front-web-interface</h4><p>这个模块下面放的都是Controller，和页面端发来的请求进行交互。</p>
<h4 id="fiepam-front-api">2.11.1.2. fiepam-front-api</h4><hr>
<p><strong>服务层</strong></p>
<h4 id="fiepam-front-app">2.11.1.3. fiepam-front-app</h4><p>里面有很多包，还有spring的配置：</p>
<ol>
<li>accounting：action、billrules、plugins、service</li>
<li>common：action、assembler、billrules、customimport、dto、service、util</li>
<li>datasheet：action、billrules、plugins、service</li>
<li>realco：action、pligins、service</li>
<li>report：service</li>
<li>rule：action、billrules、plugins、service</li>
</ol>
<p>action：返回一个Dto对象</p>
<p>billrules：返回一个RuleExecuteResult对象，这个对象里面的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">4932651332894530294L</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> msgCode = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isCancel = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isActionCancel = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">private</span> Object data;<br><span class="hljs-keyword">private</span> String message;<br><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; outParams;<br><span class="hljs-keyword">private</span> List&lt;Object&gt; messages = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList());<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> code = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<p>plugin：触发器</p>
<p>service：里面写的是逻辑，调用增删改查那些</p>
<p>assembler：把一个对象转换成另外的一个对象</p>
<p>customimport：主要是获取、创建、查询</p>
<p>util：工具类</p>
<hr>
<p><strong>领域层</strong></p>
<h4 id="fiepam-front-domain">2.11.1.4. fiepam-front-domain</h4><hr>
<p><strong>适配层</strong></p>
<h4 id="fiepam-front-adapter">2.11.1.5. fiepam-front-adapter</h4><p>里面有mapper的xml配置文件</p>
<h4 id="fiepam-front-infra">2.11.1.6. fiepam-front-infra</h4><p>repository：应该是和最底层的数据库进行交互，真正的增删改查的实现</p>
<p>vo：值对象</p>
<hr>
<h4 id="fiepam-front-bootstrap">2.11.1.7. fiepam-front-bootstrap</h4><p>这个模块下没有java代码，是一些启动配置</p>
<h3 id="中台">2.11.2. 中台</h3><p>external相关的代码，基本上都是通过RemoteDubbo来获取服务，然后返回结果。</p>
<p>open中的实现调用了app-api中的接口</p>
<h2 id="盘点表取数">2.12. 盘点表取数</h2><p>app-api   producequa</p>
<p>app   realwktime   GetDataAppServiceImpl</p>
<p>app   realwktime   GetDataAppServiceFactory   (getData方法，传入FetchDataDTO对象，根据不同的订单号（getBillnum）执行不同的服务)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">(FetchDataDTO dto)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">switch</span> (dto.getBillnum()) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;epcm_producequa_list&quot;</span>:<br>            <span class="hljs-keyword">return</span> produceQuaGetDataService.getData(dto);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;epcm_producequa_card&quot;</span>:<br>            <span class="hljs-keyword">return</span> produceQuaGetDataService.getData(dto);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;epcm_quoper_list&quot;</span>:<br>            <span class="hljs-keyword">return</span> quoPerGetDataService.getData(dto);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;epcm_worktime_list&quot;</span>:<br>            <span class="hljs-keyword">return</span> realWTimeGetDataService.getData(dto);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;epcm_worktime_card&quot;</span>:<br>            <span class="hljs-keyword">return</span> realWTimeGetDataService.getData(dto);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p>“epcm_producequa_list”； “epcm_producequa_card”</p>
<p>这两个的内部会调用domain-api中的接口，domain-api调用domain中的实现。</p>
<blockquote>
<p>domain中的实现类的业务逻辑：</p>
<ol>
<li>要取数的核算对象</li>
<li>期初累积量对象</li>
<li>订单产量数据</li>
<li>当期盘点表数据</li>
<li>投产推荐选项</li>
<li>当期入库数</li>
<li>当期废品数</li>
<li>订单材料</li>
<li>关键子件</li>
<li>累计材料出库记录</li>
<li>联产品折算系数</li>
<li>完工取数</li>
<li>处理期初</li>
<li>当期用到的订单材料</li>
<li>关键子件推算</li>
<li>本期材料出库数据</li>
<li>期初材料出库数据</li>
<li>合并</li>
<li>。。。。</li>
</ol>
</blockquote>
<p>我们主要看盘点表取数部分</p>
<p>盘点表取数的逻辑调用了repository-api的接口，这个接口依然调用repository中的实现，下面是repository中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ProduceQuaBO&gt; <span class="hljs-title">queryCurProduceQua</span><span class="hljs-params">(AccBase accBase, List&lt;String&gt; realCoIds)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String[] fields = <span class="hljs-keyword">new</span> String[] &#123;<br>            ProduceQua.ID, ProduceQua.REALCO, ProduceQua.TOTALQUA, ProduceQua.ACCPURPOSE, ProduceQua.CONTROLSCOPE, ProduceQua.ACCENTITY, ProduceQua.ACCBOOK, ProduceQua.PERIOD, ProduceQua.PERIODCODE,<br>            ProduceQua.WHQUA, ProduceQua.WASTEQUA, ProduceQua.WHQUARED, ProduceQua.FINQUA, ProduceQua.CONFINQUA, ProduceQua.ONPQUA, ProduceQua.TOTALINQUA,<br>    &#125;;<br>    QueryConditionGroup queryConditionGroup = RepositoryHelper.createCommonQueryCondition(accBase, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">if</span>(CollectionUtils.isNotEmpty(realCoIds)) &#123;<br>        queryConditionGroup.addCondition(QueryCondition.name(FieldConsts.DATA_SHEET_REALCO).in(realCoIds));<br>    &#125;<br>    QuerySchema schema = QuerySchema.create().fullname(ProduceQua.ENTITY_NAME).addSelect(fields).addCondition(queryConditionGroup);<br>    List&lt;ProduceQua&gt; produceQuaList = (List&lt;ProduceQua&gt;) fiMaYpdRepository.query(schema);<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(produceQuaList)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    List&lt;ProduceQuaBO&gt; produceQuaBOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (ProduceQua produceQua : produceQuaList) &#123;<br>        ProduceQuaBO produceQuaBO = ProduceQuaAssembler.assembler(produceQua);<br>        produceQuaBOList.add(produceQuaBO);<br>    &#125;<br>    <span class="hljs-keyword">return</span> produceQuaBOList;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然后这个repository调用了框架中的持久化方法进行了持久化。</p>
<h3 id="总结-1">2.12.1. 总结</h3><p>调用关系：</p>
<ol>
<li>app-api</li>
<li>app</li>
<li>domain-api</li>
<li>domain</li>
<li>repository-api</li>
<li>repository</li>
<li>框架底层</li>
</ol>
<p>accBase是四要素</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/gzguo/categories/DDD/">DDD</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/gzguo/tags/DDD/">DDD</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/gzguo/2022/03/10/%E4%B8%9C%E8%BD%AF/mysql/">
                        <span class="hidden-mobile">mysql复习回顾</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"gc226JcELJOJ7J0n4C9IDFd1-gzGzoHsz","appKey":"Ix9equHpEbmzuf2eGJmCgvaB","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/gzguo/js/events.js" ></script>
<script  src="/gzguo/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/gzguo/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script defer src="/gzguo/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  




  
<script src="/gzguo/js/boom.js"></script>
<script src="/gzguo/js/anime.min.js"></script>
<script src="/gzguo/js/qipao.js"></script>
<script src="/gzguo/js/timeDate.js"></script>
<script src="/gzguo/js/APlayer.min.js"></script>
<script src="/gzguo/js/Meting.min.js"></script>
<script src="/gzguo/js/caidai.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/gzguo/js/boot.js" ></script>


</body>
</html>
